agent/                          # ü§ñ MODULAR AGENTIC CHATBOT
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ orchestrator.py            # üéØ Main orchestrator (FSM coordinator)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/                    # üìã Data Models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ intent.py             # BookingIntent model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.py             # ConversationMemory model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state.py              # BookingState enum
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_models.py         # API request/response models
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ engine/                    # üß† Core FSM Engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fsm.py                # ‚úÖ Finite State Machine (FIXED)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state_manager.py     # State management utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ intent_detector.py    # Intent detection logic
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ handlers/                  # üé≠ State-Specific Handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base_handler.py       # Base handler class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ greeting_handler.py   # Greeting state
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service_handler.py    # Service selection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package_handler.py    # Package selection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ details_handler.py    # Details collection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ confirmation_handler.py # Confirmation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ otp_handler.py        # OTP verification
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ info_handler.py       # Info queries
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ extractors/                # üîç Data Extractors
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base_extractor.py     # Base extractor class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone_extractor.py    # Phone number extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email_extractor.py    # Email extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date_extractor.py     # Date extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ name_extractor.py     # Name extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ address_extractor.py  # Address extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pincode_extractor.py  # Pincode extraction
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ country_extractor.py  # Country extraction
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ validators/                # ‚úÖ Data Validators
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone_validator.py    # Phone validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email_validator.py    # Email validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date_validator.py     # Date validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pincode_validator.py  # Pincode validation
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ prompts/                   # üí¨ Prompt Templates
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ system_prompts.py     # System prompts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ templates.py          # Message templates
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ builder.py            # Prompt builder
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/                  # üõ†Ô∏è Business Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory_service.py     # Session memory management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone_service.py      # Phone number services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ otp_service.py        # OTP generation/verification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ booking_service.py    # Booking operations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ knowledge_base_service.py  # ‚úÖ KB + Groq LLM (NEW!)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/                     # üß∞ Utility Functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ patterns.py           # Regex patterns
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.py         # Data formatters
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helpers.py            # Helper functions
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/                    # ‚öôÔ∏è Configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services_config.py    # Services & packages config
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.py           # General settings
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ api/                       # üåê API Layer
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ router.py             # Agent router factory
‚îÇ       ‚îî‚îÄ‚îÄ endpoints.py          # Endpoint handlers
_______

See the structure of my current code...
I have 1 issue..
My all codes are small except orchestrator and fsm...
I want to split them and make modular...
if you can migrate related fields to another folder, then migrate
if you cannot make new modules(folder) for similar content and just use those here in fsm and orchestrator...
For now I will provide you all main files:
_______________________________________

fsm.py:

# agent/engine/fsm.py
"""
Finite State Machine Engine - FIXED with master question starters
"""

import logging
import re
from typing import Tuple, Dict, Any, List, Optional
from datetime import datetime, timedelta

from ..models.intent import BookingIntent
from ..models.state import BookingState
from ..extractors import (
    PhoneExtractor, EmailExtractor, DateExtractor, 
    NameExtractor, AddressExtractor, PincodeExtractor,
    CountryExtractor
)
from ..validators import PhoneValidator, EmailValidator, DateValidator, PincodeValidator
from ..config.services_config import SERVICES, COUNTRIES, COUNTRY_CODES

logger = logging.getLogger(__name__)


class BookingFSM:
    """Core FSM logic for booking flow"""
    
    # Master question starters list (for ALL languages)
    QUESTION_STARTERS = [
        # 1-word starters
        "what", "which", "who", "whom", "whose", "when", "where", "why", "how",
        "list", "show", "tell", "give", "explain", "describe", "compare",
        "define", "clarify", "summarize",

        # 2-word starters
        "what is", "what are", "what does", "what do", "what kind",
        "what type", "how to", "how do", "how can", "how does", "how should",
        "how much", "how many", "how long", "when is", "where is",
        "who is", "who are", "which is", "which are",
        "tell me", "show me", "give me", "explain this", "describe this",
        "list all", "list your", "compare between", "difference between",
        "price of", "cost of", "details of", "information about",

        # 3-word starters
        "what is the", "what are the", "how much does", "how many types",
        "how can i", "how do i", "how does it", "what does it",
        "tell me about", "show me about", "give me details",
        "give me information", "list all services", "list available services",
        "compare the difference", "difference between two",
        "price of the", "cost of the",

        # Polite / conversational starters
        "can you", "could you", "would you", "will you",
        "can you please", "could you please", "would you please",
        "will you please", "can u", "could u",

        # Knowledge / curiosity starters
        "i want to know", "i would like to know",
        "i want information on", "i would like information on",
        "i need information about", "i am looking for information on",
        "i am curious about", "i want details about",
        "i would like details about",

        # Explanation / teaching starters
        "explain to me", "explain it", "explain this to me",
        "describe it", "describe this", "walk me through",
        "help me understand",

        # Availability / offering starters
        "do you have", "do you offer", "do you provide",
        "are you offering", "is there", "are there",
        "is it possible", "are you able to",

        # Pricing / service info starters
        "what is the price", "what is the cost",
        "how much is", "how much are",
        "how much does it cost", "how much do you charge",
        "charges for", "fee for",

        # Soft / indirect starters
        "i was wondering", "i am wondering",
        "just wanted to ask", "just want to ask",
        "need some information", "need some details",
        "looking for information", "looking for details",

        # Command-style info requests
        "tell me the", "show me the", "give me the",
        "say the", "explain the", "describe the",

        # Edge conversational forms
        "can i know", "could i know", "may i know",
        "is it true that", "is this true",
        "what about", "how about"
    ]
    
    # Social media patterns (should trigger off-topic detection)
    SOCIAL_MEDIA_PATTERNS = [
        'instagram', 'facebook', 'twitter', 'youtube', 'linkedin',
        'social media', 'social', 'media', 'follow', 'subscriber', 
        'subscribers', 'channel', 'profile', 'page', 'account',
        'handle', 'username', 'link', 'website', 'web', 'site',
        'online', 'internet', 'net', 'whatsapp channel', 'telegram',
        'tiktok', 'snapchat', 'pinterest'
    ]
    
    # Off-topic patterns (non-booking related)
    OFF_TOPIC_PATTERNS = [
        'hi', 'hello', 'hey', 'good morning', 'good afternoon',
        'good evening', 'how are you', 'how do you do', 'nice to meet you',
        'thank you', 'thanks', 'please', 'sorry', 'excuse me',
        'never mind', 'forget it', 'cancel', 'stop', 'wait',
        'hold on', 'one second', 'one minute', 'just a moment',
        'let me think', 'i think', 'i believe', 'maybe', 'perhaps',
        'could be', 'not sure', 'i don\'t know', 'i forgot',
        'i don\'t remember', 'remind me', 'tell me again'
    ]
    
    # Booking keywords that should override question detection
    BOOKING_KEYWORDS = ["book", "booking", "reserve", "schedule", "appointment"]
    
    def __init__(self):
        """Initialize FSM"""
        self.services = list(SERVICES.keys())
        self.last_shown_list = None
        self.last_shown_service = None
        
        # Initialize extractors
        self.phone_extractor = PhoneExtractor()
        self.email_extractor = EmailExtractor()
        self.date_extractor = DateExtractor()
        self.name_extractor = NameExtractor()
        self.address_extractor = AddressExtractor()
        self.pincode_extractor = PincodeExtractor()
        self.country_extractor = CountryExtractor()
        
        # Initialize validators
        self.phone_validator = PhoneValidator()
        self.email_validator = EmailValidator()
        self.date_validator = DateValidator()
        self.pincode_validator = PincodeValidator()
    
    def process_message(self, message: str, current_state: str, intent: BookingIntent, 
                       language: str = "en", conversation_history: List[Dict] = None) -> Tuple[str, BookingIntent, Dict[str, Any]]:
        """Main FSM processing method"""
        
        try:
            state_enum = BookingState.from_string(current_state)
            logger.info(f"üéØ FSM Processing: {state_enum.value} | Message: '{message[:100]}...'")
            
            # Route to appropriate handler
            handlers = {
                BookingState.GREETING: self._handle_greeting,
                BookingState.INFO_MODE: self._handle_info_mode,
                BookingState.SELECTING_SERVICE: self._handle_service_selection,
                BookingState.SELECTING_PACKAGE: self._handle_package_selection,
                BookingState.COLLECTING_DETAILS: self._handle_details_collection,
                BookingState.CONFIRMING: self._handle_confirmation,
                BookingState.OTP_SENT: self._handle_otp_verification,
            }
            
            handler = handlers.get(state_enum)
            if handler:
                return handler(message, intent, language, conversation_history or [])
            
            # Default fallback
            return (BookingState.GREETING.value, intent, {
                "error": "Invalid state",
                "action": "reset",
                "message": "Let's start over. How can I help you?",
                "understood": True
            })
            
        except Exception as e:
            logger.error(f"FSM processing error: {e}", exc_info=True)
            return (BookingState.GREETING.value, intent, {
                "error": str(e),
                "action": "error",
                "message": "Sorry, I encountered an error. Let's start over.",
                "understood": True
            })
    
    def _handle_greeting(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle greeting state - FIXED to properly switch to info mode"""
        msg_lower = message.lower().strip()
        
        # Check if it's a chat/info request or general conversation
        chat_phrases = [
            'i want to chat', 'just chat', 'talk', 'converse', 'don\'t book',
            'chat mode', 'switch to chat', 'cancel booking', 'stop booking',
            'why are you showing me list', 'dont show me list', 'tell me about',
            'i just want to talk', 'i want to know', 'tell me more',
            'what is', 'how to', 'can you', 'could you'
        ]
        
        # Check for explicit chat/info mode requests
        if any(phrase in msg_lower for phrase in chat_phrases):
            return (BookingState.INFO_MODE.value, intent, {
                "action": "switch_to_info",
                "message": self._get_chat_response(language),
                "mode": "chat",
                "understood": True
            })
        
        # Check if it's a general question (for info mode)
        if self._is_general_question(msg_lower):
            return (BookingState.INFO_MODE.value, intent, {
                "action": "general_question",
                "message": "",  # Will be handled by knowledge base
                "mode": "chat",
                "understood": False  # Let knowledge base handle
            })
        
        # Check if user wants to book
        if self._is_booking_intent(msg_lower):
            self.last_shown_list = "services"
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "ask_service",
                "message": self._get_service_prompt(language),
                "mode": "booking",
                "understood": True
            })
        
        # Check if it's a service listing request (still info mode)
        if 'list' in msg_lower and 'service' in msg_lower:
            return (BookingState.INFO_MODE.value, intent, {
                "action": "list_services",
                "message": self._get_service_prompt(language),
                "mode": "chat",
                "understood": True
            })
        
        # Default: stay in greeting
        return (BookingState.GREETING.value, intent, {
            "action": "greeting",
            "message": self._get_greeting_message(language),
            "mode": "chat",
            "understood": True
        })


    def _get_chat_response(self, language: str) -> str:
        """Get appropriate response for chat mode"""
        if language == "hi":
            return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§ï‡§æ ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§™ ‡§Æ‡•Å‡§ù‡§∏‡•á ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§ì‡§Ç, ‡§ï‡•Ä‡§Æ‡§§‡•ã‡§Ç, ‡§Ø‡§æ ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§™‡•Ç‡§õ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?"
        elif language == "ne":
            return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ‡§ï‡•ã ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Å‡§Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç ‡§Æ‡§∏‡§Å‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç, ‡§Æ‡•Ç‡§≤‡•ç‡§Ø, ‡§µ‡§æ ‡§¨‡•Å‡§ï‡§ø‡§ô‡§ï‡•ã ‡§¨‡§æ‡§∞‡•á‡§Æ‡§æ ‡§∏‡•ã‡§ß‡•ç‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ‡•§ ‡§Ü‡§ú ‡§Æ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§ï‡§∏‡§∞‡•Ä ‡§Æ‡§¶‡•ç‡§¶‡§§ ‡§ó‡§∞‡•ç‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å?"
        else:
            return "Hello! I'm Chirag Sharma's assistant. You can ask me about makeup services, prices, or booking. How can I help you today?"
    

    def _handle_info_mode(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle info mode - user wants information, not booking - FIXED"""
        msg_lower = message.lower().strip()
        
        # Check if user wants to start booking
        if self._is_booking_intent(msg_lower):
            self.last_shown_list = "services"
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "ask_service",
                "message": self._get_service_prompt(language),
                "mode": "booking",
                "understood": True
            })
        
        # Check if it's specifically about booking methods
        if any(phrase in msg_lower for phrase in ['booking method', 'how to book', 'book through', 'book via', 'book using']):
            # This is a specific question about booking methods
            return (BookingState.INFO_MODE.value, intent, {
                "action": "booking_methods_info",
                "message": "",  # Let knowledge base handle
                "mode": "chat",
                "understood": False  # Will be answered by knowledge base
            })
        
        # Check if it's a general question
        if self._is_general_question(msg_lower):
            return (BookingState.INFO_MODE.value, intent, {
                "action": "general_question",
                "message": "",  # Will be handled by knowledge base
                "mode": "chat",
                "understood": False
            })
        
        # Check for exit from info mode (user wants to book)
        if any(phrase in msg_lower for phrase in ['book now', 'start booking', 'i want to book', 'let\'s book', 'proceed with booking']):
            self.last_shown_list = "services"
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "ask_service",
                "message": self._get_service_prompt(language),
                "mode": "booking",
                "understood": True
            })
        
        # Stay in info mode - let knowledge base handle it
        return (BookingState.INFO_MODE.value, intent, {
            "action": "info_conversation",
            "message": "",  # Will be handled by knowledge base
            "mode": "chat",
            "understood": False
        })
    
    def _is_service_question(self, message: str) -> bool:
        """Check if message is asking about services, prices, etc."""
        msg_lower = message.lower()
        
        service_keywords = [
            'price', 'cost', 'charge', 'rate', 'fee',
            'how much', 'what is the price', 'what does it cost',
            'reception', 'senior', 'artist', 'package',
            'list', 'service', 'services', 'offer', 'provide'
        ]
        
        return any(kw in msg_lower for kw in service_keywords)
    
    def _handle_service_selection(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle service selection state"""
        msg_lower = message.lower().strip()
        
        # Check if it's a question
        if self._is_general_question(msg_lower):
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "question_about_service",
                "message": "",  # Will be handled by knowledge base
                "mode": "booking",
                "understood": False
            })
        
        # Check for numeric selection (1-4)
        num_match = re.search(r'\b([1-4])\b', message)
        if num_match:
            idx = int(num_match.group(1)) - 1
            if 0 <= idx < len(self.services):
                service = self.services[idx]
                intent.service = service
                self.last_shown_list = "packages"
                
                logger.info(f"‚úÖ Service selected: {service}")
                return (BookingState.SELECTING_PACKAGE.value, intent, {
                    "action": "service_selected",
                    "message": self._get_package_prompt(service, language),
                    "collected": {"service": service},
                    "mode": "booking",
                    "understood": True
                })
        
        # Check for service keywords
        service = self._extract_service_selection(message)
        if service:
            intent.service = service
            self.last_shown_list = "packages"
            
            logger.info(f"‚úÖ Service selected via keywords: {service}")
            return (BookingState.SELECTING_PACKAGE.value, intent, {
                "action": "service_selected",
                "message": self._get_package_prompt(service, language),
                "collected": {"service": service},
                "mode": "booking",
                "understood": True
            })
        
        # Not understood - show services again
        logger.warning(f"‚ö†Ô∏è Could not extract service from: {message}")
        return (BookingState.SELECTING_SERVICE.value, intent, {
            "action": "retry_service",
            "message": self._get_service_prompt(language),
            "mode": "booking",
            "understood": False
        })
    
    def _handle_package_selection(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle package selection state"""
        if not intent.service:
            # No service selected - go back
            logger.warning("‚ö†Ô∏è No service selected, going back to service selection")
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "ask_service",
                "message": self._get_service_prompt(language),
                "mode": "booking",
                "understood": True
            })
        
        msg_lower = message.lower().strip()
        
        # Check if it's a question
        if self._is_general_question(msg_lower):
            return (BookingState.SELECTING_PACKAGE.value, intent, {
                "action": "question_about_package",
                "message": "",  # Will be handled by knowledge base
                "mode": "booking",
                "understood": False
            })
        
        # Get packages for the selected service
        if intent.service not in SERVICES:
            logger.error(f"‚ùå Service not found in config: {intent.service}")
            return (BookingState.SELECTING_SERVICE.value, intent, {
                "action": "ask_service",
                "message": self._get_service_prompt(language),
                "mode": "booking",
                "understood": True
            })
        
        packages = list(SERVICES[intent.service]["packages"].keys())
        
        # Check for numeric selection
        num_match = re.search(r'\b(\d+)\b', message)
        if num_match:
            idx = int(num_match.group(1)) - 1
            if 0 <= idx < len(packages):
                package = packages[idx]
                intent.package = package
                self.last_shown_list = None
                
                logger.info(f"‚úÖ Package selected: {package} for service: {intent.service}")
                return (BookingState.COLLECTING_DETAILS.value, intent, {
                    "action": "package_selected",
                    "message": self._get_details_prompt(intent, language),
                    "collected": {"package": package},
                    "mode": "booking",
                    "understood": True
                })
            else:
                # Invalid number for this service
                logger.warning(f"‚ö†Ô∏è Invalid package number {idx+1} for service {intent.service}")
        
        # Check for package keywords
        package = self._extract_package_selection(message, intent.service)
        if package:
            intent.package = package
            self.last_shown_list = None
            
            logger.info(f"‚úÖ Package selected via keywords: {package}")
            return (BookingState.COLLECTING_DETAILS.value, intent, {
                "action": "package_selected",
                "message": self._get_details_prompt(intent, language),
                "collected": {"package": package},
                "mode": "booking",
                "understood": True
            })
        
        # Check if user provided name or other details (they might be trying to skip)
        # Extract name to see if they're providing details
        name_data = self.name_extractor.extract(message)
        if name_data and name_data.get("name"):
            # User provided name instead of package - still ask for package
            logger.warning(f"‚ö†Ô∏è User provided name instead of package selection: {message}")
        
        # Not understood - show packages again
        return (BookingState.SELECTING_PACKAGE.value, intent, {
            "action": "retry_package",
            "message": self._get_package_prompt(intent.service, language),
            "mode": "booking",
            "understood": False
        })




    def _handle_details_collection(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle details collection state - FIXED to check off-topic FIRST"""
        msg_lower = message.lower().strip()
        
        # Step 1: Check for completion intent
        if self._is_completion_intent(msg_lower):
            logger.info(f"‚ÑπÔ∏è User wants to complete: {message}")
            if intent.is_complete():
                return (BookingState.CONFIRMING.value, intent, {
                    "action": "ask_confirmation",
                    "message": self._get_confirmation_prompt(intent, language),
                    "mode": "booking",
                    "understood": True
                })
            else:
                missing = intent.missing_fields()
                logger.info(f"‚ÑπÔ∏è Completion intent with missing fields: {missing}")
                return (BookingState.COLLECTING_DETAILS.value, intent, {
                    "action": "ask_details",
                    "message": self._get_collected_summary_prompt(intent, missing, language),
                    "missing": missing,
                    "mode": "booking",
                    "understood": True
                })
        
        # Step 2: Check for off-topic questions BEFORE extracting fields
        if self._is_off_topic_question(msg_lower):
            logger.info(f"‚ùì Detected off-topic question during details collection: {message[:50]}")
            return (BookingState.COLLECTING_DETAILS.value, intent, {
                "action": "off_topic_question",
                "message": "",  # Will be handled by knowledge base
                "mode": "booking",
                "understood": False  # Let orchestrator handle
            })
        
        # Step 3: Check if it's a booking-related question
        if self._is_general_question(msg_lower):
            # Check if it's specifically about the booking details
            booking_detail_keywords = ['name', 'phone', 'email', 'date', 
                                      'location', 'address', 'pincode', 'country']
            has_booking_detail = any(kw in msg_lower for kw in booking_detail_keywords)
            
            if has_booking_detail:
                # It's a question about booking details - handle it
                return (BookingState.COLLECTING_DETAILS.value, intent, {
                    "action": "question_about_details",
                    "message": "",  # Will be handled by knowledge base
                    "mode": "booking",
                    "understood": False
                })
            else:
                # It's a general question during details collection
                return (BookingState.COLLECTING_DETAILS.value, intent, {
                    "action": "general_question_during_details",
                    "message": "",  # Will be handled by knowledge base
                    "mode": "booking",
                    "understood": False
                })
        
        # Step 4: Now try to extract fields (only if not a question)
        extracted = self._extract_all_fields_safe(message, intent, history)
        logger.info(f"‚ÑπÔ∏è Extracted fields from message: {extracted}")
        
        if extracted:
            # Update intent with extracted fields
            updated = False
            collected = {}
            
            for field_name, value in extracted.items():
                if field_name == "phone" and value and not intent.phone:
                    intent.phone = value.get("full_phone") if isinstance(value, dict) else value
                    collected["phone"] = intent.phone
                    updated = True
                    logger.info(f"‚úÖ Collected phone: {intent.phone}")
                elif field_name == "email" and value and not intent.email:
                    intent.email = value
                    collected["email"] = intent.email
                    updated = True
                    logger.info(f"‚úÖ Collected email: {intent.email}")
                elif field_name == "date" and value and not intent.date:
                    intent.date = value
                    collected["date"] = intent.date
                    updated = True
                    logger.info(f"‚úÖ Collected date: {intent.date}")
                elif field_name == "name" and value and not intent.name:
                    intent.name = value
                    collected["name"] = intent.name
                    updated = True
                    logger.info(f"‚úÖ Collected name: {intent.name}")
                elif field_name == "address" and value and not intent.address:
                    # Validate address before accepting
                    if self._is_valid_address(value):
                        intent.address = value
                        collected["address"] = intent.address
                        updated = True
                        logger.info(f"‚úÖ Collected address: {intent.address}")
                    else:
                        logger.warning(f"‚ö†Ô∏è Invalid address detected: {value}")
                elif field_name == "pincode" and value and not intent.pincode:
                    intent.pincode = value
                    collected["pincode"] = intent.pincode
                    updated = True
                    logger.info(f"‚úÖ Collected pincode: {intent.pincode}")
                elif field_name == "country" and value and not intent.service_country:
                    intent.service_country = value
                    collected["service_country"] = intent.service_country
                    updated = True
                    logger.info(f"‚úÖ Collected country: {intent.service_country}")
            
            if updated:
                # Check if all fields are complete
                if intent.is_complete():
                    logger.info(f"‚úÖ All details collected, moving to confirmation")
                    return (BookingState.CONFIRMING.value, intent, {
                        "action": "ask_confirmation",
                        "message": self._get_confirmation_prompt(intent, language),
                        "collected": collected,
                        "mode": "booking",
                        "understood": True
                    })
                
                # Still missing fields - show summary and ask for remaining
                missing = intent.missing_fields()
                logger.info(f"‚ÑπÔ∏è Updated intent, still missing: {missing}")
                
                return (BookingState.COLLECTING_DETAILS.value, intent, {
                    "action": "ask_details",
                    "message": self._get_collected_summary_prompt(intent, missing, language),
                    "collected": collected,
                    "missing": missing,
                    "mode": "booking",
                    "understood": True
                })
        
        # Step 5: If user says they already provided info
        if any(phrase in msg_lower for phrase in ['already gave', 'already told', 'i gave', 'i told', 'i provided']):
            missing = intent.missing_fields()
            logger.info(f"‚ÑπÔ∏è User says they already provided info. Missing: {missing}")
            
            return (BookingState.COLLECTING_DETAILS.value, intent, {
                "action": "clarify_details",
                "message": self._get_collected_summary_prompt(intent, missing, language),
                "missing": missing,
                "mode": "booking",
                "understood": True
            })
        
        # Step 6: Not understood - show what we have and what we need
        missing = intent.missing_fields()
        if missing:
            logger.info(f"‚ÑπÔ∏è Not understood, showing collected summary. Missing: {missing}")
            
            return (BookingState.COLLECTING_DETAILS.value, intent, {
                "action": "ask_details",
                "message": self._get_collected_summary_prompt(intent, missing, language),
                "missing": missing,
                "mode": "booking",
                "understood": False
            })
        
        # Step 7: All fields collected but not confirmed
        return (BookingState.CONFIRMING.value, intent, {
            "action": "ask_confirmation",
            "message": self._get_confirmation_prompt(intent, language),
            "mode": "booking",
            "understood": True
        })
    

    def _extract_all_fields_safe(self, message: str, intent: BookingIntent, history: List = None) -> Dict[str, Any]:
        """Extract fields safely - IMPROVED with better field separation"""
        extracted = {}
        
        # First, extract non-address fields
        extracted_non_address = self._extract_non_address_fields(message, intent)
        extracted.update(extracted_non_address)
        
        # Now extract address from the cleaned message
        if not intent.address:
            # Clean message for address extraction
            cleaned_for_address = self._clean_message_for_address_extraction(message, extracted_non_address)
            
            address_data = self.address_extractor.extract(cleaned_for_address)
            if address_data and address_data.get("address"):
                # Validate the extracted address
                if self._is_valid_address(address_data.get("address")):
                    extracted["address"] = address_data.get("address")
                    logger.info(f"‚úÖ Found address: {address_data.get('address')}")
                else:
                    logger.warning(f"‚ö†Ô∏è Invalid address detected: {address_data.get('address')}")
        
        logger.info(f"üì¶ Extracted fields: {extracted}")
        return extracted

    def _extract_non_address_fields(self, message: str, intent: BookingIntent) -> Dict[str, Any]:
        """Extract all fields except address"""
        extracted = {}
        
        # Extract pincode
        if not intent.pincode:
            pincode_data = self.pincode_extractor.extract(message)
            if pincode_data:
                extracted["pincode"] = pincode_data.get("pincode")
                logger.info(f"‚úÖ Found pincode: {pincode_data.get('pincode')}")
        
        # Extract date
        if not intent.date:
            date_data = self.date_extractor.extract(message)
            if date_data:
                extracted["date"] = date_data.get("date")
                logger.info(f"‚úÖ Found date: {date_data.get('date')}")
        
        # Extract name
        if not intent.name:
            name_data = self.name_extractor.extract(message)
            if name_data and name_data.get("name"):
                extracted["name"] = name_data.get("name")
                logger.info(f"‚úÖ Found name: {name_data.get('name')}")
        
        # Extract phone
        if not intent.phone:
            phone_data = self.phone_extractor.extract(message)
            if phone_data:
                extracted["phone"] = phone_data
                logger.info(f"‚úÖ Found phone: {phone_data}")
        
        # Extract email
        if not intent.email:
            email_data = self.email_extractor.extract(message)
            if email_data:
                extracted["email"] = email_data.get("email")
                logger.info(f"‚úÖ Found email: {email_data.get('email')}")
        
        # Extract country
        if not intent.service_country:
            country_data = self.country_extractor.extract(message)
            if country_data:
                extracted["country"] = country_data.get("country")
                logger.info(f"‚úÖ Found country: {country_data.get('country')}")
        
        return extracted

    def _clean_message_for_address_extraction(self, message: str, extracted_fields: Dict) -> str:
        """Clean message by removing already-extracted fields"""
        cleaned = message
        
        # Remove pincode if found
        if "pincode" in extracted_fields:
            pincode = extracted_fields["pincode"]
            cleaned = re.sub(rf'\b{re.escape(str(pincode))}\b', ' ', cleaned)
        
        # Remove date if found - handle various date formats
        if "date" in extracted_fields:
            date_str = str(extracted_fields["date"])
            
            # Handle different date formats
            date_patterns = [
                # YYYY-MM-DD
                rf'{re.escape(date_str[:4])}[-/]{re.escape(date_str[5:7])}[-/]{re.escape(date_str[8:10])}',
                # Month DD, YYYY variations
                rf'(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{{1,2}}[,\s]+{re.escape(date_str[:4])}',
                rf'{re.escape(date_str[5:7])}/\d{{1,2}}/{re.escape(date_str[:4])}'
            ]
            
            for pattern in date_patterns:
                cleaned = re.sub(pattern, ' ', cleaned, flags=re.IGNORECASE)
        
        # Remove phone if found
        if "phone" in extracted_fields:
            phone = extracted_fields["phone"]
            if isinstance(phone, dict):
                phone_num = phone.get("full_phone", "")
            else:
                phone_num = str(phone)
            
            # Remove phone patterns
            phone_num_digits = re.sub(r'\D', '', phone_num)
            if phone_num_digits:
                # Remove with country code
                if phone_num.startswith('+'):
                    cleaned = re.sub(rf'\b{re.escape(phone_num)}\b', ' ', cleaned)
                # Remove without country code (last 10 digits)
                if len(phone_num_digits) >= 10:
                    last_10 = phone_num_digits[-10:]
                    cleaned = re.sub(rf'\b{re.escape(last_10)}\b', ' ', cleaned)
        
        # Remove email if found
        if "email" in extracted_fields:
            email = extracted_fields["email"]
            cleaned = re.sub(rf'\b{re.escape(email)}\b', ' ', cleaned)
        
        # Remove name if found
        if "name" in extracted_fields:
            name = extracted_fields["name"]
            # Split name into parts and remove each
            name_parts = name.split()
            for part in name_parts:
                if len(part) > 2:  # Only remove significant parts
                    cleaned = re.sub(rf'\b{re.escape(part)}\b', ' ', cleaned, flags=re.IGNORECASE)
        
        # Remove country if found
        if "country" in extracted_fields:
            country = extracted_fields["country"]
            cleaned = re.sub(rf'\b{re.escape(country)}\b', ' ', cleaned, flags=re.IGNORECASE)
        
        # Clean up
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        cleaned = re.sub(r',\s*,', ',', cleaned)
        
        return cleaned
    
    def _is_likely_address(self, message: str) -> bool:
        """Check if message is likely an address (not a question) - IMPROVED"""
        msg_lower = message.lower().strip()
        
        # Check for question indicators
        for starter in self.QUESTION_STARTERS:
            if msg_lower.startswith(starter):
                return False
        
        # Check for social media patterns
        for pattern in self.SOCIAL_MEDIA_PATTERNS:
            if pattern in msg_lower:
                return False
        
        # Check for off-topic patterns
        for pattern in self.OFF_TOPIC_PATTERNS:
            if pattern in msg_lower:
                return False
        
        # Known city names that are likely addresses
        city_names = [

            # =======================
            # üáÆüá≥ INDIA (50 cities)
            # =======================
            "delhi", "new delhi", "mumbai", "bangalore", "bengaluru", "chennai",
            "kolkata", "hyderabad", "pune", "ahmedabad", "jaipur", "lucknow",
            "kanpur", "nagpur", "indore", "thane", "bhopal", "visakhapatnam",
            "patna", "vadodara", "ghaziabad", "ludhiana", "agra", "nashik",
            "faridabad", "meerut", "rajkot", "kalyan", "vasai", "varanasi",
            "srinagar", "aurangabad", "dhanbad", "amritsar", "allahabad",
            "prayagraj", "howrah", "gwalior", "jabalpur", "coimbatore",
            "vijayawada", "madurai", "trichy", "salem", "tiruppur",
            "erode", "kochi", "trivandrum", "thrissur",

            # =======================
            # üá≥üáµ NEPAL (50 cities)
            # =======================
            "kathmandu", "lalitpur", "patan", "bhaktapur", "kirtipur",
            "pokhara", "bharatpur", "biratnagar", "morang", "birgunj", "hetauda",
            "janakpur", "dharan", "itahari", "inaruwa", "damak",
            "birtamod", "mechinagar", "butwal", "bhairahawa", "siddharthanagar",
            "tansen", "palpa", "nepalgunj", "kohalpur", "dang",
            "ghorahi", "tulsipur", "surkhet", "dailekh", "dhangadhi",
            "mahendranagar", "attariya", "dadeldhura", "jumla", "dolpa",
            "banepa", "dhulikhel", "panauti", "chitwan", "ratnanagar",
            "sauraha", "illam", "phidim", "taplejung", "baglung",
            "myagdi", "besishahar", "lamjung", "syangja",

            # =======================
            # üáµüá∞ PAKISTAN
            # =======================
            "karachi", "lahore", "islamabad", "rawalpindi", "faisalabad",
            "multan", "gujranwala", "sialkot", "bahawalpur", "sukkur",
            "larkana", "hyderabad pakistan", "quetta", "peshawar", "mardan",
            "abbottabad", "mansehra", "swat", "mingora", "kohat",
            "dera ghazi khan", "dera ismail khan", "rahim yar khan",
            "sheikhupura", "kasur", "okara", "sahiwal",

            # =======================
            # üáßüá© BANGLADESH
            # =======================
            "dhaka", "chittagong", "chattogram", "khulna", "rajshahi",
            "sylhet", "barisal", "rangpur", "mymensingh", "comilla",
            "cumilla", "gazipur", "narayanganj", "tangail", "narsingdi",
            "bogura", "bogra", "pabna", "jessore", "jashore",
            "kushtia", "faridpur", "gopalganj", "madaripur",
            "shariatpur", "bhola", "noakhali", "feni", "cox's bazar",

            # =======================
            # üá¶üá™ DUBAI / UAE (Dubai-centric)
            # =======================
            "dubai", "deira", "bur dubai", "karama", "satwa",
            "jumeirah", "jumeirah beach residence", "jbr", "marina",
            "dubai marina", "business bay", "downtown dubai",
            "al barsha", "al quoz", "al nahda", "al qasimia",
            "mirdif", "muhaisnah", "international city",
            "discovery gardens", "jebel ali", "dubai south",
            "motor city", "sports city", "silicon oasis",
            "ras al khor", "al rigga", "al garhoud"
        ]

        
        # Check if it contains a city name
        has_city = any(city in msg_lower for city in city_names)
        
        # Check for address-like patterns
        address_indicators = [
            # Street types
            'street', 'st.', 'st', 'road', 'rd.', 'rd', 'lane', 'ln.',
            'avenue', 'ave.', 'ave', 'boulevard', 'blvd.', 'blvd',
            'drive', 'dr.', 'dr', 'circle', 'cir.', 'court', 'ct.',
            # Building terms
            'house', 'flat', 'apartment', 'apt.', 'apt', 'building', 'bldg.',
            'floor', 'fl.', 'room', 'rm.', 'suite', 'ste.', 'unit',
            # Location terms
            'colony', 'sector', 'area', 'locality', 'village', 'town',
            'city', 'district', 'state', 'county', 'province', 'region',
            # Indian specific
            'nagar', 'marg', 'path', 'gali', 'chowk', 'ward', 'mohalla',
            # Number patterns
            'no.', 'number', '#', 'plot', 'phase', 'extension'
        ]
        
        # Must contain at least ONE address indicator OR a city name
        has_address_indicator = any(ind in msg_lower for ind in address_indicators)
        
        # Should be reasonably long
        word_count = len(msg_lower.split())
        
        return (has_city or has_address_indicator) and word_count >= 1

    

    def _is_valid_address(self, address: str) -> bool:
        """Validate address string - improved to accept cities"""
        if not address or len(address) < 3:
            return False
        
        addr_lower = address.lower()
        
        # Check for question patterns (should not be in address)
        for starter in self.QUESTION_STARTERS:
            if addr_lower.startswith(starter):
                return False
        
        # Check for social media patterns
        for pattern in self.SOCIAL_MEDIA_PATTERNS:
            if pattern in addr_lower:
                return False
        
        # Check for valid address components
        address_components = [
            # Street types
            'street', 'road', 'lane', 'avenue', 'boulevard', 'drive', 'circle',
            # Building terms
            'house', 'flat', 'apartment', 'building', 'floor', 'room', 'suite',
            # Location terms
            'colony', 'sector', 'area', 'locality', 'village', 'town',
            'city', 'district', 'state', 'county', 'province', 'region',
            # Number patterns
            'no.', 'number', '#', 'plot', 'phase', 'extension'
        ]
        
        city_names = [

            # =======================
            # üáÆüá≥ INDIA (50 cities)
            # =======================
            "delhi", "new delhi", "mumbai", "bangalore", "bengaluru", "chennai",
            "kolkata", "hyderabad", "pune", "ahmedabad", "jaipur", "lucknow",
            "kanpur", "nagpur", "indore", "thane", "bhopal", "visakhapatnam",
            "patna", "vadodara", "ghaziabad", "ludhiana", "agra", "nashik",
            "faridabad", "meerut", "rajkot", "kalyan", "vasai", "varanasi",
            "srinagar", "aurangabad", "dhanbad", "amritsar", "allahabad",
            "prayagraj", "howrah", "gwalior", "jabalpur", "coimbatore",
            "vijayawada", "madurai", "trichy", "salem", "tiruppur",
            "erode", "kochi", "trivandrum", "thrissur",

            # =======================
            # üá≥üáµ NEPAL (50 cities)
            # =======================
            "kathmandu", "lalitpur", "patan", "bhaktapur", "kirtipur",
            "pokhara", "bharatpur", "biratnagar", "morang", "birgunj", "hetauda",
            "janakpur", "dharan", "itahari", "inaruwa", "damak",
            "birtamod", "mechinagar", "butwal", "bhairahawa", "siddharthanagar",
            "tansen", "palpa", "nepalgunj", "kohalpur", "dang",
            "ghorahi", "tulsipur", "surkhet", "dailekh", "dhangadhi",
            "mahendranagar", "attariya", "dadeldhura", "jumla", "dolpa",
            "banepa", "dhulikhel", "panauti", "chitwan", "ratnanagar",
            "sauraha", "illam", "phidim", "taplejung", "baglung",
            "myagdi", "besishahar", "lamjung", "syangja",

            # =======================
            # üáµüá∞ PAKISTAN
            # =======================
            "karachi", "lahore", "islamabad", "rawalpindi", "faisalabad",
            "multan", "gujranwala", "sialkot", "bahawalpur", "sukkur",
            "larkana", "hyderabad pakistan", "quetta", "peshawar", "mardan",
            "abbottabad", "mansehra", "swat", "mingora", "kohat",
            "dera ghazi khan", "dera ismail khan", "rahim yar khan",
            "sheikhupura", "kasur", "okara", "sahiwal",

            # =======================
            # üáßüá© BANGLADESH
            # =======================
            "dhaka", "chittagong", "chattogram", "khulna", "rajshahi",
            "sylhet", "barisal", "rangpur", "mymensingh", "comilla",
            "cumilla", "gazipur", "narayanganj", "tangail", "narsingdi",
            "bogura", "bogra", "pabna", "jessore", "jashore",
            "kushtia", "faridpur", "gopalganj", "madaripur",
            "shariatpur", "bhola", "noakhali", "feni", "cox's bazar",

            # =======================
            # üá¶üá™ DUBAI / UAE (Dubai-centric)
            # =======================
            "dubai", "deira", "bur dubai", "karama", "satwa",
            "jumeirah", "jumeirah beach residence", "jbr", "marina",
            "dubai marina", "business bay", "downtown dubai",
            "al barsha", "al quoz", "al nahda", "al qasimia",
            "mirdif", "muhaisnah", "international city",
            "discovery gardens", "jebel ali", "dubai south",
            "motor city", "sports city", "silicon oasis",
            "ras al khor", "al rigga", "al garhoud"
        ]
        
        # Check if it's a known city
        is_city = any(city in addr_lower for city in city_names)
        
        # Check for address components
        has_component = any(comp in addr_lower for comp in address_components)
        
        # Check word count
        word_count = len(address.split())
        
        # Valid if:
        # 1. It's a known city (even single word like "Delhi"), OR
        # 2. It has address components and is at least 2 words
        return (is_city and word_count >= 1) or (has_component and word_count >= 2)

    def _get_collected_summary_prompt(self, intent: BookingIntent, missing_fields: List[str], language: str) -> str:
        """Get prompt showing collected info and asking for missing fields"""
        
        # Check if date needs year
        date_info = intent.metadata.get('date_info', {}) if hasattr(intent, 'metadata') and intent.metadata else {}
        needs_year = date_info.get('needs_year', False)
        date_original = date_info.get('original', '')
        
        # Get what we've collected
        collected_summary = intent.get_summary()
        
        # Field display names
        field_display = {
            "en": {
                "name": "Full Name",
                "phone": "WhatsApp Number",
                "email": "Email",
                "date": "Event Date",
                "address": "Event Location",
                "pincode": "PIN Code",
                "service_country": "Country"
            },
            "hi": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "date": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "address": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "ne": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞",
                "email": "‡§á‡§Æ‡•á‡§≤",
                "date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø",
                "address": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "mr": {
                "name": "‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "address": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            }
        }
        
        lang_display = field_display.get(language, field_display["en"])
        
        if language == "hi":
            prompt = "üìã **‡§Ü‡§™‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä:**\n\n"
        elif language == "ne":
            prompt = "üìã **‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä:**\n\n"
        elif language == "mr":
            prompt = "üìã **‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä:**\n\n"
        else:
            prompt = "üìã **Your Information:**\n\n"
        
        # Show collected fields
        has_collected = False
        for field, value in collected_summary.items():
            if value:  # Only show if we have a value
                display_name = lang_display.get(field.lower().replace(" ", "_"), field)
                prompt += f"‚úÖ **{display_name}:** {value}\n"
                has_collected = True
        
        if has_collected:
            prompt += "\n"
        
        # Special handling for missing year
        if needs_year and date_original:
            if language == "hi":
                prompt += f"üìÖ **‡§Ü‡§™‡§®‡•á ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡•Ä: '{date_original}' ‡§≤‡•á‡§ï‡§ø‡§® ‡§∏‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§ø‡§Ø‡§æ‡•§**\n"
                prompt += "**‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§æ‡§≤ ‡§¶‡•á‡§Ç (‡§ú‡•à‡§∏‡•á 2025, 2026):**"
            elif language == "ne":
                prompt += f"üìÖ **‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡•á ‡§Æ‡§ø‡§§‡§ø ‡§¶‡§ø‡§®‡•Å‡§≠‡§Ø‡•ã: '{date_original}' ‡§§‡§∞ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§≠‡§è‡§®‡•§**\n"
                prompt += "**‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç (‡§ú‡§∏‡•ç‡§§‡•à 2025, 2026):**"
            elif language == "mr":
                prompt += f"üìÖ **‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡§ø‡§≤‡•Ä: '{date_original}' ‡§™‡§£ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§≤‡•á ‡§®‡§æ‡§π‡•Ä.**\n"
                prompt += "**‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡•ç‡§Ø‡§æ (‡§â‡§¶‡§æ. 2025, 2026):**"
            else:
                prompt += f"üìÖ **You provided date: '{date_original}' but not the year.**\n"
                prompt += "**Please provide the year (e.g., 2025, 2026):**"
            
            return prompt
        
        # Show missing fields
        if missing_fields:
            missing_display = [lang_display.get(field, field) for field in missing_fields]
            
            if language == "hi":
                prompt += "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§Ç:**\n"
            elif language == "ne":
                prompt += "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**\n"
            elif language == "mr":
                prompt += "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ç‡§Ø‡§æ:**\n"
            else:
                prompt += "üìù **Please provide:**\n"
            
            for field in missing_display:
                prompt += f"‚Ä¢ {field}\n"
            
            # Add format hints for specific fields
            if "phone" in missing_fields:
                if language == "hi":
                    prompt += "\nüí° **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞:** ‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• (+919876543210)"
                elif language == "ne":
                    prompt += "\nüí° **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞:** ‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§Ç‡§ó (+9779876543210)"
                elif language == "mr":
                    prompt += "\nüí° **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞:** ‡§¶‡•á‡§∂ ‡§ï‡•ã‡§°‡§∏‡§π (+919876543210)"
                else:
                    prompt += "\nüí° **WhatsApp Number:** with country code (+919876543210)"
        
        return prompt
    
    def _handle_confirmation(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle confirmation state"""
        msg_lower = message.lower().strip()
        
        # Check if it's a question
        if self._is_general_question(msg_lower):
            return (BookingState.CONFIRMING.value, intent, {
                "action": "question_during_confirmation",
                "message": "",
                "mode": "booking",
                "understood": False
            })
        
        # Check for confirmation
        if any(word in msg_lower for word in ['yes', 'confirm', 'correct', 'proceed', 'ok', 'yeah', 'yep', '‡§π‡§æ‡§Ç', '‡§π‡•ã']):
            return (BookingState.OTP_SENT.value, intent, {
                "action": "send_otp",
                "mode": "booking",
                "understood": True
            })
        
        # Check for rejection/change
        if any(word in msg_lower for word in ['no', 'cancel', 'wrong', 'change', 'edit', '‡§®‡§π‡•Ä‡§Ç', '‡§π‡•ã‡§á‡§®']):
            return (BookingState.COLLECTING_DETAILS.value, intent, {
                "action": "ask_details",
                "message": "What would you like to change? Please provide the corrected information.",
                "mode": "booking",
                "understood": True
            })
        
        # Not understood
        return (BookingState.CONFIRMING.value, intent, {
            "action": "retry_confirmation",
            "message": "Please reply 'yes' to confirm or 'no' to make changes.",
            "mode": "booking",
            "understood": False
        })
    
    def _handle_otp_verification(self, message: str, intent: BookingIntent, language: str, history: List) -> Tuple[str, BookingIntent, Dict]:
        """Handle OTP verification state"""
        msg_lower = message.lower().strip()
        
        # Check if it's a question
        if self._is_general_question(msg_lower):
            return (BookingState.OTP_SENT.value, intent, {
                "action": "question_during_otp",
                "message": "",
                "mode": "booking",
                "understood": False
            })
        
        # Check for OTP
        otp_match = re.search(r'\b(\d{6})\b', message)
        if otp_match:
            return (BookingState.OTP_SENT.value, intent, {
                "action": "verify_otp",
                "otp": otp_match.group(1),
                "mode": "booking",
                "understood": True
            })
        
        # Check for resend request
        if any(word in msg_lower for word in ['resend', 'send again', 'missed', "didn't get", 'not received']):
            return (BookingState.OTP_SENT.value, intent, {
                "action": "resend_otp",
                "mode": "booking",
                "understood": True
            })
        
        # Not understood
        return (BookingState.OTP_SENT.value, intent, {
            "action": "ask_otp",
            "message": "Please enter the 6-digit OTP sent to your WhatsApp.",
            "mode": "booking",
            "understood": False
        })
    
    # Helper methods (keep existing ones but fix the issues)
    def _is_booking_intent(self, message: str) -> bool:
        """Check if message indicates booking intent"""
        booking_keywords = ['book', 'booking', 'reserve', 'schedule', 'appointment',
                           'i want to book', 'want to book', 'book service', 'i want your', 
                           'your services', 'your service', 'best services']
        msg_lower = message.lower()
        return any(kw in msg_lower for kw in booking_keywords)
    
    def _is_general_question(self, message: str) -> bool:
        """Check if message is a general question using master list - FIXED"""
        msg_lower = message.lower().strip()
        
        # Check for question mark
        if '?' in message:
            return True
        
        # Check if it starts with any question starter
        for starter in self.QUESTION_STARTERS:
            if msg_lower.startswith(starter):
                # Safety filter: check if it contains booking keywords
                # If it's about booking, it's NOT a general question (it's booking-related)
                if any(b in msg_lower for b in self.BOOKING_KEYWORDS):
                    return False
                return True
        
        # Check for social media patterns
        for pattern in self.SOCIAL_MEDIA_PATTERNS:
            if pattern in msg_lower:
                # If it's asking about social media, it's a general question
                return True
        
        # Check for off-topic patterns
        for pattern in self.OFF_TOPIC_PATTERNS:
            if pattern in msg_lower and len(msg_lower.split()) <= 5:
                return True
        
        return False


    def _is_off_topic_question(self, message: str) -> bool:
        """Check if message is off-topic (not related to booking details) - FIXED"""
        msg_lower = message.lower().strip()
        
        # Check for social media patterns
        for pattern in self.SOCIAL_MEDIA_PATTERNS:
            if pattern in msg_lower:
                return True
        
        # Check if it's a question starter AND doesn't contain booking detail keywords
        booking_detail_keywords = [
            'name', 'phone', 'number', 'email', 'mail',
            'date', 'day', 'month', 'year', 'time',
            'address', 'location', 'place', 'venue',
            'pincode', 'zipcode', 'postal', 'code',
            'country', 'city', 'state', 'district',
            'event', 'function', 'ceremony', 'wedding',
            'my ', 'i ', 'me ', 'mine '  # Personal pronouns
        ]
        
        # Check if it's a question
        is_question = False
        for starter in self.QUESTION_STARTERS:
            if msg_lower.startswith(starter):
                is_question = True
                break
        
        if is_question:
            # Check if it contains booking detail keywords
            has_booking_detail = any(kw in msg_lower for kw in booking_detail_keywords)
            
            # If it's a question but doesn't have booking details, it's off-topic
            if not has_booking_detail:
                return True
        
        # Check for specific off-topic patterns
        off_topic_patterns = [
            'instagram', 'facebook', 'youtube', 'channel',
            'follow', 'subscribe', 'social media',
            'contact', 'reach', 'get in touch',
            'website', 'online', 'web',
            'about you', 'about your', 'who are you',
            'what do you do', 'where are you',
            'experience', 'portfolio', 'gallery',
            'rating', 'review', 'feedback', 'testimonial'
        ]
        
        for pattern in off_topic_patterns:
            if pattern in msg_lower:
                return True
        
        return False
    
    def _is_completion_intent(self, message: str) -> bool:
        """Check if user wants to complete details"""
        completion_keywords = ['done', 'finish', 'complete', 'proceed', 'confirm', 
                              'go ahead', 'all set', 'ready', 'submit']
        msg_lower = message.lower()
        return any(kw in msg_lower for kw in completion_keywords)
    
    def _extract_service_selection(self, message: str) -> Optional[str]:
        """Extract service from message"""
        msg_lower = message.lower()
        
        service_patterns = {
            "Bridal Makeup Services": ['bridal', 'bride', 'wedding', 'marriage'],
            "Party Makeup Services": ['party', 'function', 'celebration'],
            "Engagement & Pre-Wedding Makeup": ['engagement', 'pre-wedding', 'sangeet'],
            "Henna (Mehendi) Services": ['henna', 'mehendi', 'mehndi', 'mehandi']
        }
        
        for service, keywords in service_patterns.items():
            for keyword in keywords:
                if keyword in msg_lower:
                    return service
        
        return None
    
    def _extract_package_selection(self, message: str, service: str) -> Optional[str]:
        """Extract package from message for given service"""
        if service not in SERVICES:
            return None
        
        msg_lower = message.lower()
        packages = list(SERVICES[service]["packages"].keys())
        
        # First check exact package names
        for package in packages:
            package_lower = package.lower()
            if package_lower in msg_lower:
                return package
        
        # Check for keywords
        package_keywords = {
            "Chirag's Signature Bridal Makeup": ['signature', 'chirag', 'premium'],
            "Luxury Bridal Makeup (HD / Brush)": ['luxury', 'hd', 'brush', 'high definition'],
            "Reception / Engagement / Cocktail Makeup": ['reception', 'cocktail', 'engagement'],
            "Chirag Sharma": ['chirag', 'artist'],
            "Senior Artist": ['senior'],
            "Signature Package": ['signature'],
            "Luxury Package": ['luxury', 'premium'],
            "Basic Package": ['basic', 'simple', 'cheapest'],
            "Henna by Chirag Sharma": ['chirag', 'premium', 'signature'],
            "Henna by Senior Artist": ['senior']
        }
        
        for package, keywords in package_keywords.items():
            if package in packages:
                for keyword in keywords:
                    if keyword in msg_lower:
                        return package
        
        return None
    
    def _extract_all_fields(self, message: str, intent: BookingIntent, history: List = None) -> Dict[str, Any]:
        """Extract all possible fields from message with year handling"""
        extracted = {}
        
        # Initialize metadata if not exists
        if not hasattr(intent, 'metadata') or intent.metadata is None:
            intent.metadata = {}
        
        # DEBUG: Log what we're trying to extract
        logger.info(f"üîç Extracting fields from: {message}")
        
        # Extract pincode FIRST (before other fields might interfere)
        if not intent.pincode:
            logger.info(f"üîç Looking for pincode in: {message}")
            pincode_data = self.pincode_extractor.extract(message)
            if pincode_data:
                extracted["pincode"] = pincode_data.get("pincode")
                logger.info(f"‚úÖ Found pincode: {pincode_data.get('pincode')}")
            else:
                logger.warning(f"‚ùå No pincode extracted from: {message}")
        
        # Extract date (only if not already collected)
        if not intent.date:
            date_data = self.date_extractor.extract(message)
            if date_data:
                extracted["date"] = date_data.get("date")
                
                # Store date metadata for year handling
                intent.metadata['date_info'] = {
                    'needs_year': date_data.get('needs_year', False),
                    'assumed_year': date_data.get('assumed_year'),
                    'method': date_data.get('method', 'unknown'),
                    'original': date_data.get('original', ''),
                    'confidence': date_data.get('confidence', 'medium')
                }
                logger.info(f"‚úÖ Found date: {date_data.get('date')}")
        
        # Extract name (only if not already collected)
        if not intent.name:
            name_data = self.name_extractor.extract(message)
            if name_data and name_data.get("name"):
                extracted["name"] = name_data.get("name")
                logger.info(f"‚úÖ Found name: {name_data.get('name')}")
        
        # Extract phone (only if not already collected)
        if not intent.phone:
            phone_data = self.phone_extractor.extract(message)
            if phone_data:
                extracted["phone"] = phone_data
                logger.info(f"‚úÖ Found phone: {phone_data}")
        
        # Extract email (only if not already collected)
        if not intent.email:
            email_data = self.email_extractor.extract(message)
            if email_data:
                extracted["email"] = email_data.get("email")
                logger.info(f"‚úÖ Found email: {email_data.get('email')}")
        
        # Extract address (only if not already collected)
        if not intent.address:
            address_data = self.address_extractor.extract(message)
            if address_data:
                extracted["address"] = address_data.get("address")
                logger.info(f"‚úÖ Found address: {address_data.get('address')}")
        
        # Extract country (only if not already collected)
        if not intent.service_country:
            country_data = self.country_extractor.extract(message)
            if country_data:
                extracted["country"] = country_data.get("country")
                logger.info(f"‚úÖ Found country: {country_data.get('country')}")
        
        logger.info(f"üì¶ Final extracted fields: {extracted}")
        return extracted
    
    def _extract_year_from_message(self, message: str) -> Optional[int]:
        """Extract year from message (e.g., 2025, 2026)"""
        year_match = re.search(r'\b(20[2-9][0-9]|2100)\b', message)
        if year_match:
            try:
                year = int(year_match.group(1))
                # Validate year is reasonable (2023-2100)
                current_year = datetime.now().year
                if current_year - 1 <= year <= current_year + 10:
                    return year
            except (ValueError, TypeError):
                pass
        return None

    
    def _handle_year_response(self, message: str, intent: BookingIntent, language: str) -> Tuple[str, BookingIntent, Dict]:
        """Handle when user provides year after partial date"""
        year = self._extract_year_from_message(message)
        
        if year:
            # Check if we have a date that needs year
            date_info = intent.metadata.get('date_info', {})
            
            if date_info.get('needs_year', False) and intent.date:
                try:
                    # Update the date with correct year
                    from datetime import datetime
                    old_date = datetime.strptime(intent.date, '%Y-%m-%d')
                    new_date = old_date.replace(year=year)
                    intent.date = new_date.strftime('%Y-%m-%d')
                    
                    # Update metadata
                    intent.metadata['date_info']['needs_year'] = False
                    intent.metadata['date_info']['user_provided_year'] = year
                    intent.metadata['date_info']['assumed_year'] = year
                    
                    # Show updated summary
                    missing = intent.missing_fields()
                    
                    return (BookingState.COLLECTING_DETAILS.value, intent, {
                        "action": "year_provided",
                        "message": f"‚úÖ Updated year to {year}. {self._get_collected_summary_prompt(intent, missing, language)}",
                        "mode": "booking",
                        "understood": True
                    })
                except Exception as e:
                    logger.error(f"Error updating year: {e}")
        
        # If no valid year found, ask for it
        date_original = intent.metadata.get('date_info', {}).get('original', 'the date')
        
        if language == "hi":
            prompt = f"üìÖ **‡§Ü‡§™‡§®‡•á ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡•Ä: '{date_original}' ‡§≤‡•á‡§ï‡§ø‡§® ‡§∏‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§ø‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§æ‡§≤ ‡§¶‡•á‡§Ç (‡§ú‡•à‡§∏‡•á 2025, 2026):**"
        elif language == "ne":
            prompt = f"üìÖ **‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡•á ‡§Æ‡§ø‡§§‡§ø ‡§¶‡§ø‡§®‡•Å‡§≠‡§Ø‡•ã: '{date_original}' ‡§§‡§∞ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§≠‡§è‡§®‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç (‡§ú‡§∏‡•ç‡§§‡•à 2025, 2026):**"
        elif language == "mr":
            prompt = f"üìÖ **‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡§ø‡§≤‡•Ä: '{date_original}' ‡§™‡§£ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§≤‡•á ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡•ç‡§Ø‡§æ (‡§â‡§¶‡§æ. 2025, 2026):**"
        else:
            prompt = f"üìÖ **You provided date: '{date_original}' but not the year. Please provide the year (e.g., 2025, 2026):**"
        
        return (BookingState.COLLECTING_DETAILS.value, intent, {
            "action": "ask_year",
            "message": prompt,
            "mode": "booking",
            "understood": False
        })

    # Prompt methods
    def _get_greeting_message(self, language: str) -> str:
        """Get greeting message"""
        if language == "hi":
            return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§ï‡§æ ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?"
        elif language == "ne":
            return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ‡§ï‡•ã ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Å‡§Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô‡§Æ‡§æ ‡§ï‡§∏‡§∞‡•Ä ‡§Æ‡§¶‡•ç‡§¶‡§§ ‡§ó‡§∞‡•ç‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å?"
        elif language == "mr":
            return "‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞! ‡§Æ‡•Ä ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§Ø‡§æ‡§Ç‡§ö‡§æ ‡§∏‡§π‡§æ‡§Ø‡•ç‡§Ø‡§ï ‡§Ü‡§π‡•á. ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§Æ‡•Ä ‡§ï‡§∂‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã?"
        else:
            return "Hello! I'm Chirag Sharma's assistant. How can I help you with your booking?"
    
    def _get_service_prompt(self, language: str) -> str:
        """Get service selection prompt"""
        if language == "hi":
            return """üéØ **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç:**

1. **‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™
2. **‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§™‡§æ‡§∞‡•ç‡§ü‡§ø‡§Ø‡•ã‡§Ç ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™
3. **‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§î‡§∞ ‡§™‡•ç‡§∞‡•Ä-‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™** - ‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™
4. **‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç

**‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ (1-4) ‡§ö‡•Å‡§®‡•á‡§Ç ‡§Ø‡§æ ‡§∏‡•á‡§µ‡§æ ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§**"""
        elif language == "ne":
            return """üéØ **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç:**

1. **‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™
2. **‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™
3. **‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü ‡§∞ ‡§™‡•ç‡§∞‡•Ä-‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™** - ‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü ‡§∏‡§Æ‡§æ‡§∞‡•ã‡§π‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™
4. **‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç

**‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Æ‡•ç‡§¨‡§∞ (1-4) ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§∏‡•á‡§µ‡§æ‡§ï‡•ã ‡§®‡§æ‡§Æ ‡§≤‡•á‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§**"""
        elif language == "mr":
            return """üéØ **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•á‡§µ‡§æ:**

1. **‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ** - ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§Ø‡§æ‡§Ç‡§ö‡•ç‡§Ø‡§æ‡§ï‡§°‡•Ç‡§® ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™
2. **‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ** - ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Ü‡§£‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§™‡•ç‡§∞‡§∏‡§Ç‡§ó‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™
3. **‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§Ü‡§£‡§ø ‡§™‡•ç‡§∞‡•Ä-‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™** - ‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§´‡§Ç‡§ï‡•ç‡§∂‡§®‡§∏‡§æ‡§†‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™
4. **‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ** - ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Ü‡§£‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§™‡•ç‡§∞‡§∏‡§Ç‡§ó‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä ‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ

**‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï (1-4) ‡§®‡§ø‡§µ‡§°‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§∏‡•á‡§µ‡•á‡§ö‡•á ‡§®‡§æ‡§µ ‡§≤‡§ø‡§π‡§æ.**"""
        else:
            return """üéØ **Available Services:**

1. **Bridal Makeup Services** - Premium bridal makeup by Chirag Sharma
2. **Party Makeup Services** - Makeup for parties and special occasions
3. **Engagement & Pre-Wedding Makeup** - Makeup for engagement functions
4. **Henna (Mehendi) Services** - Henna services for bridal and special occasions

**Please choose a number (1-4) or type the service name.**"""
    
    def _get_package_prompt(self, service: str, language: str) -> str:
        """Get package selection prompt - FIXED to show correct packages"""
        if service not in SERVICES:
            logger.error(f"‚ùå Service not found: {service}")
            return f"Sorry, service '{service}' not found. Please choose from available services."
        
        packages = SERVICES[service]["packages"]
        
        if language == "hi":
            prompt = f"üì¶ **{service} ‡§ï‡•á ‡§™‡•à‡§ï‡•á‡§ú:**\n\n"
            for idx, (pkg_name, price) in enumerate(packages.items(), 1):
                prompt += f"{idx}. **{pkg_name}** - {price}\n"
            prompt += f"\n**‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ (1-{len(packages)}) ‡§ö‡•Å‡§®‡•á‡§Ç ‡§Ø‡§æ ‡§™‡•à‡§ï‡•á‡§ú ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§**"
            return prompt
        elif language == "ne":
            prompt = f"üì¶ **{service} ‡§ï‡•ã ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú‡§π‡§∞‡•Ç:**\n\n"
            for idx, (pkg_name, price) in enumerate(packages.items(), 1):
                prompt += f"{idx}. **{pkg_name}** - {price}\n"
            prompt += f"\n**‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Æ‡•ç‡§¨‡§∞ (1-{len(packages)}) ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú‡§ï‡•ã ‡§®‡§æ‡§Æ ‡§≤‡•á‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§**"
            return prompt
        elif language == "mr":
            prompt = f"üì¶ **{service} ‡§ö‡•á ‡§™‡•Ö‡§ï‡•á‡§ú:**\n\n"
            for idx, (pkg_name, price) in enumerate(packages.items(), 1):
                prompt += f"{idx}. **{pkg_name}** - {price}\n"
            prompt += f"\n**‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï (1-{len(packages)}) ‡§®‡§ø‡§µ‡§°‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§™‡•Ö‡§ï‡•á‡§ú‡§ö‡•á ‡§®‡§æ‡§µ ‡§≤‡§ø‡§π‡§æ.**"
            return prompt
        else:
            prompt = f"üì¶ **Packages for {service}:**\n\n"
            for idx, (pkg_name, price) in enumerate(packages.items(), 1):
                prompt += f"{idx}. **{pkg_name}** - {price}\n"
            prompt += f"\n**Please choose a number (1-{len(packages)}) or type the package name.**"
            return prompt
    
    def _get_details_prompt(self, intent: BookingIntent, language: str) -> str:
        """Get details collection prompt - ASK FOR ALL DETAILS AT ONCE"""
        if language == "hi":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á‡§Ç:**

‡§Ü‡§™ ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§Ø‡§æ ‡§è‡§ï-‡§è‡§ï ‡§ï‡§∞‡§ï‡•á:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§ú‡•à‡§∏‡•á +919876543210):
‚Ä¢ **‡§à‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ** (‡§ú‡•à‡§∏‡•á 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +919876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä, 110001, ‡§≠‡§æ‡§∞‡§§"

‡§Ü‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?"""
        elif language == "ne":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

‡§§‡§™‡§æ‡§à‡§Ç ‡§è‡§ï‡•à ‡§™‡§ü‡§ï ‡§∏‡§¨‡•à ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ ‡§µ‡§æ ‡§è‡§ï-‡§è‡§ï ‡§ó‡§∞‡•á‡§∞:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§, ‡§ú‡§∏‡•ç‡§§‡•à +9779876543210):
‚Ä¢ **‡§á‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø** (‡§ú‡§∏‡•ç‡§§‡•à 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +9779876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§ï‡§æ‡§†‡§Æ‡§æ‡§°‡•å‡§Ç, 44600, ‡§®‡•á‡§™‡§æ‡§≤"

‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•á ‡§π‡•ã?"""
        elif language == "mr":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•á ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§¶‡•ç‡§Ø‡§æ:**

‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§è‡§ï‡§æ‡§ö ‡§µ‡•á‡§≥‡•Ä ‡§∏‡§∞‡•ç‡§µ ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§¶‡•á‡§ä ‡§∂‡§ï‡§§‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§è‡§ï-‡§è‡§ï ‡§ï‡§∞‡•Ç‡§®:

‚Ä¢ **‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§°‡§∏‡§π, ‡§â‡§¶‡§æ. +919876543210):
‚Ä¢ **‡§à‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ** (‡§â‡§¶‡§æ. 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≥/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +919876543210, ramesh@email.com, 15 ‡§è‡§™‡•ç‡§∞‡§ø‡§≤ 2025, ‡§Æ‡•Å‡§Ç‡§¨‡§à, 400001, ‡§≠‡§æ‡§∞‡§§"

‡§§‡•Å‡§Æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ ‡§ï‡§æ‡§Ø ‡§Ü‡§π‡•á?"""
        else:
            return """üìã **Please provide your details:**

You can provide all details at once or one by one:

‚Ä¢ **Full Name:**
‚Ä¢ **WhatsApp Number** (with country code, e.g., +919876543210):
‚Ä¢ **Email:**
‚Ä¢ **Event Date** (e.g., March 25, 2025):
‚Ä¢ **Event Location:**
‚Ä¢ **PIN Code:**
‚Ä¢ **Country** (India/Nepal/Pakistan/Bangladesh/Dubai):

**Example:** "Ramesh Kumar, +919876543210, ramesh@email.com, April 15, 2025, Delhi, 110001, India"

What is your full name?"""
    
    def _get_missing_fields_prompt(self, missing_fields: List[str], language: str) -> str:
        """Get prompt for missing fields"""
        if not missing_fields:
            return "All details collected!"
        
        # Map field names to display names
        field_names = {
            "en": {
                "name": "full name",
                "phone": "phone number with country code",
                "email": "email address",
                "event_date": "event date",
                "location": "event location",
                "pincode": "PIN code",
                "service_country": "country"
            },
            "hi": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "event_date": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "location": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "ne": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞",
                "email": "‡§á‡§Æ‡•á‡§≤",
                "event_date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø",
                "location": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "mr": {
                "name": "‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "event_date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "location": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            }
        }
        
        lang_fields = field_names.get(language, field_names["en"])
        
        # Get display names for missing fields
        display_fields = [lang_fields.get(field, field) for field in missing_fields]
        
        if len(display_fields) == 1:
            if language == "hi":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§Ç:** {display_fields[0]}"
            elif language == "ne":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** {display_fields[0]}"
            elif language == "mr":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ç‡§Ø‡§æ:** {display_fields[0]}"
            else:
                return f"üìã **Please provide:** {display_fields[0]}"
        else:
            if language == "hi":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§Ç:** {', '.join(display_fields)}"
            elif language == "ne":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** {', '.join(display_fields)}"
            elif language == "mr":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ç‡§Ø‡§æ:** {', '.join(display_fields)}"
            else:
                return f"üìã **Please provide:** {', '.join(display_fields)}"
    
    def _get_confirmation_prompt(self, intent: BookingIntent, language: str) -> str:
        """Get confirmation prompt"""
        summary = intent.get_summary()
        
        if language == "hi":
            prompt = "üéØ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç:**\n\n"
            for field, value in summary.items():
                prompt += f"‚Ä¢ **{field}:** {value}\n"
            prompt += "\n**‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§∏‡§π‡•Ä ‡§π‡•à?** ('‡§π‡§æ‡§Ç' ‡§Ø‡§æ '‡§®‡§π‡•Ä‡§Ç')"
            return prompt
        elif language == "ne":
            prompt = "üéØ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**\n\n"
            for field, value in summary.items():
                prompt += f"‚Ä¢ **{field}:** {value}\n"
            prompt += "\n**‡§ï‡•á ‡§∏‡§¨‡•à ‡§†‡•Ä‡§ï ‡§õ?** ('‡§π‡•ã' ‡§µ‡§æ '‡§π‡•ã‡§á‡§®')"
            return prompt
        elif language == "mr":
            prompt = "üéØ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä ‡§ï‡§∞‡§æ:**\n\n"
            for field, value in summary.items():
                prompt += f"‚Ä¢ **{field}:** {value}\n"
            prompt += "\n**‡§∏‡§∞‡•ç‡§µ ‡§ï‡§æ‡§π‡•Ä ‡§¨‡§∞‡•ã‡§¨‡§∞ ‡§Ü‡§π‡•á ‡§ï‡§æ?** ('‡§π‡•ã' ‡§ï‡§ø‡§Ç‡§µ‡§æ '‡§®‡§æ‡§π‡•Ä')"
            return prompt
        else:
            prompt = "üéØ **Please confirm your booking:**\n\n"
            for field, value in summary.items():
                prompt += f"‚Ä¢ **{field}:** {value}\n"
            prompt += "\n**Is everything correct?** (Reply 'yes' or 'no')"
            return prompt


orchestrator.py:

# agent/orchestrator.py
"""
Agent Orchestrator - FIXED with proper question answering during booking
"""

import logging
import secrets
from datetime import datetime
from typing import Dict, Any, Optional, Tuple, List
import re

from .models.memory import ConversationMemory
from .models.state import BookingState
from .models.api_models import AgentChatResponse
from .engine.fsm import BookingFSM
from .services.memory_service import MemoryService
from .services.otp_service import OTPService
from .services.booking_service import BookingService
from .services.knowledge_base_service import KnowledgeBaseService
from .engine.intent_detector import IntentDetector
from .prompts.templates import PromptTemplates

logger = logging.getLogger(__name__)


class AgentOrchestrator:
    """Main orchestrator for agent operations"""
    
    # Maximum off-track attempts before switching to chat mode
    MAX_OFF_TRACK_ATTEMPTS = 6
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize orchestrator"""
        self.config = config or {}
        
        # Initialize components
        self._initialize_components()
        
        logger.info("AgentOrchestrator initialized")
    
    def _initialize_components(self):
        """Initialize all components (FSM, services, handlers)"""
        self.fsm = BookingFSM()
        self.memory_service = MemoryService()
        self.intent_detector = IntentDetector()
        self.prompt_templates = PromptTemplates()
        
        # Initialize knowledge base service
        try:
            from database import knowledge_collection
            self.knowledge_base_service = KnowledgeBaseService(knowledge_collection)
        except ImportError:
            logger.warning("Knowledge collection not found, using default")
            self.knowledge_base_service = KnowledgeBaseService()
        
        # Services will be initialized when needed
        self.otp_service = None
        self.booking_service = None
        
        logger.info("All components initialized")
    
    async def process_message(self, message: str, session_id: Optional[str] = None, language: str = "en") -> Dict[str, Any]:
        """Main entry point for processing user messages"""
        try:
            logger.info(f"Processing message: session={session_id}, lang={language}, msg='{message[:50]}...'")
            
            # Validate input
            if not message or len(message.strip()) == 0:
                return self._build_error_response("Message cannot be empty", session_id)
            
            # Get or create session
            memory = self._get_or_create_session(session_id, language)
            
            # Check for exit/restart requests
            if self._is_exit_request(message):
                return await self._handle_exit(memory, language)
            
            if self._is_restart_request(message):
                return await self._handle_restart(memory, language)

            # NEW: Check for chat mode requests
            if self._is_chat_request(message):
                logger.info(f"üìû User requested chat mode: {message[:50]}")
                return await self._switch_to_chat_mode(memory, language)

            # Check for OTP resend request BEFORE processing
            if memory.stage == BookingState.OTP_SENT.value:
                if self._is_resend_otp_request(message):
                    return await self._handle_resend_otp(memory, language)
            
            # Add user message to history
            memory.add_message("user", message)
            
            # Process through FSM
            fsm_result = self.fsm.process_message(
                message=message,
                current_state=memory.stage,
                intent=memory.intent,
                language=language,
                conversation_history=memory.conversation_history
            )
            
            next_state, updated_intent, metadata = fsm_result
            
            # Check if FSM understood the message
            fsm_understood = metadata.get("understood", False)
            
            if fsm_understood:
                # FSM understood - reset off-track counter
                memory.off_track_count = 0
                
                # Update memory
                memory.intent = updated_intent
                memory.stage = next_state
                
                # Handle special actions
                action = metadata.get("action")
                
                if action == "send_otp":
                    return await self._handle_send_otp(memory, language)
                elif action == "verify_otp":
                    otp = metadata.get("otp")
                    return await self._handle_verify_otp(otp, memory, language)
                elif action == "resend_otp":
                    return await self._handle_resend_otp(memory, language)
                
                # Update last shown list if provided
                if hasattr(self.fsm, 'last_shown_list'):
                    memory.last_shown_list = self.fsm.last_shown_list
                
                # Add assistant response to history if provided
                reply = metadata.get("message", "")
                if reply:
                    memory.add_message("assistant", reply)
                
                # Update session
                self.memory_service.update_session(memory.session_id, memory)
                
                # Build response
                return await self._handle_fsm_result(fsm_result, message, memory, language)
            
            else:
                # ‚úÖ FSM did NOT understand - this is a QUESTION during booking
                logger.info(f"üìö FSM detected QUESTION during booking, answering...")
                
                # Increment off-track counter
                memory.off_track_count += 1
                
                # Check if we should switch to chat mode
                if memory.off_track_count >= self.MAX_OFF_TRACK_ATTEMPTS:
                    logger.info(f"‚ö†Ô∏è Too many off-track attempts ({memory.off_track_count}), switching to chat mode")
                    return await self._switch_to_chat_mode(memory, language)
                
                # ‚úÖ Handle as question during booking
                return await self._handle_question_during_booking(message, memory, language)
            
        except Exception as e:
            logger.error(f"Error processing message: {e}", exc_info=True)
            
            session_id_for_error = session_id if session_id else secrets.token_urlsafe(8)
            
            return self._build_error_response(
                "Sorry, I encountered an error. Please try again.",
                session_id_for_error
            )
    


    async def _handle_question_during_booking(self, message: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Answer question using knowledge base and continue booking - IMPROVED"""
        try:
            logger.info(f"üìö Answering question during booking (off-track count: {memory.off_track_count}/{self.MAX_OFF_TRACK_ATTEMPTS})")
            
            msg_lower = message.lower()
            
            # 1. Check if we're asking for year (date completion)
            date_info = memory.intent.metadata.get('date_info', {})
            if date_info.get('needs_year', False):
                if self._is_year_response(message):
                    return await self._handle_year_response(message, memory, language)
            
            # 2. Check for chat requests
            if self._is_chat_request(msg_lower):
                logger.info(f"üìû User requested chat mode during booking")
                return await self._switch_to_chat_mode(memory, language)
            
            # 3. Check for service comparison requests
            requested_service = self._extract_requested_service(msg_lower)
            if requested_service and memory.intent.service != requested_service:
                return await self._handle_service_comparison(message, requested_service, memory, language)
            
            # 4. Handle booking-specific questions first (these are critical for flow)
            booking_specific_answer = await self._handle_booking_specific_questions(message, memory, language)
            if booking_specific_answer:
                # We have a booking-specific answer, show it with continuation
                return await self._show_answer_with_continuation(booking_specific_answer, message, memory, language)
            
            # 5. For ALL OTHER questions, use knowledge base
            # Build context about current booking state
            context = self._build_booking_context(memory)
            
            # Get answer from knowledge base
            answer = await self.knowledge_base_service.get_answer(message, language, context)
            
            # If knowledge base returns answer, use it
            if answer:
                return await self._show_answer_with_continuation(answer, message, memory, language)
            
            # 6. Fallback for when knowledge base has no answer
            # Only use generic fallback, not specific content
            fallback_answer = self._get_generic_fallback_answer(message, language)
            return await self._show_answer_with_continuation(fallback_answer, message, memory, language)
            
        except Exception as e:
            logger.error(f"Error answering question: {e}", exc_info=True)
            return await self._handle_question_error(memory, language, e)
    

    def _is_year_response(self, message: str) -> bool:
        """Check if message contains a valid year"""
        year_match = re.search(r'\b(20[2-9][0-9]|2100)\b', message)
        return bool(year_match)

    def _is_chat_request(self, message: str) -> bool:
        """Check if user wants to switch to chat mode"""
        msg_lower = message.lower().strip()
        
        chat_keywords = [
            'i want to chat', 'want to chat', 'let\'s chat', 'just chat',
            'don\'t book', 'don\'t ask me to book', 'not booking',
            'just talking', 'only chat', 'chat only', 'chat mode',
            'talk about', 'discuss', 'have a conversation', 'chat',
            'converse', 'talk', 'speak', 'have a talk', 'have discussion',
            'cancel booking and chat', 'stop booking and chat',
            'no booking just chat', 'skip booking'
        ]
        
        return any(kw in msg_lower for kw in chat_keywords)

    def is_service_switch_request(self, message: str) -> Tuple[bool, Optional[str]]:
        """Check if user wants to switch to a different service"""
        msg_lower = message.lower()
        
        # First exclude social media questions
        social_keywords =[
            'instagram', 'facebook', 'twitter', 'youtube', 'linkedin',
            'social media', 'social', 'media', 'follow', 'subscriber', 
            'subscribers', 'channel', 'profile', 'page', 'account',
            'handle', 'username', 'link', 'website', 'web', 'site',
            'online', 'internet', 'net', 'whatsapp channel', 'telegram',
            'tiktok', 'snapchat', 'pinterest'
        ]
        if any(keyword in msg_lower for keyword in social_keywords):
            return False, None
        
        switch_patterns = {
            'bridal': 'Bridal Makeup Services',
            'bride': 'Bridal Makeup Services',
            'wedding': 'Bridal Makeup Services',
            'party': 'Party Makeup Services',
            'function': 'Party Makeup Services',
            'celebration': 'Party Makeup Services',
            'engagement': 'Engagement & Pre-Wedding Makeup',
            'pre-wedding': 'Engagement & Pre-Wedding Makeup',
            'sangeet': 'Engagement & Pre-Wedding Makeup',
            'henna': 'Henna (Mehendi) Services',
            'mehendi': 'Henna (Mehendi) Services',
            'mehndi': 'Henna (Mehendi) Services'
        }
        
        for keyword, service in switch_patterns.items():
            if keyword in msg_lower:
                # Check if this is different from current
                return True, service
        
        return False, None




    def _extract_requested_service(self, message: str) -> Optional[str]:
        """Extract service name from message"""
        msg_lower = message.lower()
        
        # First check if it's about social media (not a service)
        social_keywords = [
            'instagram', 'facebook', 'twitter', 'youtube', 'linkedin',
            'social media', 'social', 'media', 'follow', 'subscriber', 
            'subscribers', 'channel', 'profile', 'page', 'account',
            'handle', 'username', 'link', 'website', 'web', 'site',
            'online', 'internet', 'net', 'whatsapp channel', 'telegram',
            'tiktok', 'snapchat', 'pinterest']
        if any(keyword in msg_lower for keyword in social_keywords):
            return None
        
        # Only then check for services
        service_keywords = {
            'bridal': 'Bridal Makeup Services',
            'party': 'Party Makeup Services', 
            'engagement': 'Engagement & Pre-Wedding Makeup',
            'pre-wedding': 'Engagement & Pre-Wedding Makeup',
            'henna': 'Henna (Mehendi) Services',
            'mehendi': 'Henna (Mehendi) Services',
            'mehndi': 'Henna (Mehendi) Services'
        }
        
        for keyword, service_name in service_keywords.items():
            if keyword in msg_lower:
                return service_name
        
        return None

    async def _handle_booking_specific_questions(
        self,
        message: str,
        memory: ConversationMemory,
        language: str
    ) -> Optional[str]:
        """Handle booking-specific questions that need special handling"""

        msg_lower = message.lower().strip()

        # --------------------------------------------------
        # 0Ô∏è‚É£ FIX: Address incorrectly contains date info
        # --------------------------------------------------
        if memory.intent.address:
            address_lower = memory.intent.address.lower()

            month_names = [
                "january", "february", "march", "april", "may", "june",
                "july", "august", "september", "october", "november", "december",
                # short forms (very important)
                "jan", "feb", "mar", "apr", "jun", "jul",
                "aug", "sep", "sept", "oct", "nov", "dec"
            ]

            has_month = any(month in address_lower for month in month_names)
            has_year = any(year in address_lower for year in ["2024", "2025", "2026", "2027", "2028"])

            # Heuristic: month + year OR number + month
            if has_month and (has_year or any(ch.isdigit() for ch in address_lower)):
                memory.intent.address = None
                logger.warning(
                    "Cleared address field because it contained date-like information"
                )

        # --------------------------------------------------
        # 1Ô∏è‚É£ HARD EXCLUSION: Social / Online presence queries
        # --------------------------------------------------
        social_media_keywords = [
            "instagram", "facebook", "twitter", "x", "youtube", "linkedin",
            "social media", "social", "media", "follow", "followers",
            "subscriber", "subscribers", "channel", "profile", "page",
            "account", "handle", "username", "link", "website", "web",
            "site", "online", "internet", "net", "whatsapp channel",
            "telegram", "tiktok", "snapchat", "pinterest"
        ]

        if any(k in msg_lower for k in social_media_keywords):
            return None

        # --------------------------------------------------
        # 2Ô∏è‚É£ PRICE / PACKAGE / ARTIST QUESTIONS
        # --------------------------------------------------
        price_keywords = [
            "price", "cost", "charges", "fee", "rate",
            "how much", "pricing", "budget"
        ]

        package_keywords = [
            "package", "packages", "plan", "plans",
            "lowest", "cheapest", "minimum", "basic",
            "premium", "luxury", "highest", "expensive"
        ]

        artist_keywords = [
            "senior", "junior", "artist", "makeup artist",
            "reception", "engagement", "cocktail"
        ]

        if any(k in msg_lower for k in price_keywords + package_keywords + artist_keywords):

            if "reception" in msg_lower:
                return self.prompt_templates.get_service_price_info(
                    "Reception",
                    language
                )

            if "senior" in msg_lower:
                return self.prompt_templates.get_service_price_info(
                    "Senior Artist",
                    language
                )

            if "cheapest" in msg_lower or "lowest" in msg_lower:
                return self.prompt_templates.get_lowest_price_package(language)

            if "premium" in msg_lower or "luxury" in msg_lower:
                return self.prompt_templates.get_premium_package(language)

            if memory.intent.service:
                return self.prompt_templates.get_service_price_info(
                    memory.intent.service,
                    language
                )

            return self.prompt_templates.get_service_details(language)

        # --------------------------------------------------
        # 3Ô∏è‚É£ LIST / OFFERING QUESTIONS
        # --------------------------------------------------
        list_keywords = [
            "list", "services", "what do you offer",
            "what services", "what are your services",
            "show services", "available services",
            "explain services", "service details"
        ]

        if any(k in msg_lower for k in list_keywords):
            return self.prompt_templates.get_service_details(language)

        # --------------------------------------------------
        # 4Ô∏è‚É£ SERVICE COMPARISON FLOW
        # --------------------------------------------------
        comparison_state = memory.intent.metadata.get(
            "service_comparison", {}
        )

        if comparison_state.get("waiting_for_response", False):
            return await self._handle_service_switch_response(
                message,
                memory,
                language
            )

        # --------------------------------------------------
        # 5Ô∏è‚É£ NOT HANDLED HERE ‚Üí fallback
        # --------------------------------------------------
        return None


    async def _handle_service_comparison(self, message: str, requested_service: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle when user asks about different service"""
        logger.info(f"üîç User asking about different service: {requested_service}")
        
        # Answer the question about that service
        context = f"User is currently selecting package for {memory.intent.service}. They are asking about {requested_service}."
        answer = await self.knowledge_base_service.get_answer(message, language, context)
        
        if not answer:
            # Fallback answer
            answer = f"For detailed information about {requested_service}, you can select it from our services list."
        
        # Show comparison: Current service vs Asked service
        if memory.intent.service:
            current_service_info = self.prompt_templates.get_service_price_info(memory.intent.service, language)
            asked_service_info = self.prompt_templates.get_service_price_info(requested_service, language)
            
            reply = f"{answer}\n\nüéØ **Comparison:**\n\n"
            reply += f"**Current Selection:** {memory.intent.service}\n{current_service_info}\n\n"
            reply += f"**{requested_service}:**\n{asked_service_info}\n\n"
            
            # Ask if they want to switch services
            if language == "hi":
                reply += "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏ ‡§∏‡•á‡§µ‡§æ ‡§ï‡•ã ‡§ö‡•Å‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á? (‡§π‡§æ‡§Ç/‡§®‡§π‡•Ä‡§Ç)"
            elif language == "ne":
                reply += "‡§ï‡•á ‡§§‡§™‡§æ‡§à‡§Ç ‡§Ø‡•ã ‡§∏‡•á‡§µ‡§æ ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§® ‡§ö‡§æ‡§π‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ? (‡§π‡•ã/‡§π‡•ã‡§á‡§®)"
            elif language == "mr":
                reply += "‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§π‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§®‡§ø‡§µ‡§°‡§æ‡§Ø‡§ö‡•Ä ‡§Ü‡§π‡•á ‡§ï‡§æ? (‡§π‡•ã/‡§®‡§æ‡§π‡•Ä)"
            else:
                reply += "Would you like to select this service instead? (yes/no)"
            
            # Set a flag to handle service switching
            memory.intent.metadata['service_comparison'] = {
                'requested_service': requested_service,
                'waiting_for_response': True
            }
            
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="service_comparison",
                metadata={
                    "current_service": memory.intent.service,
                    "requested_service": requested_service,
                    "off_track_count": memory.off_track_count
                }
            )

    async def _handle_service_switch_response(self, message: str, memory: ConversationMemory, language: str) -> Optional[str]:
        """Handle user's response to service switch question"""
        msg_lower = message.lower()
        
        if 'yes' in msg_lower or '‡§π‡§æ‡§Ç' in msg_lower or '‡§π‡•ã' in msg_lower:
            # User wants to switch services
            requested_service = memory.intent.metadata['service_comparison']['requested_service']
            previous_service = memory.intent.service
            memory.intent.service = requested_service
            memory.intent.package = None  # Reset package selection
            memory.intent.metadata.pop('service_comparison', None)
            
            logger.info(f"üîÑ User switched service from {previous_service} to {requested_service}")
            
            # Move to package selection for new service
            memory.stage = BookingState.SELECTING_PACKAGE.value
            
            reply = f"‚úÖ **Switched to {requested_service}**\n\n"
            reply += self.fsm._get_package_prompt(requested_service, language)
            
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            # This returns None because we're handling it directly
            return None
        
        elif 'no' in msg_lower or '‡§®‡§π‡•Ä‡§Ç' in msg_lower or '‡§π‡•ã‡§á‡§®' in msg_lower:
            # User doesn't want to switch, clear comparison flag
            memory.intent.metadata.pop('service_comparison', None)
            return "Okay, let's continue with your current selection."
        
        return None

    async def _show_answer_with_continuation(self, answer: str, original_question: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Show answer and appropriate booking continuation"""
        # Get current state and missing fields
        state_enum = BookingState.from_string(memory.stage)
        missing = memory.intent.missing_fields()
        
        # Get appropriate continuation based on state
        continuation = ""
        
        if state_enum == BookingState.CONFIRMING:
            summary = memory.intent.get_summary()
            continuation = self.prompt_templates.get_confirmation_prompt(summary, language)
        
        elif state_enum == BookingState.COLLECTING_DETAILS and missing:
            continuation = self.fsm._get_collected_summary_prompt(memory.intent, missing, language)
        
        elif state_enum == BookingState.SELECTING_PACKAGE and memory.intent.service:
            continuation = self.fsm._get_package_prompt(memory.intent.service, language)
        
        else:
            try:
                continuation = self._get_booking_continuation(state_enum, memory, language)
            except AttributeError as e:
                logger.error(f"Error getting booking continuation: {e}")
                continuation = "How can I help you with your booking?"
        
        # Format final reply
        if answer and continuation:
            reply = f"{answer}\n\n{continuation}"
        elif answer:
            reply = answer
        else:
            reply = continuation
        
        memory.add_message("assistant", reply)
        self.memory_service.update_session(memory.session_id, memory)
        
        return self._build_response(
            reply=reply,
            memory=memory,
            action="question_answered",
            metadata={
                "question": original_question,
                "answer": answer,
                "off_track_count": memory.off_track_count,
                "max_attempts": self.MAX_OFF_TRACK_ATTEMPTS
            }
        )

    def _get_generic_fallback_answer(self, message: str, language: str) -> str:
        """Get generic fallback answer when knowledge base has no answer"""
        # VERY generic fallback - no specific content
        if language == "hi":
            return "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Ç ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç‡•§"
        elif language == "ne":
            return "‡§Æ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Ø‡§π‡§æ‡§Å ‡§õ‡•Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§æ‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§"
        elif language == "mr":
            return "‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§á‡§•‡•á ‡§Ü‡§π‡•á. ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∏‡•Å‡§∞‡•Ç ‡§†‡•á‡§µ‡§æ."
        else:
            return "I'm here for your information. Please continue with your booking."

    async def _handle_question_error(self, memory: ConversationMemory, language: str, error: Exception) -> Dict[str, Any]:
        """Handle errors in question answering"""
        logger.error(f"Question answering error: {error}")
        
        # Fallback: just continue with booking
        state_enum = BookingState.from_string(memory.stage)
        try:
            continuation = self._get_booking_continuation(state_enum, memory, language)
        except AttributeError:
            if language == "hi":
                continuation = "‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç‡•§"
            elif language == "ne":
                continuation = "‡§¨‡•Å‡§ï‡§ø‡§ô ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§æ‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§"
            else:
                continuation = "Continue with booking."
        
        reply = f"I understand. {continuation}"
        memory.add_message("assistant", reply)
        self.memory_service.update_session(memory.session_id, memory)
        
        return self._build_response(
            reply=reply,
            memory=memory,
            action="continue",
            metadata={"error": str(error)}
        )


    async def _handle_year_response(self, message: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle year response for partial dates"""
        year_match = re.search(r'\b(20[2-9][0-9]|2100)\b', message)
        
        if year_match:
            year = int(year_match.group(1))
            # Update date with year
            date_info = memory.intent.metadata.get('date_info', {})
            
            if date_info.get('needs_year', False) and memory.intent.date:
                try:
                    from datetime import datetime
                    old_date = datetime.strptime(memory.intent.date, '%Y-%m-%d')
                    new_date = old_date.replace(year=year)
                    memory.intent.date = new_date.strftime('%Y-%m-%d')
                    
                    # Update metadata
                    memory.intent.metadata['date_info']['needs_year'] = False
                    memory.intent.metadata['date_info']['user_provided_year'] = year
                    
                    # Show updated summary
                    missing = memory.intent.missing_fields()
                    continuation = self.fsm._get_collected_summary_prompt(memory.intent, missing, language)
                    
                    reply = f"‚úÖ Updated year to {year}. {continuation}"
                    memory.add_message("assistant", reply)
                    self.memory_service.update_session(memory.session_id, memory)
                    
                    return self._build_response(
                        reply=reply,
                        memory=memory,
                        action="year_provided",
                        metadata={"year": year}
                    )
                except Exception as e:
                    logger.error(f"Error updating year: {e}")
        
        # If no valid year, ask again
        date_original = memory.intent.metadata.get('date_info', {}).get('original', 'the date')
        
        if language == "hi":
            reply = f"üìÖ **‡§Ü‡§™‡§®‡•á ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡•Ä: '{date_original}' ‡§≤‡•á‡§ï‡§ø‡§® ‡§∏‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§ø‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§æ‡§≤ ‡§¶‡•á‡§Ç (‡§ú‡•à‡§∏‡•á 2025, 2026):**"
        elif language == "ne":
            reply = f"üìÖ **‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡•á ‡§Æ‡§ø‡§§‡§ø ‡§¶‡§ø‡§®‡•Å‡§≠‡§Ø‡•ã: '{date_original}' ‡§§‡§∞ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§≠‡§è‡§®‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç (‡§ú‡§∏‡•ç‡§§‡•à 2025, 2026):**"
        elif language == "mr":
            reply = f"üìÖ **‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡§ø‡§≤‡•Ä: '{date_original}' ‡§™‡§£ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡§ø‡§≤‡•á ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§∞‡•ç‡§∑ ‡§¶‡•ç‡§Ø‡§æ (‡§â‡§¶‡§æ. 2025, 2026):**"
        else:
            reply = f"üìÖ **You provided date: '{date_original}' but not the year. Please provide the year (e.g., 2025, 2026):**"
        
        memory.add_message("assistant", reply)
        self.memory_service.update_session(memory.session_id, memory)
        
        return self._build_response(
            reply=reply,
            memory=memory,
            action="ask_year",
            metadata={"error": "Invalid year provided"}
        )






    def _get_booking_continuation(self, state_enum: BookingState, memory: ConversationMemory, language: str) -> str:
        """Get the next step to continue booking - FIXED"""
        
        if state_enum == BookingState.GREETING:
            return self.prompt_templates.get_service_list(language)
        
        elif state_enum == BookingState.SELECTING_SERVICE:
            return self.prompt_templates.get_service_list(language)

        elif state_enum == BookingState.INFO_MODE:
            # In info mode, just acknowledge we're in chat mode
            if language == "hi":
                return "‡§Æ‡•à‡§Ç ‡§∏‡•Ç‡§ö‡§®‡§æ ‡§Æ‡•ã‡§° ‡§Æ‡•á‡§Ç ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§™ ‡§Æ‡•Å‡§ù‡§∏‡•á ‡§ï‡•Å‡§õ ‡§≠‡•Ä ‡§™‡•Ç‡§õ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§"
            elif language == "ne":
                return "‡§Æ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§Æ‡•ã‡§°‡§Æ‡§æ ‡§õ‡•Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç ‡§Æ‡§∏‡§Å‡§ó ‡§ï‡•á‡§π‡§ø ‡§™‡§®‡§ø ‡§∏‡•ã‡§ß‡•ç‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ‡•§"
            else:
                return "I'm in information mode. You can ask me anything."
        
        elif state_enum == BookingState.SELECTING_PACKAGE:
            if memory.intent.service:
                # FIX: Show packages for the CURRENT service, not what was just discussed
                return self.fsm._get_package_prompt(memory.intent.service, language)
            else:
                return self.prompt_templates.get_service_list(language)
        
        elif state_enum == BookingState.COLLECTING_DETAILS:
            # Check what's missing and ask for it
            missing = memory.intent.missing_fields()
            
            if not missing:
                # All details collected - move to confirmation
                summary = memory.intent.get_summary()
                return self.prompt_templates.get_confirmation_prompt(summary, language)
            
            # If we just entered details collection, show full prompt
            if memory.off_track_count == 0 or len(missing) >= 5:
                return self.fsm._get_details_prompt(memory.intent, language)
            else:
                # Ask for specific missing field(s)
                if len(missing) == 1:
                    return self._get_field_specific_prompt(missing[0], language)
                else:
                    return self.fsm._get_missing_fields_prompt(missing, language)
        
        elif state_enum == BookingState.CONFIRMING:
            summary = memory.intent.get_summary()
            return self.prompt_templates.get_confirmation_prompt(summary, language)
        
        elif state_enum == BookingState.OTP_SENT:
            if language == "hi":
                return "üî¢ **‡§ï‡•É‡§™‡§Ø‡§æ 6-‡§Ö‡§Ç‡§ï‡•Ä‡§Ø OTP ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç:**"
            elif language == "ne":
                return "üî¢ **‡§ï‡•É‡§™‡§Ø‡§æ 6-‡§Ö‡§ô‡•ç‡§ï‡§ï‡•ã OTP ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**"
            elif language == "mr":
                return "üî¢ **‡§ï‡•É‡§™‡§Ø‡§æ 6-‡§Ö‡§Ç‡§ï‡•Ä OTP ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ:**"
            else:
                return "üî¢ **Please enter the 6-digit OTP:**"
        
        else:
            if language == "hi":
                return "üìã ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç‡•§"
            elif language == "ne":
                return "üìã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§æ‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§"
            elif language == "mr":
                return "üìã ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∏‡•Å‡§∞‡•Ç ‡§†‡•á‡§µ‡§æ."
            else:
                return "üìã Continue with booking."
    
    def _get_full_details_prompt(self, language: str) -> str:
        """Get full details prompt asking for all details at once"""
        if language == "hi":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á‡§Ç:**

‡§Ü‡§™ ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§ú‡•à‡§∏‡•á +919876543210):
‚Ä¢ **‡§à‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ** (‡§ú‡•à‡§∏‡•á 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +919876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä, 110001, ‡§≠‡§æ‡§∞‡§§"

‡§Ü‡§™‡§ï‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?"""
        elif language == "ne":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

‡§§‡§™‡§æ‡§à‡§Ç ‡§è‡§ï‡•à ‡§™‡§ü‡§ï ‡§∏‡§¨‡•à ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§, ‡§ú‡§∏‡•ç‡§§‡•à +9779876543210):
‚Ä¢ **‡§á‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø** (‡§ú‡§∏‡•ç‡§§‡•à 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +9779876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§ï‡§æ‡§†‡§Æ‡§æ‡§°‡•å‡§Ç, 44600, ‡§®‡•á‡§™‡§æ‡§≤"

‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§ï‡•á ‡§π‡•ã?"""
        elif language == "mr":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•á ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§¶‡•ç‡§Ø‡§æ:**

‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§è‡§ï‡§æ‡§ö ‡§µ‡•á‡§≥‡•Ä ‡§∏‡§∞‡•ç‡§µ ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§¶‡•á‡§ä ‡§∂‡§ï‡§§‡§æ:

‚Ä¢ **‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§°‡§∏‡§π, ‡§â‡§¶‡§æ. +919876543210):
‚Ä¢ **‡§à‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ** (‡§â‡§¶‡§æ. 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≥/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +919876543210, ramesh@email.com, 15 ‡§è‡§™‡•ç‡§∞‡§ø‡§≤ 2025, ‡§Æ‡•Å‡§Ç‡§¨‡§à, 400001, ‡§≠‡§æ‡§∞‡§§"

‡§§‡•Å‡§Æ‡§ö‡•á ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§ï‡§æ‡§Ø ‡§Ü‡§π‡•á‡§§?"""
        else:
            return """üìã **Please provide your details:**

You can provide all details at once:

‚Ä¢ **Full Name:**
‚Ä¢ **WhatsApp Number** (with country code, e.g., +919876543210):
‚Ä¢ **Email:**
‚Ä¢ **Event Date** (e.g., March 25, 2025):
‚Ä¢ **Event Location:**
‚Ä¢ **PIN Code:**
‚Ä¢ **Country** (India/Nepal/Pakistan/Bangladesh/Dubai):

**Example:** "Ramesh Kumar, +919876543210, ramesh@email.com, April 15, 2025, Delhi, 110001, India"

What are your details?"""
    
    def _get_field_specific_prompt(self, field: str, language: str) -> str:
        """Get prompt for specific missing field"""
        prompts = {
            "en": {
                "name": "üìù **Please provide your full name:**",
                "phone": "üì± **Please provide your WhatsApp number:** (with country code, e.g., +919876543210)",
                "email": "üìß **Please provide your email:**",
                "event_date": "üìÖ **Please provide event date:** (e.g., March 25, 2025)",
                "location": "üìç **Please provide event location:**",
                "pincode": "üìÆ **Please provide PIN code:**",
                "service_country": "üåç **Please provide country:** (India/Nepal/Pakistan/Bangladesh/Dubai)"
            },
            "hi": {
                "name": "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¶‡•á‡§Ç:**",
                "phone": "üì± **‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡•á‡§Ç:** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§ú‡•à‡§∏‡•á +919876543210)",
                "email": "üìß **‡§ï‡•É‡§™‡§Ø‡§æ ‡§à‡§Æ‡•á‡§≤ ‡§¶‡•á‡§Ç:**",
                "event_date": "üìÖ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡•á‡§Ç:** (‡§ú‡•à‡§∏‡•á 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025)",
                "location": "üìç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡•á‡§Ç:**",
                "pincode": "üìÆ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§ø‡§® ‡§ï‡•ã‡§° ‡§¶‡•á‡§Ç:**",
                "service_country": "üåç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§¶‡•á‡§Ç:** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à)"
            },
            "ne": {
                "name": "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**",
                "phone": "üì± **‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§, ‡§ú‡§∏‡•ç‡§§‡•à +9779876543210)",
                "email": "üìß **‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§Æ‡•á‡§≤ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**",
                "event_date": "üìÖ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** (‡§ú‡§∏‡•ç‡§§‡•à 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025)",
                "location": "üìç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**",
                "pincode": "üìÆ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§ø‡§® ‡§ï‡•ã‡§° ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**",
                "service_country": "üåç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à)"
            },
            "mr": {
                "name": "üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ ‡§¶‡•ç‡§Ø‡§æ:**",
                "phone": "üì± **‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡•ç‡§Ø‡§æ:** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§°‡§∏‡§π, ‡§â‡§¶‡§æ. +919876543210)",
                "email": "üìß **‡§ï‡•É‡§™‡§Ø‡§æ ‡§à‡§Æ‡•á‡§≤ ‡§¶‡•ç‡§Ø‡§æ:**",
                "event_date": "üìÖ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¶‡•ç‡§Ø‡§æ:** (‡§â‡§¶‡§æ. 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025)",
                "location": "üìç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡•ç‡§Ø‡§æ:**",
                "pincode": "üìÆ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§ø‡§® ‡§ï‡•ã‡§° ‡§¶‡•ç‡§Ø‡§æ:**",
                "service_country": "üåç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§¶‡•ç‡§Ø‡§æ:** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≥/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à)"
            }
        }
        
        lang_prompts = prompts.get(language, prompts["en"])
        return lang_prompts.get(field, f"Please provide: {field}")
    
    def _get_missing_fields_prompt(self, missing_fields: List[str], language: str) -> str:
        """Get prompt for multiple missing fields"""
        field_names = {
            "en": {
                "name": "full name",
                "phone": "phone number",
                "email": "email",
                "event_date": "event date",
                "location": "event location",
                "pincode": "PIN code",
                "service_country": "country"
            },
            "hi": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "event_date": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "location": "‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "ne": {
                "name": "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞",
                "email": "‡§á‡§Æ‡•á‡§≤",
                "event_date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø",
                "location": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            },
            "mr": {
                "name": "‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§æ‡§µ",
                "phone": "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞",
                "email": "‡§à‡§Æ‡•á‡§≤",
                "event_date": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ",
                "location": "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
                "pincode": "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
                "service_country": "‡§¶‡•á‡§∂"
            }
        }
        
        lang_fields = field_names.get(language, field_names["en"])
        
        # Get display names for missing fields
        display_fields = [lang_fields.get(field, field) for field in missing_fields]
        
        if len(display_fields) == 1:
            return self._get_field_specific_prompt(missing_fields[0], language)
        else:
            if language == "hi":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§Ç:** {', '.join(display_fields)}"
            elif language == "ne":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** {', '.join(display_fields)}"
            elif language == "mr":
                return f"üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ç‡§Ø‡§æ:** {', '.join(display_fields)}"
            else:
                return f"üìã **Please provide:** {', '.join(display_fields)}"
    
    def _build_booking_context(self, memory: ConversationMemory) -> str:
        """Build context for knowledge base"""
        parts = []
        
        if memory.intent.service:
            parts.append(f"Service: {memory.intent.service}")
        
        if memory.intent.package:
            parts.append(f"Package: {memory.intent.package}")
        
        if memory.intent.name:
            parts.append(f"Name: {memory.intent.name}")
        
        current_stage = BookingState.from_string(memory.stage)
        parts.append(f"Current stage: {current_stage.value}")
        
        # Add missing fields if any
        missing = memory.intent.missing_fields()
        if missing:
            parts.append(f"Waiting for: {', '.join(missing)}")
        
        return " | ".join(parts) if parts else "New booking"
    
    def _get_or_create_session(self, session_id: Optional[str], language: str) -> ConversationMemory:
        """Get or create session"""
        if session_id:
            memory = self.memory_service.get_session(session_id)
            if memory:
                return memory
        
        # Create new session if not found
        new_session_id = self.memory_service.create_session(language)
        return self.memory_service.get_session(new_session_id)
    
    def _is_exit_request(self, message: str) -> bool:
        """Check exit"""
        msg_lower = message.lower()
        exit_keywords = ['exit', 'cancel', 'quit', 'stop', 'nevermind', 'abort']
        return any(kw in msg_lower for kw in exit_keywords)
    
    def _is_restart_request(self, message: str) -> bool:
        """Check restart"""
        msg_lower = message.lower()
        restart_keywords = ['restart', 'start over', 'reset', 'new booking']
        return any(kw in msg_lower for kw in restart_keywords)
    
    def _is_resend_otp_request(self, message: str) -> bool:
        """Check resend OTP"""
        msg_lower = message.lower()
        keywords = ['resend', 'send again', 'missed', 'didn\'t get', 'not received']
        return any(kw in msg_lower for kw in keywords)
    
    async def _switch_to_chat_mode(self, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Switch to chat mode - FIXED to properly set stage to INFO_MODE"""
        memory.reset()
        memory.stage = BookingState.INFO_MODE.value  # Use INFO_MODE instead of "chat_mode"
        self.memory_service.update_session(memory.session_id, memory)
        
        if language == "hi":
            reply = "‡§Æ‡•à‡§Ç‡§®‡•á ‡§∏‡•Ç‡§ö‡§®‡§æ ‡§Æ‡•ã‡§° ‡§Æ‡•á‡§Ç ‡§∏‡•ç‡§µ‡§ø‡§ö ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™ ‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§™‡•Ç‡§õ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§î‡§∞ ‡§ú‡§¨ ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•ã‡§Ç, ‡§§‡•ã ‡§Æ‡•Å‡§ù‡•á ‡§¨‡§§‡§æ‡§è‡§Ç!"
        elif language == "ne":
            reply = "‡§Æ‡•à‡§≤‡•á ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§Æ‡•ã‡§°‡§Æ‡§æ ‡§∏‡•ç‡§µ‡§ø‡§ö ‡§ó‡§∞‡•á‡§ï‡•ã ‡§õ‡•Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç ‡§∏‡•ç‡§µ‡§§‡§®‡•ç‡§§‡•ç‡§∞ ‡§∞‡•Ç‡§™‡§Æ‡§æ ‡§∏‡•ã‡§ß‡•ç‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ, ‡§∞ ‡§ú‡§¨ ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§ó‡§∞‡•ç‡§® ‡§§‡§Ø‡§æ‡§∞ ‡§π‡•Å‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ, ‡§Æ‡§≤‡§æ‡§à ‡§≠‡§®‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç!"
        else:
            reply = "I've switched to information mode. Feel free to ask any questions, and when you're ready to book, let me know!"
        
        memory.add_message("assistant", reply)
        self.memory_service.update_session(memory.session_id, memory)
        
        return self._build_response(
            reply=reply, 
            memory=memory, 
            action="switched_to_info", 
            metadata={"chat_mode": "normal"}
        )
    
    async def _handle_exit(self, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle exit"""
        memory.reset()
        self.memory_service.update_session(memory.session_id, memory)
        reply = self.prompt_templates.get_exit_message(language)
        return self._build_response(reply, memory, "exit", {"status": "cancelled"})
    
    async def _handle_restart(self, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle restart"""
        memory.reset()
        self.memory_service.update_session(memory.session_id, memory)
        reply = self.prompt_templates.get_restart_message(language)
        return self._build_response(reply, memory, "restart", {"status": "restarted"})
    
    async def _handle_resend_otp(self, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle resend OTP"""
        logger.info(f"OTP resend requested for session {memory.session_id}")
        
        try:
            if not self.otp_service:
                from config import TWILIO_WHATSAPP_FROM
                from services import twilio_client
                
                self.otp_service = OTPService(
                    twilio_client=twilio_client,
                    from_number=TWILIO_WHATSAPP_FROM,
                    expiry_minutes=5
                )
            
            if not memory.booking_id:
                reply = "No active OTP session. Please confirm your booking details first."
                memory.add_message("assistant", reply)
                self.memory_service.update_session(memory.session_id, memory)
                
                return self._build_response(
                    reply=reply,
                    memory=memory,
                    action="error",
                    metadata={"error": "No booking_id"}
                )
            
            resend_result = self.otp_service.resend_otp(memory.booking_id)
            
            if resend_result.get("success"):
                reply = f"A fresh OTP has been sent to {self._mask_phone(memory.intent.phone)}."
            elif resend_result.get("error"):
                error_msg = resend_result.get("error")
                reply = f"{error_msg}"
            else:
                reply = "Could not resend OTP. Please try again."
            
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="resend_otp",
                metadata={
                    "booking_id": memory.booking_id,
                    "next_expected": "OTP verification",
                    "resend_result": resend_result
                }
            )
            
        except Exception as e:
            logger.error(f"Error resending OTP: {e}", exc_info=True)
            
            reply = "Sorry, there was an error resending the OTP. Please try again or contact support."
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="error",
                metadata={"error": str(e)}
            )
    
    def _mask_phone(self, phone: str) -> str:
        """Mask phone"""
        if not phone:
            return "your number"
        
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) >= 10:
            if phone.startswith('+'):
                return f"{phone[:8]}****{digits[-4:]}"
            else:
                return f"+XX{digits[:2]}****{digits[-4:]}"
        
        return phone
    
    async def _handle_fsm_result(self, fsm_result: Tuple, message: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle FSM processing result"""
        next_state, updated_intent, metadata = fsm_result
        
        # Build response
        reply = metadata.get("message", "")
        if not reply:
            state_enum = BookingState.from_string(next_state)
            reply = self._get_booking_continuation(state_enum, memory, language)
        
        # Determine chat mode
        chat_mode = "agent" if next_state != BookingState.GREETING.value else "normal"
        
        return self._build_response(
            reply=reply,
            memory=memory,
            action=metadata.get("action", "continue"),
            metadata={
                "collected_info": metadata.get("collected", {}),
                "missing_fields": updated_intent.missing_fields(),
                "next_expected": BookingState.from_string(next_state).get_next_expected(),
                "chat_mode": chat_mode
            }
        )
    
    async def _handle_send_otp(self, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle send OTP"""
        try:
            if not self.otp_service:
                from config import TWILIO_WHATSAPP_FROM
                from services import twilio_client
                
                self.otp_service = OTPService(
                    twilio_client=twilio_client,
                    from_number=TWILIO_WHATSAPP_FROM,
                    expiry_minutes=5
                )
            
            booking_id = self.otp_service.generate_booking_id()
            otp = self.otp_service.generate_otp()
            
            booking_data = {
                "intent": memory.intent.dict(),
                "session_id": memory.session_id,
                "language": language,
                "created_at": datetime.utcnow().isoformat()
            }
            
            self.otp_service.store_otp_data(
                booking_id=booking_id,
                otp=otp,
                phone=memory.intent.phone,
                booking_data=booking_data,
                language=language
            )
            
            otp_sent = self.otp_service.send_otp(
                phone=memory.intent.phone,
                otp=otp,
                language=language
            )
            
            if not otp_sent:
                logger.warning(f"OTP send failed for {memory.intent.phone}")
            
            memory.booking_id = booking_id
            memory.stage = BookingState.OTP_SENT.value
            self.memory_service.update_session(memory.session_id, memory)
            
            reply = self.prompt_templates.get_otp_sent_message(language, memory.intent.phone)
            
            logger.info(f"OTP sent for booking {booking_id[:8]}...")
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="send_otp",
                metadata={
                    "booking_id": booking_id,
                    "next_expected": "OTP verification",
                    "otp_sent": otp_sent
                }
            )
            
        except Exception as e:
            logger.error(f"Error sending OTP: {e}", exc_info=True)
            
            memory.stage = BookingState.CONFIRMING.value
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply="Sorry, there was an error sending OTP. Please try again or contact support.",
                memory=memory,
                action="error",
                metadata={"error": str(e)}
            )
    
    async def _handle_verify_otp(self, otp: str, memory: ConversationMemory, language: str) -> Dict[str, Any]:
        """Handle verify OTP"""
        if not otp or not memory.booking_id:
            reply = "Please enter the 6-digit OTP."
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="retry",
                metadata={"error": "No OTP provided"}
            )
        
        try:
            if not self.otp_service:
                from config import TWILIO_WHATSAPP_FROM
                from services import twilio_client
                
                self.otp_service = OTPService(
                    twilio_client=twilio_client,
                    from_number=TWILIO_WHATSAPP_FROM,
                    expiry_minutes=5
                )
            
            verification_result = self.otp_service.verify_otp(memory.booking_id, otp)
            
            if not verification_result.get("valid", False):
                memory.otp_attempts += 1
                
                if memory.otp_attempts >= 3 or verification_result.get("should_restart"):
                    memory.reset()
                    self.memory_service.update_session(memory.session_id, memory)
                    
                    error_msg = verification_result.get("error", "Too many failed attempts")
                    reply = f"{error_msg}. Please start a new booking."
                    
                    return self._build_response(
                        reply=reply,
                        memory=memory,
                        action="reset",
                        metadata={"status": "otp_failed"}
                    )
                
                attempts_left = 3 - memory.otp_attempts
                error_msg = verification_result.get("error", "Invalid OTP")
                reply = f"{error_msg}"
                
                memory.add_message("assistant", reply)
                self.memory_service.update_session(memory.session_id, memory)
                
                return self._build_response(
                    reply=reply,
                    memory=memory,
                    action="retry",
                    metadata={"attempts_left": attempts_left}
                )
            
            logger.info(f"‚úÖ OTP verified, saving booking...")
            
            if not self.booking_service:
                from database import booking_collection
                from services import twilio_client
                from config import TWILIO_WHATSAPP_FROM
                
                self.booking_service = BookingService(
                    booking_collection=booking_collection,
                    twilio_client=twilio_client,
                    whatsapp_from=TWILIO_WHATSAPP_FROM
                )
            
            booking_data = self.booking_service.create_booking_payload(memory)
            saved_booking_id = self.booking_service.save_booking(booking_data)
            
            verified_booking_id = verification_result.get("booking_id")
            if verified_booking_id:
                self.otp_service.delete_otp_data(verified_booking_id)
            
            if memory.intent.phone:
                self.booking_service.send_confirmation_whatsapp(
                    memory.intent.phone,
                    booking_data,
                    language
                )
            
            reply = self.prompt_templates.get_booking_confirmed_message(language, memory.intent.name)
            
            memory.reset()
            self.memory_service.update_session(memory.session_id, memory)
            
            logger.info(f"‚úÖ Booking completed: {saved_booking_id}")
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="booking_confirmed",
                metadata={
                    "booking_id": saved_booking_id,
                    "status": "completed"
                }
            )
            
        except Exception as e:
            logger.error(f"Error verifying OTP or saving booking: {e}", exc_info=True)
            
            reply = "Error saving booking. Your OTP is still valid, please try again."
            memory.add_message("assistant", reply)
            self.memory_service.update_session(memory.session_id, memory)
            
            return self._build_response(
                reply=reply,
                memory=memory,
                action="error",
                metadata={"error": str(e)}
            )
    
    def _build_response(self, reply: str, memory: ConversationMemory, action: str, metadata: Dict = None) -> Dict[str, Any]:
        """Build response - FIXED chat_mode determination based on stage"""
        metadata = metadata or {}
        
        # Determine chat_mode based on stage
        state_enum = BookingState.from_string(memory.stage)
        if state_enum in [BookingState.GREETING, BookingState.INFO_MODE]:
            chat_mode = "normal"
        else:
            chat_mode = "agent"
        
        # Override with metadata if explicitly provided
        if "chat_mode" in metadata:
            chat_mode = metadata["chat_mode"]
        
        response_data = {
            "reply": reply,
            "session_id": memory.session_id,
            "stage": memory.stage,
            "action": action,
            "missing_fields": memory.intent.missing_fields(),
            "collected_info": memory.intent.get_summary(),
            "chat_mode": chat_mode,  # Use the determined value
            "next_expected": metadata.get("next_expected"),
            "booking_id": metadata.get("booking_id"),
            "off_track_count": memory.off_track_count
        }
        
        for key, value in metadata.items():
            if key not in response_data:
                response_data[key] = value
        
        try:
            return AgentChatResponse(**response_data).dict()
        except Exception as e:
            logger.error(f"Error building response: {e}")
            return response_data
    
    def _build_error_response(self, error_message: str, session_id: str) -> Dict[str, Any]:
        """Build error response"""
        return {
            "reply": error_message,
            "session_id": session_id or "error",
            "stage": "error",
            "action": "error",
            "missing_fields": [],
            "collected_info": {},
            "chat_mode": "normal",
            "off_track_count": 0
        }

__________________

Below are other small files:

Main files(extractors)
_________________________
address_extractor.py:

"""
Address Extractor - Robust address extraction logic
"""

import re
from typing import Optional, Dict, Any, List
from .base_extractor import BaseExtractor


class AddressExtractor(BaseExtractor):
    """Extract addresses from messages with battle-tested logic"""
    
    # Address indicators/keywords
    ADDRESS_INDICATORS = [
        'street', 'st.', 'st', 'road', 'rd.', 'rd', 'lane', 'ln.', 'ln',
        'avenue', 'ave.', 'ave', 'boulevard', 'blvd.', 'blvd',
        'drive', 'dr.', 'dr', 'circle', 'cir.', 'court', 'ct.',
        'house', 'flat', 'apartment', 'apt.', 'apt', 'building', 'bldg.',
        'floor', 'fl.', 'room', 'rm.', 'suite', 'ste.', 'unit', 'block', 'blk.',
        'colony', 'sector', 'area', 'locality', 'village', 'town', 'city',
        'district', 'state', 'county', 'province', 'region', 'zone',
        'near', 'beside', 'opposite', 'behind', 'in front of', 'at', 'by',
        'no.', 'number', '#', 'plot', 'ward', 'mohalla', 'chowk', 'nagar',
        'marg', 'path', 'gali', 'cross', 'layout', 'phase', 'extension',
        'vihar', 'puram', 'niwas', 'kunj', 'enclave', 'residency'
    ]
    
    # Location/city names (comprehensive)
    LOCATION_NAMES = [
        # India - Major cities
        'mumbai', 'delhi', 'bangalore', 'bengaluru', 'hyderabad', 'ahmedabad',
        'chennai', 'kolkata', 'surat', 'pune', 'jaipur', 'lucknow', 'kanpur',
        'nagpur', 'indore', 'thane', 'bhopal', 'visakhapatnam', 'pimpri',
        'patna', 'vadodara', 'ghaziabad', 'ludhiana', 'agra', 'nashik',
        'faridabad', 'meerut', 'rajkot', 'kalyan', 'vasai', 'varanasi',
        'srinagar', 'aurangabad', 'dhanbad', 'amritsar', 'navi mumbai',
        'allahabad', 'ranchi', 'howrah', 'coimbatore', 'jabalpur', 'gwalior',
        'vijayawada', 'jodhpur', 'madurai', 'raipur', 'kota', 'chandigarh',
        
        # India - States
        'maharashtra', 'karnataka', 'tamil nadu', 'uttar pradesh', 'up',
        'gujarat', 'rajasthan', 'punjab', 'haryana', 'kerala', 'bihar',
        'west bengal', 'madhya pradesh', 'mp', 'andhra pradesh', 'ap',
        'telangana', 'odisha', 'jharkhand', 'chhattisgarh',
        
        # Nepal
        'kathmandu', 'pokhara', 'lalitpur', 'bhaktapur', 'biratnagar',
        'birgunj', 'dharan', 'bharatpur', 'hetauda', 'janakpur',
        
        # Pakistan
        'karachi', 'lahore', 'islamabad', 'rawalpindi', 'faisalabad',
        'multan', 'peshawar', 'quetta', 'sialkot', 'gujranwala',
        
        # Bangladesh
        'dhaka', 'chittagong', 'khulna', 'rajshahi', 'sylhet',
        'barisal', 'rangpur', 'comilla', 'narayanganj',
        
        # Dubai/UAE
        'dubai', 'abu dhabi', 'sharjah', 'ajman', 'fujairah', 'ras al khaimah',
        'umm al quwain', 'al ain'
    ]
    
    # Words that are NOT addresses
    EXCLUDED_PATTERNS = [
        r'\S+@\S+\.\S+',  # Email
        r'\+\d[\d\s\-\(\)]+',  # Phone with +
        r'\b\d{10,}\b',  # Long numbers (likely phone)
        r'\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)',  # Dates
        r'(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+\d{1,2}',  # Dates
    ]
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract address from message"""
        original_message = message
        message = self.clean_message(message)
        
        # Check if message contains address indicators
        if not self._find_address_indicators(message):
            # Try location-based extraction
            location_address = self._extract_location_based(message)
            if location_address:
                return {
                    'address': location_address,
                    'confidence': 'medium',
                    'method': 'location_based'
                }
            return None
        
        # Clean the message by removing non-address elements
        cleaned = self._clean_for_extraction(message)
        
        # Extract location parts
        location_parts = self._extract_location_parts(cleaned)
        
        # Build address from parts
        if location_parts:
            address = self._build_address(location_parts, cleaned)
            if address and self._validate_address(address):
                return {
                    'address': self._clean_address(address),
                    'confidence': 'high',
                    'method': 'structured',
                    'parts': location_parts
                }
        
        # Fallback: extract based on patterns
        pattern_address = self._extract_pattern_based(cleaned)
        if pattern_address and self._validate_address(pattern_address):
            return {
                'address': self._clean_address(pattern_address),
                'confidence': 'medium',
                'method': 'pattern'
            }
        
        return None
    
    def _find_address_indicators(self, message: str) -> bool:
        """Check if message contains address indicators"""
        msg_lower = message.lower()
        
        # Check for address keywords
        for indicator in self.ADDRESS_INDICATORS:
            if indicator in msg_lower:
                return True
        
        # Check for location names
        for location in self.LOCATION_NAMES:
            if location in msg_lower:
                return True
        
        # Check for address-like patterns (number + text)
        if re.search(r'\b\d+[,\s]+[A-Za-z]', message):
            return True
        
        return False
    
    def _clean_for_extraction(self, message: str) -> str:
        """Clean message for address extraction"""
        cleaned = message
        
        # Remove excluded patterns
        for pattern in self.EXCLUDED_PATTERNS:
            cleaned = re.sub(pattern, ' ', cleaned, flags=re.IGNORECASE)
        
        # Remove common name patterns (Title Case at start)
        name_pattern = r'^([A-Z][a-z]+\s+[A-Z][a-z]+)[,\s]*'
        cleaned = re.sub(name_pattern, ' ', cleaned)
        
        # Remove standalone numbers that look like PIN codes
        cleaned = re.sub(r'\b\d{5,6}\b', ' ', cleaned)
        
        # Normalize whitespace
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        
        return cleaned
    
    def _extract_location_parts(self, message: str) -> Dict[str, str]:
        """Extract location components (street, city, etc.)"""
        parts = {}
        msg_lower = message.lower()
        
        # Extract street/house number
        street_pattern = r'(?:no\.?\s*)?(\d+[a-z]?)\s+([A-Za-z\s]+(?:street|st|road|rd|lane|ln|avenue|ave))'
        street_match = re.search(street_pattern, message, re.IGNORECASE)
        if street_match:
            parts['street'] = f"{street_match.group(1)} {street_match.group(2).strip()}"
        
        # Extract area/locality
        area_pattern = r'(?:area|locality|colony|sector|zone|ward|mohalla|nagar)\s*[:\-]?\s*([A-Za-z0-9\s]+)'
        area_match = re.search(area_pattern, message, re.IGNORECASE)
        if area_match:
            parts['area'] = area_match.group(1).strip()
        
        # Extract city
        for city in self.LOCATION_NAMES:
            if city in msg_lower:
                # Find the actual case-preserved version
                city_pattern = re.compile(re.escape(city), re.IGNORECASE)
                city_match = city_pattern.search(message)
                if city_match:
                    parts['city'] = city_match.group(0)
                    break
        
        # Extract state/country (if mentioned after city)
        if 'city' in parts:
            city_pos = msg_lower.index(parts['city'].lower())
            after_city = message[city_pos + len(parts['city']):].strip()
            
            # Look for state/country names
            state_pattern = r'^[,\s]+([A-Za-z\s]+?)(?:[,\.\s]|$)'
            state_match = re.search(state_pattern, after_city)
            if state_match:
                potential_state = state_match.group(1).strip()
                if len(potential_state.split()) <= 3:  # Max 3 words for state
                    parts['state'] = potential_state
        
        return parts
    
    def _build_address(self, parts: Dict[str, str], full_message: str) -> str:
        """Build address from extracted parts"""
        address_components = []
        
        # Add components in order: street, area, city, state
        if 'street' in parts:
            address_components.append(parts['street'])
        
        if 'area' in parts:
            address_components.append(parts['area'])
        
        if 'city' in parts:
            address_components.append(parts['city'])
        
        if 'state' in parts:
            address_components.append(parts['state'])
        
        # If we have very few components, try to extract more from full message
        if len(address_components) < 2:
            # Look for comma-separated components
            comma_parts = [p.strip() for p in full_message.split(',') if len(p.strip()) > 3]
            
            # Filter out parts that look like names or other info
            valid_parts = []
            for part in comma_parts[:5]:  # Max 5 parts
                if not re.search(r'@|^\d{10}$|\+\d', part):  # Not email/phone
                    valid_parts.append(part)
            
            if len(valid_parts) > len(address_components):
                address_components = valid_parts
        
        return ', '.join(address_components) if address_components else ''
    
    def _extract_pattern_based(self, message: str) -> Optional[str]:
        """Extract address using pattern matching"""
        # Pattern: Multiple components separated by commas
        comma_separated = [p.strip() for p in message.split(',')]
        
        if len(comma_separated) >= 2:
            # Filter valid components
            valid_components = []
            for component in comma_separated[:6]:  # Max 6 components
                # Skip if too short or looks like other data
                if len(component) < 3:
                    continue
                if re.search(r'^\d{10}$|@\w+\.\w+', component):
                    continue
                valid_components.append(component)
            
            if len(valid_components) >= 2:
                return ', '.join(valid_components)
        
        # Pattern: Long text with location indicators
        if len(message) > 20 and any(ind in message.lower() for ind in self.ADDRESS_INDICATORS[:20]):
            # Extract everything as address
            return message
        
        return None
    
    def _extract_location_based(self, message: str) -> Optional[str]:
        """Extract address when location names are present"""
        msg_lower = message.lower()
        
        # Check for city names
        found_location = None
        for location in self.LOCATION_NAMES:
            if location in msg_lower:
                found_location = location
                break
        
        if not found_location:
            return None
        
        # Extract text around the location
        location_pos = msg_lower.index(found_location)
        
        # Get context before and after
        before = message[:location_pos].strip()
        after = message[location_pos + len(found_location):].strip()
        
        # Build address from context
        address_parts = []
        
        # Add before context if it looks like address
        if before and len(before) > 5 and not re.search(r'@|\d{10}', before):
            # Take last part before location (likely street/area)
            before_parts = before.split(',')
            if before_parts:
                address_parts.append(before_parts[-1].strip())
        
        # Add location
        address_parts.append(found_location.title())
        
        # Add after context if it looks like state/country
        if after:
            after_clean = re.sub(r'[,\.]', '', after).strip()
            after_words = after_clean.split()
            if len(after_words) <= 3 and not re.search(r'\d{5,}|@', after_clean):
                address_parts.append(after_words[0].title())
        
        if len(address_parts) >= 2:
            return ', '.join(address_parts)
        
        return None
    
    def _clean_address(self, address: str) -> str:
        """Clean and format address"""
        # Remove extra spaces
        address = re.sub(r'\s+', ' ', address).strip()
        
        # Remove trailing punctuation
        address = re.sub(r'[,\s\.]+$', '', address)
        
        # Remove leading punctuation
        address = re.sub(r'^[,\s\.]+', '', address)
        
        # Capitalize properly
        parts = address.split(',')
        formatted_parts = []
        for part in parts:
            part = part.strip()
            if part:
                # Capitalize first letter of each word (title case)
                formatted_parts.append(part.title())
        
        return ', '.join(formatted_parts)
    
    def _validate_address(self, address: str) -> bool:
        """Validate if string is likely an address - RELAXED for city names"""
        if not address or len(address) < 3:  # Reduced from 10 to 3
            return False
        
        addr_lower = address.lower()
        
        # ========================
        # EXCLUDE DATE PATTERNS
        # ========================
        # Month names (English)
        months = [
            'january', 'february', 'march', 'april', 'may', 'june',
            'july', 'august', 'september', 'october', 'november', 'december',
            'jan', 'feb', 'mar', 'apr', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'
        ]
        
        # Common date patterns
        date_patterns = [
            r'\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)',
            r'(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+\d{1,2}',
            r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}',
            r'\d{4}[/-]\d{1,2}[/-]\d{1,2}',
            r'\d{1,2}\s+\d{4}'  # "15 2025"
        ]
        
        # Check for date patterns
        for month in months:
            if month in addr_lower:
                # Check if it's a date format
                for pattern in date_patterns:
                    if re.search(pattern, addr_lower):
                        return False
        
        # Check for question patterns
        question_starters = [
            "what", "which", "who", "whom", "whose", "when", "where", "why", "how",
            "can you", "could you", "would you", "will you",
            "tell me", "show me", "give me", "explain this",
            "i want to know", "i would like to know",
            "do you have", "do you offer", "do you provide",
        ]
        
        for starter in question_starters:
            if addr_lower.startswith(starter):
                return False
        
        # Check for social media patterns
        social_patterns = [
            'instagram', 'facebook', 'twitter', 'youtube', 'linkedin',
            'social media', 'follow', 'subscribe', 'channel',
            'link', 'website', 'web', 'site', 'online'
        ]
        
        for pattern in social_patterns:
            if pattern in addr_lower:
                return False
        
        # ========================
        # NEW: Special handling for city names
        # ========================
        # Check if it's a known city
        is_city = any(location in addr_lower for location in self.LOCATION_NAMES)
        
        if is_city:
            # For city names only, be more lenient
            # Check it's not just part of a longer invalid string
            words = address.split()
            if len(words) == 1:
                # Single word that's a city - accept it
                return True
            elif len(words) <= 3:
                # Short address (like "Delhi", "New Delhi", "South Delhi")
                # Check if it doesn't contain other invalid patterns
                invalid_patterns = [
                    r'\d{10}',  # Phone number
                    r'\S+@\S+\.\S+',  # Email
                    r'price|cost|how much|fee',  # Price keywords
                ]
                for pattern in invalid_patterns:
                    if re.search(pattern, addr_lower):
                        return False
                return True
        
        # ========================
        # For non-city addresses, apply stricter rules
        # ========================
        parts = [p.strip() for p in address.split(',')]
        
        # Check for address indicators
        has_indicator = False
        for indicator in self.ADDRESS_INDICATORS[:30]:
            if indicator in addr_lower:
                has_indicator = True
                break
        
        if not has_indicator:
            # Check for location names (already done above)
            if not is_city:
                return False
        
        # Check for reasonable length and content
        words = address.split()
        if len(words) < 1:  # Reduced from 3
            return False
        
        # Check for number + street pattern
        if not is_city and not has_indicator:
            if re.search(r'\d+[,\s]+\w+', address):
                has_indicator = True
            else:
                return False
        
        return True


base_extractor.py:

"""
Base Extractor - Abstract base class for all extractors
"""

from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
import re
import logging

logger = logging.getLogger(__name__)


class BaseExtractor(ABC):
    """Base class for all field extractors with common utilities"""
    
    def __init__(self):
        """Initialize base extractor"""
        self.logger = logger
    
    @abstractmethod
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """
        Extract field from message
        
        Args:
            message: The input message to extract from
            context: Optional context including conversation history, other extracted fields
            
        Returns:
            Dictionary with extracted value and metadata, or None if not found
            Format: {
                'field_name': extracted_value,
                'confidence': 'high'|'medium'|'low',
                'method': 'extraction_method_used',
                ...additional metadata
            }
        """
        pass
    
    def clean_message(self, message: str) -> str:
        """
        Clean message before extraction
        
        Args:
            message: Raw input message
            
        Returns:
            Cleaned message with normalized whitespace and punctuation
        """
        if not message:
            return ""
        
        # Remove extra whitespace
        cleaned = re.sub(r'\s+', ' ', message.strip())
        
        # Remove trailing punctuation from end
        cleaned = re.sub(r'[.,;!?]+$', '', cleaned)

        # Remove special characters that might interfere
        cleaned = re.sub(r'[^\w\s@+.,-]', ' ', cleaned)
        
        # Remove leading punctuation
        cleaned = re.sub(r'^[.,;!?]+', '', cleaned)
        
        return cleaned
    
    def find_pattern(self, message: str, pattern: str, flags: int = re.IGNORECASE) -> Optional[str]:
        """
        Helper method to find pattern in message
        
        Args:
            message: Message to search
            pattern: Regex pattern
            flags: Regex flags (default: IGNORECASE)
            
        Returns:
            First match group or None
        """
        try:
            match = re.search(pattern, message, flags)
            return match.group(1) if match else None
        except Exception as e:
            self.logger.error(f"Pattern matching error: {e}")
            return None
    
    def find_all_patterns(self, message: str, pattern: str, flags: int = re.IGNORECASE) -> List[str]:
        """
        Find all occurrences of pattern in message
        
        Args:
            message: Message to search
            pattern: Regex pattern
            flags: Regex flags (default: IGNORECASE)
            
        Returns:
            List of all matches
        """
        try:
            matches = re.finditer(pattern, message, flags)
            return [match.group(1) for match in matches if match.group(1)]
        except Exception as e:
            self.logger.error(f"Pattern matching error: {e}")
            return []
    
    def extract_from_context(self, field_name: str, context: Optional[Dict[str, Any]]) -> Optional[Any]:
        """
        Extract field from context dictionary
        
        Args:
            field_name: Name of the field to extract
            context: Context dictionary
            
        Returns:
            Field value or None
        """
        if not context:
            return None
        
        # Direct field lookup
        if field_name in context:
            return context[field_name]
        
        # Check nested structures
        if 'extracted_fields' in context and field_name in context['extracted_fields']:
            return context['extracted_fields'][field_name]
        
        if 'intent' in context:
            intent = context['intent']
            if isinstance(intent, dict) and field_name in intent:
                return intent[field_name]
            elif hasattr(intent, field_name):
                return getattr(intent, field_name)
        
        return None
    
    def get_conversation_history(self, context: Optional[Dict[str, Any]]) -> List[Dict]:
        """
        Get conversation history from context
        
        Args:
            context: Context dictionary
            
        Returns:
            List of conversation messages
        """
        if not context:
            return []
        
        # Try different possible locations
        if 'history' in context:
            return context['history']
        
        if 'conversation_history' in context:
            return context['conversation_history']
        
        if 'messages' in context:
            return context['messages']
        
        return []
    
    def search_in_history(self, history: List[Dict], extractor_func, max_messages: int = 10) -> Optional[Any]:
        """
        Search for field in conversation history
        
        Args:
            history: Conversation history
            extractor_func: Function to extract from message
            max_messages: Maximum messages to search
            
        Returns:
            Extracted value or None
        """
        if not history:
            return None
        
        # Search recent messages (reverse order)
        for msg in reversed(history[-max_messages:]):
            if isinstance(msg, dict) and msg.get('role') == 'user':
                content = msg.get('content', '')
                
                try:
                    result = extractor_func(content)
                    if result:
                        return result
                except Exception as e:
                    self.logger.debug(f"History search error: {e}")
                    continue
        
        return None
    
    def normalize_text(self, text: str) -> str:
        """
        Normalize text for comparison
        
        Args:
            text: Input text
            
        Returns:
            Normalized text (lowercase, trimmed)
        """
        if not text:
            return ""
        
        return text.lower().strip()
    
    def remove_noise(self, message: str, noise_patterns: List[str]) -> str:
        """
        Remove noise patterns from message
        
        Args:
            message: Input message
            noise_patterns: List of regex patterns to remove
            
        Returns:
            Cleaned message
        """
        cleaned = message
        
        for pattern in noise_patterns:
            try:
                cleaned = re.sub(pattern, ' ', cleaned, flags=re.IGNORECASE)
            except Exception as e:
                self.logger.debug(f"Noise removal error for pattern {pattern}: {e}")
        
        # Normalize whitespace after removal
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        
        return cleaned
    
    def validate_length(self, value: str, min_length: int = 1, max_length: int = 1000) -> bool:
        """
        Validate value length
        
        Args:
            value: Value to validate
            min_length: Minimum allowed length
            max_length: Maximum allowed length
            
        Returns:
            True if valid, False otherwise
        """
        if not value:
            return False
        
        length = len(value)
        return min_length <= length <= max_length
    
    def extract_with_confidence(self, extractors: List[tuple]) -> Optional[Dict]:
        """
        Try multiple extraction methods and return best result
        
        Args:
            extractors: List of (extractor_func, confidence_level) tuples
            
        Returns:
            Best extraction result with highest confidence
        """
        results = []
        
        for extractor_func, confidence in extractors:
            try:
                result = extractor_func()
                if result:
                    results.append({
                        'value': result,
                        'confidence': confidence
                    })
            except Exception as e:
                self.logger.debug(f"Extractor error: {e}")
                continue
        
        if not results:
            return None
        
        # Sort by confidence (high > medium > low)
        confidence_order = {'high': 3, 'medium': 2, 'low': 1}
        results.sort(key=lambda x: confidence_order.get(x['confidence'], 0), reverse=True)
        
        return results[0] if results else None
    
    def merge_results(self, *results: Optional[Dict]) -> Optional[Dict]:
        """
        Merge multiple extraction results, preferring higher confidence
        
        Args:
            results: Multiple result dictionaries
            
        Returns:
            Merged result with best confidence
        """
        valid_results = [r for r in results if r is not None]
        
        if not valid_results:
            return None
        
        # Sort by confidence
        confidence_order = {'high': 3, 'medium': 2, 'low': 1}
        valid_results.sort(
            key=lambda x: confidence_order.get(x.get('confidence', 'low'), 0),
            reverse=True
        )
        
        # Return highest confidence result
        return valid_results[0]
    
    def build_result(self, value: Any, confidence: str = 'medium', 
                     method: str = 'unknown', **kwargs) -> Dict:
        """
        Build standardized result dictionary
        
        Args:
            value: Extracted value
            confidence: Confidence level ('high', 'medium', 'low')
            method: Extraction method used
            **kwargs: Additional metadata
            
        Returns:
            Standardized result dictionary
        """
        result = {
            'value': value,
            'confidence': confidence,
            'method': method
        }
        
        # Add any additional metadata
        result.update(kwargs)
        
        return result
    
    def log_extraction(self, field: str, success: bool, method: str = None):
        """
        Log extraction attempt
        
        Args:
            field: Field being extracted
            success: Whether extraction succeeded
            method: Method used
        """
        status = "SUCCESS" if success else "FAILED"
        method_str = f" ({method})" if method else ""
        self.logger.debug(f"{status}: {field} extraction{method_str}")


country_extractor.py:

"""
Country Extractor - Robust country detection logic
"""

import re
from typing import Optional, Dict, Any, List
from .base_extractor import BaseExtractor


class CountryExtractor(BaseExtractor):
    """Extract country information from messages with battle-tested logic"""
    
    # Supported countries with comprehensive patterns
    COUNTRY_PATTERNS = {
        'India': {
            'keywords': ['india', 'indian', '‡§≠‡§æ‡§∞‡§§', '‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø', 'hindustan'],
            'cities': [
                'mumbai', 'delhi', 'bangalore', 'bengaluru', 'hyderabad',
                'ahmedabad', 'chennai', 'kolkata', 'surat', 'pune', 'jaipur',
                'lucknow', 'kanpur', 'nagpur', 'indore', 'thane', 'bhopal',
                'visakhapatnam', 'pimpri', 'patna', 'vadodara', 'ghaziabad',
                'ludhiana', 'agra', 'nashik', 'faridabad', 'meerut', 'rajkot',
                'kalyan', 'vasai', 'varanasi', 'srinagar', 'aurangabad',
                'dhanbad', 'amritsar', 'navi mumbai', 'allahabad', 'prayagraj',
                'ranchi', 'howrah', 'coimbatore', 'jabalpur', 'gwalior',
                'vijayawada', 'jodhpur', 'madurai', 'raipur', 'kota',
                'chandigarh', 'guwahati', 'solapur', 'hubli', 'mysore',
                'tiruchirappalli', 'bareilly', 'aligarh', 'tiruppur', 'moradabad'
            ],
            'states': [
                'maharashtra', 'karnataka', 'tamil nadu', 'uttar pradesh',
                'gujarat', 'rajasthan', 'punjab', 'haryana', 'kerala', 'bihar',
                'west bengal', 'madhya pradesh', 'mp', 'andhra pradesh', 'ap',
                'telangana', 'odisha', 'jharkhand', 'chhattisgarh', 'assam',
                'uttarakhand', 'himachal pradesh', 'hp', 'goa', 'jammu',
                'kashmir', 'ladakh', 'manipur', 'meghalaya', 'mizoram',
                'nagaland', 'sikkim', 'tripura', 'arunachal pradesh'
            ],
            'phone_codes': ['91'],
            'pincode_length': 6
        },
        'Nepal': {
            'keywords': ['nepal', 'nepali', 'nepalese', '‡§®‡•á‡§™‡§æ‡§≤', '‡§®‡•á‡§™‡§æ‡§≤‡•Ä'],
            'cities': [
                'kathmandu', 'pokhara', 'lalitpur', 'patan', 'bhaktapur',
                'biratnagar', 'birgunj', 'dharan', 'bharatpur', 'hetauda',
                'janakpur', 'butwal', 'dhangadhi', 'nepalgunj', 'itahari',
                'kalaiya', 'bhimdatta', 'gulariya', 'tulsipur', 'rajbiraj'
            ],
            'states': [
                'bagmati', 'gandaki', 'lumbini', 'karnali', 'sudurpashchim',
                'province 1', 'madhesh', 'koshi'
            ],
            'phone_codes': ['977'],
            'pincode_length': 5
        },
        'Pakistan': {
            'keywords': ['pakistan', 'pakistani', 'Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ'],
            'cities': [
                'karachi', 'lahore', 'islamabad', 'rawalpindi', 'faisalabad',
                'multan', 'peshawar', 'quetta', 'sialkot', 'gujranwala',
                'hyderabad', 'bahawalpur', 'sargodha', 'sukkur', 'larkana',
                'sheikhupura', 'jhang', 'rahim yar khan', 'gujrat', 'mardan',
                'kasur', 'mingora', 'dera ghazi khan', 'sahiwal', 'nawabshah',
                'okara', 'gilgit', 'chiniot', 'sadiqabad', 'burewala'
            ],
            'states': [
                'punjab', 'sindh', 'khyber pakhtunkhwa', 'kpk', 'balochistan',
                'gilgit-baltistan', 'azad kashmir', 'islamabad capital territory'
            ],
            'phone_codes': ['92'],
            'pincode_length': 5
        },
        'Bangladesh': {
            'keywords': ['bangladesh', 'bangladeshi', '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂'],
            'cities': [
                'dhaka', 'chittagong', 'khulna', 'rajshahi', 'sylhet',
                'barisal', 'rangpur', 'comilla', 'gazipur', 'narayanganj',
                'mymensingh', 'cox\'s bazar', 'bogra', 'jessore', 'dinajpur',
                'tangail', 'kushtia', 'pabna', 'jamalpur', 'brahmanbaria'
            ],
            'states': [
                'dhaka division', 'chittagong division', 'khulna division',
                'rajshahi division', 'sylhet division', 'barisal division',
                'rangpur division', 'mymensingh division'
            ],
            'phone_codes': ['880'],
            'pincode_length': 4
        },
        'Dubai': {
            'keywords': ['dubai', 'uae', 'united arab emirates', 'emirates', 'ÿØÿ®Ÿä'],
            'cities': [
                'dubai', 'abu dhabi', 'sharjah', 'ajman', 'fujairah',
                'ras al khaimah', 'umm al quwain', 'al ain', 'khor fakkan',
                'dibba', 'jebel ali', 'deira', 'bur dubai', 'jumeirah'
            ],
            'states': [
                'dubai', 'abu dhabi', 'sharjah', 'ajman', 'fujairah',
                'ras al khaimah', 'umm al quwain'
            ],
            'phone_codes': ['971'],
            'pincode_length': 5
        }
    }
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract country from message"""
        message = self.clean_message(message).lower()
        
        # Try direct country mention first
        country = self._extract_direct_mention(message)
        if country:
            return {
                'country': country,
                'confidence': 'high',
                'method': 'direct_mention'
            }
        
        # Try to infer from cities/locations
        country = self._infer_from_locations(message)
        if country:
            return {
                'country': country,
                'confidence': 'high',
                'method': 'location_based'
            }
        
        # Try to infer from context
        if context:
            # From phone number
            phone = context.get('phone')
            if phone:
                country = self.infer_from_phone(phone)
                if country:
                    return {
                        'country': country,
                        'confidence': 'high',
                        'method': 'phone_based'
                    }
            
            # From address/pincode
            address = context.get('address')
            pincode = context.get('pincode')
            if address or pincode:
                country = self.infer_from_location(address, pincode)
                if country:
                    return {
                        'country': country,
                        'confidence': 'medium',
                        'method': 'address_based'
                    }
        
        return None
    
    def _extract_direct_mention(self, message: str) -> Optional[str]:
        """Extract country from direct mention"""
        msg_lower = message.lower()
        
        # Check each country's keywords
        for country, patterns in self.COUNTRY_PATTERNS.items():
            for keyword in patterns['keywords']:
                if keyword in msg_lower:
                    return country
        
        return None
    
    def _infer_from_locations(self, message: str) -> Optional[str]:
        """Infer country from city/state names"""
        msg_lower = message.lower()
        
        # Score for each country based on location matches
        country_scores = {country: 0 for country in self.COUNTRY_PATTERNS.keys()}
        
        for country, patterns in self.COUNTRY_PATTERNS.items():
            # Check cities
            for city in patterns['cities']:
                if city in msg_lower:
                    country_scores[country] += 2  # Cities get higher weight
            
            # Check states
            for state in patterns['states']:
                if state in msg_lower:
                    country_scores[country] += 1
        
        # Return country with highest score
        max_score = max(country_scores.values())
        if max_score > 0:
            for country, score in country_scores.items():
                if score == max_score:
                    return country
        
        return None
    
    def infer_from_location(self, address: Optional[str], pincode: Optional[str]) -> Optional[str]:
        """Infer country from address and pincode"""
        # First try pincode
        if pincode:
            country = self._infer_from_pincode(pincode)
            if country:
                return country
        
        # Then try address
        if address:
            country = self._infer_from_locations(address.lower())
            if country:
                return country
        
        return None
    
    def infer_from_phone(self, phone: str) -> Optional[str]:
        """Infer country from phone number"""
        # Clean phone number
        phone_clean = re.sub(r'[^\d+]', '', phone)
        
        # Extract country code
        if phone_clean.startswith('+'):
            # Try to match country codes
            for country, patterns in self.COUNTRY_PATTERNS.items():
                for code in patterns['phone_codes']:
                    if phone_clean.startswith(f'+{code}'):
                        return country
        
        return None
    
    def _infer_from_pincode(self, pincode: str) -> Optional[str]:
        """Infer country from pincode pattern"""
        length = len(pincode)
        
        if length == 6:
            # Could be India
            if pincode[0] in '12345678':
                return 'India'
        elif length == 5:
            # Could be Nepal, Pakistan, or Dubai
            # Need additional context to determine
            # For now, default to most common (India uses 6, so Nepal is next)
            return 'Nepal'
        elif length == 4:
            # Bangladesh
            return 'Bangladesh'
        
        return None
    
    def _get_country_patterns(self) -> Dict[str, list]:
        """Get country detection patterns"""
        patterns = {}
        
        for country, data in self.COUNTRY_PATTERNS.items():
            country_patterns = []
            
            # Add keyword patterns
            country_patterns.extend(data['keywords'])
            
            # Add city patterns (top 10 cities)
            country_patterns.extend(data['cities'][:10])
            
            # Add state patterns (top 5 states)
            country_patterns.extend(data['states'][:5])
            
            patterns[country] = country_patterns
        
        return patterns
    
    def get_supported_countries(self) -> List[str]:
        """Get list of supported countries"""
        return list(self.COUNTRY_PATTERNS.keys())
    
    def get_country_info(self, country: str) -> Optional[Dict]:
        """Get information about a specific country"""
        if country in self.COUNTRY_PATTERNS:
            info = self.COUNTRY_PATTERNS[country].copy()
            return {
                'country': country,
                'phone_codes': info['phone_codes'],
                'pincode_length': info['pincode_length'],
                'major_cities': info['cities'][:10],
                'states': info['states'][:5]
            }
        return None
    
    def validate_country_context(self, country: str, phone: Optional[str] = None, 
                                 pincode: Optional[str] = None, address: Optional[str] = None) -> Dict:
        """Validate if country matches with other context (phone, pincode, address)"""
        if country not in self.COUNTRY_PATTERNS:
            return {
                'valid': False,
                'error': 'Unsupported country'
            }
        
        country_info = self.COUNTRY_PATTERNS[country]
        conflicts = []
        
        # Validate phone
        if phone:
            inferred_from_phone = self.infer_from_phone(phone)
            if inferred_from_phone and inferred_from_phone != country:
                conflicts.append(f"Phone number suggests {inferred_from_phone}")
        
        # Validate pincode
        if pincode:
            if len(pincode) != country_info['pincode_length']:
                conflicts.append(f"Pincode length should be {country_info['pincode_length']}")
        
        # Validate address
        if address:
            inferred_from_address = self._infer_from_locations(address.lower())
            if inferred_from_address and inferred_from_address != country:
                conflicts.append(f"Address suggests {inferred_from_address}")
        
        if conflicts:
            return {
                'valid': False,
                'conflicts': conflicts,
                'confidence': 'low'
            }
        
        return {
            'valid': True,
            'confidence': 'high'
        }


date_extractor.py:

# agent/extractors/date_extractor.py
"""
Ultra-Enhanced Date Extractor - Handles ALL possible date formats with robust error handling
"""

import re
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime, timedelta
import calendar
from .base_extractor import BaseExtractor


class DateExtractor(BaseExtractor):
    """Comprehensive date extraction with error prevention"""
    
    # Month mappings (English)
    MONTH_MAP = {
        'jan': 1, 'january': 1,
        'feb': 2, 'february': 2,
        'mar': 3, 'march': 3,
        'apr': 4, 'april': 4,
        'may': 5,
        'jun': 6, 'june': 6,
        'jul': 7, 'july': 7,
        'aug': 8, 'august': 8,
        'sep': 9, 'sept': 9, 'september': 9,
        'oct': 10, 'october': 10,
        'nov': 11, 'november': 11,
        'dec': 12, 'december': 12
    }
    
    # Hindi month names
    MONTH_MAP_HI = {
        '‡§ú‡§®‡§µ‡§∞‡•Ä': 1, '‡§´‡§∞‡§µ‡§∞‡•Ä': 2, '‡§Æ‡§æ‡§∞‡•ç‡§ö': 3, '‡§Ö‡§™‡•ç‡§∞‡•à‡§≤': 4,
        '‡§Æ‡§à': 5, '‡§ú‡•Ç‡§®': 6, '‡§ú‡•Å‡§≤‡§æ‡§à': 7, '‡§Ö‡§ó‡§∏‡•ç‡§§': 8,
        '‡§∏‡§ø‡§§‡§Ç‡§¨‡§∞': 9, '‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞': 10, '‡§®‡§µ‡§Ç‡§¨‡§∞': 11, '‡§¶‡§ø‡§∏‡§Ç‡§¨‡§∞': 12
    }
    
    # Nepali month names (Devanagari)
    MONTH_MAP_NE = {
        '‡§ú‡§®‡§µ‡§∞‡•Ä': 1, '‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§Ö‡§∞‡•Ä': 2, '‡§Æ‡§æ‡§∞‡•ç‡§ö': 3, '‡§Ö‡§™‡•ç‡§∞‡§ø‡§≤': 4,
        '‡§Æ‡•á': 5, '‡§ú‡•Å‡§®': 6, '‡§ú‡•Å‡§≤‡§æ‡§à': 7, '‡§Ö‡§ó‡§∏‡•ç‡§ü': 8,
        '‡§∏‡•á‡§™‡•ç‡§ü‡•á‡§Æ‡•ç‡§¨‡§∞': 9, '‡§Ö‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞': 10, '‡§®‡•ã‡§≠‡•á‡§Æ‡•ç‡§¨‡§∞': 11, '‡§°‡§ø‡§∏‡•á‡§Æ‡•ç‡§¨‡§∞': 12
    }
    
    # Marathi month names
    MONTH_MAP_MR = {
        '‡§ú‡§æ‡§®‡•á‡§µ‡§æ‡§∞‡•Ä': 1, '‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä': 2, '‡§Æ‡§æ‡§∞‡•ç‡§ö': 3, '‡§è‡§™‡•ç‡§∞‡§ø‡§≤': 4,
        '‡§Æ‡•á': 5, '‡§ú‡•Ç‡§®': 6, '‡§ú‡•Å‡§≤‡•à': 7, '‡§ë‡§ó‡§∏‡•ç‡§ü': 8,
        '‡§∏‡§™‡•ç‡§ü‡•á‡§Ç‡§¨‡§∞': 9, '‡§ë‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞': 10, '‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç‡§¨‡§∞': 11, '‡§°‡§ø‡§∏‡•á‡§Ç‡§¨‡§∞': 12
    }
    
    # Words that look like months but aren't (false positives to avoid)
    FALSE_POSITIVE_WORDS = {
        'december', 'remembered', 'september', 'octopus', 'mayonnaise', 
        'juliet', 'august', 'april', 'march', 'june'
    }
    
    # Relative date keywords
    RELATIVE_KEYWORDS = {
        'today', 'tomorrow', 'yesterday', 'tonight',
        'next week', 'next month', 'next year',
        'this week', 'this month', 'this year',
        'day after tomorrow', 'day after',
        '‡§Ü‡§ú', '‡§ï‡§≤', '‡§™‡§∞‡§∏‡•ã‡§Ç',  # Hindi
        '‡§Ü‡§ú‡§ï‡•ã', '‡§≠‡•ã‡§≤‡§ø', '‡§™‡§∞‡•ç‡§∏‡§ø',  # Nepali
        '‡§Ü‡§ú', '‡§â‡§¶‡•ç‡§Ø‡§æ', '‡§™‡§∞‡§µ‡§æ'  # Marathi
    }
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract date from message with comprehensive error handling"""
        if not message or len(message.strip()) == 0:
            return None
        
        original_message = message
        message = self.clean_message(message)
        
        # Quick check for date indicators
        if not self._has_date_indicators(message):
            return None
        
        # Try multiple extraction methods in order of confidence
        extraction_methods = [
            ('iso_standard', self._extract_iso_date),                    # "2026-02-15"
            ('compact_with_year', self._extract_compact_date_with_year), # "2feb2026"
            ('full_with_year', self._extract_full_date_with_month_name), # "25 june 2026"
            ('written_format', self._extract_written_date),              # "15th of February 2026"
            ('numeric', self._extract_numeric_date),                     # "15/02/2026"
            ('relative', self._extract_relative_date),                   # "tomorrow"
            ('natural_language', self._extract_natural_language_date),   # "next friday"
            ('partial', self._extract_partial_date),                     # "2feb" (no year)
            ('year_month', self._extract_year_month),                    # "Feb 2026" (just month/year)
        ]
        
        for method_name, method in extraction_methods:
            try:
                result = method(message)
                if result and self._validate_extracted_date(result):
                    result['extraction_method'] = method_name
                    result['extraction_complete'] = not result.get('needs_year', False)
                    return result
            except Exception as e:
                # Log but don't crash
                continue
        
        return None
    
    def _has_date_indicators(self, message: str) -> bool:
        """Check if message likely contains a date - strict check to avoid false positives"""
        msg_lower = message.lower()
        
        # Check for relative date keywords (exact match)
        for keyword in self.RELATIVE_KEYWORDS:
            if keyword in msg_lower:
                return True
        
        # Check for month names (but not as part of other words)
        month_pattern = '|'.join(self.MONTH_MAP.keys())
        if re.search(rf'\b({month_pattern})\b', msg_lower):
            return True
        
        # Check for Hindi/Nepali/Marathi months
        for month_dict in [self.MONTH_MAP_HI, self.MONTH_MAP_NE, self.MONTH_MAP_MR]:
            for month_name in month_dict.keys():
                if month_name in message:
                    return True
        
        # Check for numeric date patterns (strict)
        date_patterns = [
            r'\b\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2,4}\b',  # DD/MM/YYYY
            r'\b\d{4}[/\-\.]\d{1,2}[/\-\.]\d{1,2}\b',    # YYYY-MM-DD
            r'\b\d{1,2}(?:st|nd|rd|th)\b',                # 15th, 2nd
        ]
        
        for pattern in date_patterns:
            if re.search(pattern, msg_lower):
                return True
        
        return False
    
    def _extract_iso_date(self, message: str) -> Optional[Dict]:
        """Extract ISO format: YYYY-MM-DD or YYYY/MM/DD"""
        pattern = r'\b(\d{4})[/\-\.](\d{1,2})[/\-\.](\d{1,2})\b'
        
        match = re.search(pattern, message)
        if not match:
            return None
        
        try:
            year, month, day = map(int, match.groups())
            
            # Validate
            if not self._is_valid_date_parts(year, month, day):
                return None
            
            date_obj = datetime(year, month, day)
            
            return {
                'date': date_obj.strftime('%Y-%m-%d'),
                'date_obj': date_obj,
                'formatted': date_obj.strftime('%d %b %Y'),
                'confidence': 'very_high',
                'method': 'iso_standard',
                'needs_year': False,
                'original': match.group(0)
            }
        except (ValueError, OverflowError):
            return None
    
    def _extract_compact_date_with_year(self, message: str) -> Optional[Dict]:
        """
        Extract: "2feb2026", "2feb 2026", "2 feb 2026", "15march2025"
        """
        patterns = [
            # "2feb2026" - no spaces at all
            (r'(\d{1,2})(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*(\d{4})\b', 'dmy_compact'),
            # "2 feb 2026" - with spaces
            (r'(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{4})\b', 'dmy_space'),
            # "feb 2 2026" - month first
            (r'(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{1,2})\s*,?\s*(\d{4})\b', 'mdy'),
        ]
        
        msg_lower = message.lower()
        
        for pattern, format_type in patterns:
            match = re.search(pattern, msg_lower)
            if not match:
                continue
            
            try:
                if format_type in ['dmy_compact', 'dmy_space']:
                    day_str, month_str, year_str = match.groups()
                    day = int(day_str)
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                elif format_type == 'mdy':
                    month_str, day_str, year_str = match.groups()
                    day = int(day_str)
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                
                if month is None or not self._is_valid_date_parts(year, month, day):
                    continue
                
                date_obj = datetime(year, month, day)
                
                return {
                    'date': date_obj.strftime('%Y-%m-%d'),
                    'date_obj': date_obj,
                    'formatted': date_obj.strftime('%d %b %Y'),
                    'confidence': 'high',
                    'method': 'compact_date_with_year',
                    'needs_year': False,
                    'original': match.group(0)
                }
            except (ValueError, OverflowError):
                continue
        
        return None
    
    def _extract_full_date_with_month_name(self, message: str) -> Optional[Dict]:
        """
        Extract: "25 june 2026", "25th june 2026", "june 25, 2026"
        """
        patterns = [
            # "25th june 2026"
            (r'(\d{1,2})(?:st|nd|rd|th)?\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s*,?\s*(\d{4})\b', 'dmy'),
            # "june 25th, 2026"
            (r'(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{1,2})(?:st|nd|rd|th)?\s*,?\s*(\d{4})\b', 'mdy'),
        ]
        
        msg_lower = message.lower()
        
        for pattern, format_type in patterns:
            match = re.search(pattern, msg_lower)
            if not match:
                continue
            
            try:
                if format_type == 'dmy':
                    day_str, month_str, year_str = match.groups()
                    day = int(re.sub(r'\D', '', day_str))
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                elif format_type == 'mdy':
                    month_str, day_str, year_str = match.groups()
                    day = int(re.sub(r'\D', '', day_str))
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                
                if month is None or not self._is_valid_date_parts(year, month, day):
                    continue
                
                date_obj = datetime(year, month, day)
                
                return {
                    'date': date_obj.strftime('%Y-%m-%d'),
                    'date_obj': date_obj,
                    'formatted': date_obj.strftime('%d %b %Y'),
                    'confidence': 'high',
                    'method': 'full_date_with_year',
                    'needs_year': False,
                    'original': match.group(0)
                }
            except (ValueError, OverflowError):
                continue
        
        return None
    
    def _extract_written_date(self, message: str) -> Optional[Dict]:
        """
        Extract: "15th of February 2026", "the 25th of june"
        """
        patterns = [
            # "15th of February 2026"
            (r'(\d{1,2})(?:st|nd|rd|th)?\s+of\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{4})\b', 'dmy'),
            # "February 15th, 2026"
            (r'(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{1,2})(?:st|nd|rd|th)?\s*,?\s*(\d{4})\b', 'mdy'),
        ]
        
        msg_lower = message.lower()
        
        for pattern, format_type in patterns:
            match = re.search(pattern, msg_lower)
            if not match:
                continue
            
            try:
                if format_type == 'dmy':
                    day_str, month_str, year_str = match.groups()
                    day = int(re.sub(r'\D', '', day_str))
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                elif format_type == 'mdy':
                    month_str, day_str, year_str = match.groups()
                    day = int(re.sub(r'\D', '', day_str))
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                
                if month is None or not self._is_valid_date_parts(year, month, day):
                    continue
                
                date_obj = datetime(year, month, day)
                
                return {
                    'date': date_obj.strftime('%Y-%m-%d'),
                    'date_obj': date_obj,
                    'formatted': date_obj.strftime('%d %b %Y'),
                    'confidence': 'high',
                    'method': 'written_format',
                    'needs_year': False,
                    'original': match.group(0)
                }
            except (ValueError, OverflowError):
                continue
        
        return None
    
    def _extract_numeric_date(self, message: str) -> Optional[Dict]:
        """
        Extract: "15/02/2026", "15-02-2026", "02/15/2026", "15.02.2026"
        """
        patterns = [
            # DD/MM/YYYY or DD-MM-YYYY or DD.MM.YYYY
            (r'\b(\d{1,2})[/\-\.](\d{1,2})[/\-\.](\d{4})\b', 'dmy'),
            # DD/MM/YY (2-digit year)
            (r'\b(\d{1,2})[/\-\.](\d{1,2})[/\-\.](\d{2})\b', 'dmy_short'),
            # DD/MM (no year)
            (r'\b(\d{1,2})[/\-\.](\d{1,2})\b(?![/\-\.])', 'dm_partial'),
        ]
        
        now = datetime.now()
        
        for pattern, format_type in patterns:
            matches = re.finditer(pattern, message)
            for match in matches:
                try:
                    if format_type == 'dmy':
                        first, second, year = map(int, match.groups())
                        
                        # Determine if DD/MM or MM/DD
                        if first > 12 and second <= 12:
                            day, month = first, second
                        elif second > 12 and first <= 12:
                            day, month = second, first
                        elif first <= 12 and second <= 12:
                            # Ambiguous - default to DD/MM (international)
                            day, month = first, second
                        else:
                            continue
                    
                    elif format_type == 'dmy_short':
                        first, second, year_short = map(int, match.groups())
                        
                        # Convert 2-digit year to 4-digit
                        current_year = now.year
                        century = (current_year // 100) * 100
                        year = century + year_short
                        
                        # If year is more than 20 years in past, assume next century
                        if year < current_year - 20:
                            year += 100
                        
                        # Determine day/month
                        if first > 12 and second <= 12:
                            day, month = first, second
                        elif second > 12 and first <= 12:
                            day, month = second, first
                        else:
                            day, month = first, second
                    
                    elif format_type == 'dm_partial':
                        first, second = map(int, match.groups())
                        
                        # Determine day/month
                        if first > 12 and second <= 12:
                            day, month = first, second
                        elif second > 12 and first <= 12:
                            day, month = second, first
                        else:
                            day, month = first, second
                        
                        # Assume year
                        year = now.year
                        test_date = datetime(year, month, day)
                        if test_date < now:
                            year += 1
                    
                    if not self._is_valid_date_parts(year, month, day):
                        continue
                    
                    date_obj = datetime(year, month, day)
                    
                    return {
                        'date': date_obj.strftime('%Y-%m-%d'),
                        'date_obj': date_obj,
                        'formatted': date_obj.strftime('%d %b %Y'),
                        'confidence': 'medium' if format_type == 'dm_partial' else 'high',
                        'method': 'numeric_date',
                        'needs_year': format_type == 'dm_partial',
                        'original': match.group(0)
                    }
                except (ValueError, OverflowError):
                    continue
        
        return None
    
    def _extract_relative_date(self, message: str) -> Optional[Dict]:
        """
        Extract: "today", "tomorrow", "yesterday", "next week"
        """
        msg_lower = message.lower()
        now = datetime.now()
        
        # English relative dates
        relative_map = {
            'today': 0,
            'tonight': 0,
            'tomorrow': 1,
            'tmrw': 1,
            'tmr': 1,
            'day after tomorrow': 2,
            'day after': 2,
            'overmorrow': 2,
            'yesterday': -1,
            'next week': 7,
            'in a week': 7,
            'next month': 30,
            'in a month': 30,
            'next year': 365,
            # Hindi
            '‡§Ü‡§ú': 0,
            '‡§ï‡§≤': 1,
            '‡§™‡§∞‡§∏‡•ã‡§Ç': 2,
            # Nepali
            '‡§Ü‡§ú‡§ï‡•ã': 0,
            '‡§≠‡•ã‡§≤‡§ø': 1,
            '‡§™‡§∞‡•ç‡§∏‡§ø': 2,
            # Marathi
            '‡§â‡§¶‡•ç‡§Ø‡§æ': 1,
            '‡§™‡§∞‡§µ‡§æ': 2,
        }
        
        for keyword, days_offset in relative_map.items():
            if keyword in msg_lower:
                target_date = now + timedelta(days=days_offset)
                
                return {
                    'date': target_date.strftime('%Y-%m-%d'),
                    'date_obj': target_date,
                    'formatted': target_date.strftime('%d %b %Y'),
                    'confidence': 'very_high',
                    'method': 'relative_date',
                    'needs_year': False,
                    'original': keyword
                }
        
        return None
    
    def _extract_natural_language_date(self, message: str) -> Optional[Dict]:
        """
        Extract: "next friday", "this monday", "coming saturday"
        """
        msg_lower = message.lower()
        now = datetime.now()
        
        # Day names
        day_names = {
            'monday': 0, 'mon': 0,
            'tuesday': 1, 'tue': 1, 'tues': 1,
            'wednesday': 2, 'wed': 2,
            'thursday': 3, 'thu': 3, 'thur': 3, 'thurs': 3,
            'friday': 4, 'fri': 4,
            'saturday': 5, 'sat': 5,
            'sunday': 6, 'sun': 6,
        }
        
        for day_name, day_num in day_names.items():
            # "next friday" or "coming friday"
            if re.search(rf'\b(next|coming|this)\s+{day_name}\b', msg_lower):
                current_day = now.weekday()
                days_ahead = day_num - current_day
                
                if days_ahead <= 0:
                    days_ahead += 7
                
                target_date = now + timedelta(days=days_ahead)
                
                return {
                    'date': target_date.strftime('%Y-%m-%d'),
                    'date_obj': target_date,
                    'formatted': target_date.strftime('%d %b %Y'),
                    'confidence': 'high',
                    'method': 'natural_language',
                    'needs_year': False,
                    'original': f"next {day_name}"
                }
        
        return None
    
    def _extract_partial_date(self, message: str) -> Optional[Dict]:
        """
        Extract: "2feb", "2 feb", "15march" (no year)
        """
        patterns = [
            # "2feb" - compact
            (r'\b(\d{1,2})(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\b', 'dm_compact'),
            # "2 feb" - with space
            (r'\b(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\b', 'dm_space'),
            # "feb 2" - month first
            (r'\b(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{1,2})(?:st|nd|rd|th)?\b', 'md'),
        ]
        
        msg_lower = message.lower()
        now = datetime.now()
        
        for pattern, format_type in patterns:
            match = re.search(pattern, msg_lower)
            if not match:
                continue
            
            try:
                if format_type in ['dm_compact', 'dm_space']:
                    day_str, month_str = match.groups()
                    day = int(day_str)
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                elif format_type == 'md':
                    month_str, day_str = match.groups()
                    day = int(re.sub(r'\D', '', day_str))
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                
                if month is None:
                    continue
                
                # Assume year
                year = now.year
                
                # Validate day for month
                if not self._is_valid_day_for_month(year, month, day):
                    continue
                
                # Check if in past
                test_date = datetime(year, month, day)
                if test_date < now:
                    year += 1
                    test_date = datetime(year, month, day)
                
                return {
                    'date': test_date.strftime('%Y-%m-%d'),
                    'date_obj': test_date,
                    'formatted': test_date.strftime('%d %b %Y'),
                    'confidence': 'medium',
                    'method': 'partial_date',
                    'needs_year': True,
                    'original': match.group(0),
                    'assumed_year': year
                }
            except (ValueError, OverflowError):
                continue
        
        return None
    
    def _extract_year_month(self, message: str) -> Optional[Dict]:
        """
        Extract: "Feb 2026", "February 2026" (just month and year, no day)
        Returns 1st of the month
        """
        patterns = [
            (r'\b(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s+(\d{4})\b', 'my'),
            (r'\b(\d{4})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\b', 'ym'),
        ]
        
        msg_lower = message.lower()
        
        for pattern, format_type in patterns:
            match = re.search(pattern, msg_lower)
            if not match:
                continue
            
            try:
                if format_type == 'my':
                    month_str, year_str = match.groups()
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                elif format_type == 'ym':
                    year_str, month_str = match.groups()
                    month = self.MONTH_MAP.get(month_str[:3].lower())
                    year = int(year_str)
                
                if month is None or not self._is_valid_year(year):
                    continue
                
                # Use 1st of the month
                day = 1
                date_obj = datetime(year, month, day)
                
                return {
                    'date': date_obj.strftime('%Y-%m-%d'),
                    'date_obj': date_obj,
                    'formatted': date_obj.strftime('%b %Y'),
                    'confidence': 'low',
                    'method': 'year_month_only',
                    'needs_year': False,
                    'needs_day': True,
                    'original': match.group(0)
                }
            except (ValueError, OverflowError):
                continue
        
        return None
    
    def _is_valid_date_parts(self, year: int, month: int, day: int) -> bool:
        """Validate year, month, day"""
        try:
            # Validate year (reasonable range)
            if not self._is_valid_year(year):
                return False
            
            # Validate month
            if not (1 <= month <= 12):
                return False
            
            # Validate day for month
            if not self._is_valid_day_for_month(year, month, day):
                return False
            
            # Try creating datetime object
            datetime(year, month, day)
            return True
            
        except (ValueError, OverflowError):
            return False
    
    def _is_valid_year(self, year: int) -> bool:
        """Check if year is in reasonable range"""
        current_year = datetime.now().year
        return (current_year - 1) <= year <= (current_year + 10)
    
    def _is_valid_day_for_month(self, year: int, month: int, day: int) -> bool:
        """Check if day is valid for given month/year"""
        try:
            if day < 1:
                return False
            
            # Get last day of month
            last_day = calendar.monthrange(year, month)[1]
            return day <= last_day
            
        except (ValueError, TypeError):
            return False
    
    def _validate_extracted_date(self, result: Dict) -> bool:
        """Final validation of extracted date"""
        if not result or 'date_obj' not in result:
            return False
        
        try:
            date_obj = result['date_obj']
            
            # Check if date is reasonable (not too far in past or future)
            now = datetime.now()
            days_diff = (date_obj - now).days
            
            # Allow 1 year in past to 10 years in future
            if days_diff < -365 or days_diff > 3650:
                return False
            
            return True
            
        except Exception:
            return False
    
    def clean_message(self, message: str) -> str:
        """Clean message while preserving date formats"""
        # Remove extra whitespace but preserve structure
        message = ' '.join(message.split())
        # Remove common non-date punctuation
        message = re.sub(r'[!?;]', ' ', message)
        return message


email_extractor.py:

"""
Email Extractor - Comprehensive email validation and extraction
"""

import re
from typing import Optional, Dict, Any, List
from .base_extractor import BaseExtractor


class EmailExtractor(BaseExtractor):
    """Extract email addresses from messages with comprehensive validation"""
    
    # Comprehensive email regex pattern
    EMAIL_PATTERN = r'\b[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9][a-zA-Z0-9.-]*\.[a-zA-Z]{2,}\b'
    
    # More specific patterns for better accuracy
    STRICT_EMAIL_PATTERN = r'\b[a-zA-Z0-9][a-zA-Z0-9._%-]{0,63}@[a-zA-Z0-9][a-zA-Z0-9.-]{0,253}\.[a-zA-Z]{2,10}\b'
    
    # Common email providers (for confidence scoring)
    COMMON_PROVIDERS = {
        # Free email providers
        'gmail.com': 'high',
        'yahoo.com': 'high',
        'outlook.com': 'high',
        'hotmail.com': 'high',
        'icloud.com': 'high',
        'protonmail.com': 'high',
        'mail.com': 'high',
        
        # Indian providers
        'rediffmail.com': 'high',
        'ymail.com': 'medium',
        'live.com': 'high',
        'msn.com': 'medium',
        
        # Professional providers
        'zoho.com': 'medium',
        'aol.com': 'medium',
        'gmx.com': 'medium',
        'fastmail.com': 'medium',
        
        # Country-specific TLDs
        '.in': 'medium',      # India
        '.np': 'medium',      # Nepal
        '.pk': 'medium',      # Pakistan
        '.bd': 'medium',      # Bangladesh
        '.ae': 'medium',      # UAE
        '.co.in': 'medium',   # India commercial
        '.org.in': 'medium',  # India organization
        '.edu': 'medium',     # Educational
    }
    
    # Email indicators/keywords
    EMAIL_INDICATORS = [
        'email', 'mail', 'e-mail', 'gmail', 'yahoo', 'outlook',
        '‡§à‡§Æ‡•á‡§≤', '‡§Æ‡•á‡§≤', '‡§ú‡•Ä‡§Æ‡•á‡§≤', '‡§á‡§Æ‡•á‡§≤', '‡§à-‡§Æ‡•á‡§≤'
    ]
    
    # Suspicious patterns (likely not real emails)
    SUSPICIOUS_PATTERNS = [
        r'\.(png|jpg|jpeg|gif|pdf|doc|docx|txt|zip)$',  # File extensions
        r'@(localhost|test|example|dummy|fake)',         # Test domains
        r'^(test|demo|example|dummy|fake)',              # Test local parts
        r'@\d+\.\d+\.\d+\.\d+',                         # IP addresses
        r'\.{2,}',                                       # Multiple consecutive dots
        r'^\.|\.$',                                      # Starts or ends with dot
    ]
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract email address from message"""
        message = self.clean_message(message)
        
        # Try explicit email patterns first (with indicators)
        result = self._extract_explicit_email(message)
        if result:
            self.log_extraction('email', True, 'explicit')
            return result
        
        # Try standard email pattern
        result = self._extract_standard_email(message)
        if result:
            self.log_extraction('email', True, 'standard')
            return result
        
        # Try to find emails in conversation history
        if context:
            history = self.get_conversation_history(context)
            result = self.search_in_history(history, self._extract_standard_email)
            if result:
                self.log_extraction('email', True, 'history')
                return result
        
        self.log_extraction('email', False)
        return None
    
    def _extract_explicit_email(self, message: str) -> Optional[Dict]:
        """Extract email with explicit indicators like 'email: john@example.com'"""
        msg_lower = message.lower()
        
        # Patterns with indicators
        patterns = [
            # "email: john@example.com"
            r'(?:email|e-mail|mail)\s*[:\-]?\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
            # "my email is john@example.com"
            r'(?:my\s+)?(?:email|e-mail|mail)\s+(?:is|:)\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
            # Hindi/Nepali patterns
            r'(?:‡§à‡§Æ‡•á‡§≤|‡§Æ‡•á‡§≤|‡§á‡§Æ‡•á‡§≤)\s*[:\-]?\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, msg_lower)
            if match:
                email = match.group(1).lower()
                
                if self._validate_email_format(email):
                    return self._build_email_result(email, 'high', 'explicit_pattern')
        
        return None
    
    def _extract_standard_email(self, message: str) -> Optional[Dict]:
        """Extract email using standard pattern matching"""
        # Find all potential emails
        emails = self._find_email_patterns(message)
        
        if not emails:
            return None
        
        # Validate and score each email
        valid_emails = []
        for email in emails:
            if self._validate_email_candidate(email):
                confidence = self._calculate_confidence(email)
                valid_emails.append((email, confidence))
        
        if not valid_emails:
            return None
        
        # Sort by confidence and return best
        valid_emails.sort(key=lambda x: self._confidence_score(x[1]), reverse=True)
        best_email, confidence = valid_emails[0]
        
        return self._build_email_result(best_email, confidence, 'pattern_match')
    
    def _find_email_patterns(self, message: str) -> List[str]:
        """Find all email patterns in message"""
        emails = []
        
        # Use strict pattern first
        matches = re.finditer(self.STRICT_EMAIL_PATTERN, message, re.IGNORECASE)
        for match in matches:
            emails.append(match.group(0).lower())
        
        # Try relaxed pattern if no results
        if not emails:
            matches = re.finditer(self.EMAIL_PATTERN, message, re.IGNORECASE)
            for match in matches:
                emails.append(match.group(0).lower())
        
        # Remove duplicates while preserving order
        seen = set()
        unique_emails = []
        for email in emails:
            if email not in seen:
                seen.add(email)
                unique_emails.append(email)
        
        return unique_emails
    
    def _validate_email_format(self, email: str) -> bool:
        """Validate email format with comprehensive checks"""
        if not email or '@' not in email:
            return False
        
        # Basic regex validation
        if not re.match(self.STRICT_EMAIL_PATTERN, email, re.IGNORECASE):
            return False
        
        # Split into local and domain parts
        try:
            local, domain = email.rsplit('@', 1)
        except ValueError:
            return False
        
        # Validate local part
        if not self._validate_local_part(local):
            return False
        
        # Validate domain part
        if not self._validate_domain_part(domain):
            return False
        
        return True
    
    def _validate_local_part(self, local: str) -> bool:
        """Validate email local part (before @)"""
        # Length check
        if len(local) < 1 or len(local) > 64:
            return False
        
        # Cannot start or end with dot
        if local.startswith('.') or local.endswith('.'):
            return False
        
        # Cannot have consecutive dots
        if '..' in local:
            return False
        
        # Must contain at least one alphanumeric
        if not any(c.isalnum() for c in local):
            return False
        
        # Check for valid characters only
        valid_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._%-')
        if not all(c in valid_chars for c in local):
            return False
        
        return True
    
    def _validate_domain_part(self, domain: str) -> bool:
        """Validate email domain part (after @)"""
        # Length check
        if len(domain) < 1 or len(domain) > 255:
            return False
        
        # Must have at least one dot
        if '.' not in domain:
            return False
        
        # Cannot start or end with dot or hyphen
        if domain.startswith('.') or domain.endswith('.'):
            return False
        if domain.startswith('-') or domain.endswith('-'):
            return False
        
        # Cannot have consecutive dots
        if '..' in domain:
            return False
        
        # Split into labels
        labels = domain.split('.')
        
        # Must have at least 2 labels (domain + TLD)
        if len(labels) < 2:
            return False
        
        # Validate each label
        for label in labels:
            if not label or len(label) > 63:
                return False
            
            # Label can only contain alphanumeric and hyphens
            if not re.match(r'^[a-zA-Z0-9-]+$', label):
                return False
            
            # Cannot start or end with hyphen
            if label.startswith('-') or label.endswith('-'):
                return False
        
        # Validate TLD (last label)
        tld = labels[-1]
        if len(tld) < 2 or len(tld) > 10:
            return False
        
        # TLD should be alphabetic
        if not tld.isalpha():
            return False
        
        return True
    
    def _validate_email_candidate(self, email: str) -> bool:
        """Validate if email candidate is likely real"""
        # Basic format validation
        if not self._validate_email_format(email):
            return False
        
        # Check for suspicious patterns
        for pattern in self.SUSPICIOUS_PATTERNS:
            if re.search(pattern, email, re.IGNORECASE):
                return False
        
        # Check minimum length
        if len(email) < 6:  # Minimum realistic: a@b.co
            return False
        
        # Check local part isn't too short
        local = email.split('@')[0]
        if len(local) < 2:
            return False
        
        return True
    
    def _calculate_confidence(self, email: str) -> str:
        """Calculate confidence level for email"""
        # Get domain
        domain = email.split('@')[-1].lower()
        
        # Check against common providers
        for provider, confidence in self.COMMON_PROVIDERS.items():
            if provider in domain:
                return confidence
        
        # Check for country-specific TLDs
        for tld, confidence in self.COMMON_PROVIDERS.items():
            if tld.startswith('.') and domain.endswith(tld):
                return confidence
        
        # Check domain structure
        labels = domain.split('.')
        
        # Well-known TLDs get higher confidence
        well_known_tlds = ['com', 'org', 'net', 'edu', 'gov', 'co', 'io', 'me']
        if labels[-1] in well_known_tlds:
            return 'medium'
        
        # Has subdomain (more specific, likely real)
        if len(labels) >= 3:
            return 'medium'
        
        # Default
        return 'low'
    
    def _confidence_score(self, confidence: str) -> int:
        """Convert confidence to numeric score for sorting"""
        scores = {'high': 3, 'medium': 2, 'low': 1}
        return scores.get(confidence, 0)
    
    def _build_email_result(self, email: str, confidence: str, method: str) -> Dict:
        """Build email extraction result"""
        domain = email.split('@')[-1]
        local = email.split('@')[0]
        
        # Determine provider
        provider = 'unknown'
        for prov in self.COMMON_PROVIDERS.keys():
            if prov in domain:
                provider = prov
                break
        
        return {
            'email': email.lower(),
            'local_part': local,
            'domain': domain,
            'provider': provider,
            'confidence': confidence,
            'method': method,
            'masked': self._mask_email(email)
        }
    
    def _mask_email(self, email: str) -> str:
        """Mask email for display (privacy)"""
        try:
            local, domain = email.rsplit('@', 1)
            
            if len(local) <= 2:
                masked_local = local[0] + '*'
            elif len(local) <= 4:
                masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
            else:
                # Show first 2 and last 1 character
                masked_local = local[:2] + '*' * (len(local) - 3) + local[-1]
            
            return f"{masked_local}@{domain}"
        except:
            return email
    
    def _clean_email(self, email: str) -> str:
        """Clean email address"""
        email = email.lower().strip()
        
        # Remove surrounding quotes or brackets
        email = re.sub(r'^[\'\"\(\)\[\]\{\}<>]+|[\'\"\(\)\[\]\{\}<>]+$', '', email)
        
        # Remove trailing punctuation
        email = re.sub(r'[.,;!?]+$', '', email)
        
        return email
    
    def validate_email(self, email: str) -> Dict:
        """
        Validate email address
        
        Returns:
            Dict with 'valid' boolean and optional 'error' message
        """
        email = self._clean_email(email)
        
        if not email:
            return {'valid': False, 'error': 'Email is required'}
        
        if not self._validate_email_format(email):
            return {'valid': False, 'error': 'Invalid email format'}
        
        # Check for suspicious patterns
        for pattern in self.SUSPICIOUS_PATTERNS:
            if re.search(pattern, email, re.IGNORECASE):
                return {
                    'valid': False,
                    'error': 'Email appears to be invalid or test address'
                }
        
        return {'valid': True}
    
    def get_provider_info(self, email: str) -> Optional[Dict]:
        """Get information about email provider"""
        domain = email.split('@')[-1].lower()
        
        # Check against known providers
        for provider, confidence in self.COMMON_PROVIDERS.items():
            if provider in domain:
                return {
                    'provider': provider,
                    'type': 'free' if confidence == 'high' else 'unknown',
                    'trusted': confidence == 'high'
                }
        
        return {
            'provider': domain,
            'type': 'custom',
            'trusted': False
        }


name_extractor.py:

"""
Name Extractor - Enhanced for robust name extraction
"""

import re
from typing import Optional, Dict, Any, List
from .base_extractor import BaseExtractor


class NameExtractor(BaseExtractor):
    """Extract names from messages with improved logic"""
    
    # Common titles/honorifics
    TITLES = [
        'mr', 'mrs', 'ms', 'miss', 'dr', 'prof', 'sir', 'madam',
        'shri', 'smt', 'kumari', 'sheikh', 'maulana', 'pandit'
    ]
    
    # Common Indian/Nepali name patterns
    COMMON_FIRST_NAMES = [
        'amit', 'rahul', 'priya', 'sneha', 'rajesh', 'suresh', 'pooja',
        'anita', 'sunita', 'manish', 'rakesh', 'deepak', 'sanjay',
        'vijay', 'ajay', 'anil', 'sunil', 'raj', 'ravi', 'arjun',
        'krishna', 'ram', 'sita', 'gita', 'maya', 'devi', 'kumar',
        'rupesh', 'poudel', 'chirag', 'sharma', 'john', 'smith', 
        'david', 'michael', 'james', 'robert', 'mary', 'jennifer',
        'linda', 'susan', 'patel', 'singh', 'khan', 'verma', 'sharma'
    ]
    
    # Words that are NOT names
    EXCLUDED_WORDS = [
        'book', 'booking', 'service', 'makeup', 'bridal', 'party',
        'engagement', 'wedding', 'henna', 'mehendi', 'package',
        'price', 'cost', 'date', 'time', 'location', 'address',
        'email', 'phone', 'whatsapp', 'number', 'contact',
        'hello', 'hi', 'hey', 'thanks', 'please', 'yes', 'no',
        'want', 'need', 'like', 'today', 'tomorrow', 'yesterday',
        'india', 'nepal', 'pakistan', 'bangladesh', 'dubai',
        'mumbai', 'delhi', 'pune', 'kathmandu', 'karachi', 'dhaka',
        'and', 'the', 'for', 'with', 'this', 'that', 'have', 'has',
        'thank', 'you', 'can', 'could', 'would', 'let', 'me',
        'already', 'gave', 'told', 'provided', 'give', 'need'
    ]
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract name from message"""
        message = self.clean_message(message)
        
        # Try explicit name patterns first
        name = self._extract_explicit_name(message)
        if name:
            return {
                'name': name,
                'confidence': 'high',
                'method': 'explicit'
            }
        
        # Try name with title pattern
        name = self._extract_name_with_title(message)
        if name:
            return {
                'name': name,
                'confidence': 'high',
                'method': 'with_title'
            }
        
        # Try to find proper noun patterns
        name = self._extract_proper_noun(message)
        if name:
            return {
                'name': name,
                'confidence': 'medium',
                'method': 'proper_noun'
            }
        
        # Try simple name detection for short messages (2-3 words)
        name = self._extract_simple_name(message)
        if name:
            return {
                'name': name,
                'confidence': 'medium',
                'method': 'simple'
            }
        
        # Try from conversation context
        if context and 'history' in context:
            name = self._extract_from_history(context['history'])
            if name:
                return {
                    'name': name,
                    'confidence': 'low',
                    'method': 'history'
                }
        
        return None
    
    def _extract_explicit_name(self, message: str) -> Optional[str]:
        """Extract name from explicit patterns like 'my name is...'"""
        patterns = [
            # "My name is John Doe"
            r'(?:my\s+)?name\s+(?:is|:)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})',
            # "My name is john doe" (lowercase)
            r'(?:my\s+)?name\s+(?:is|:)\s+([a-z]+\s+[a-z]+(?:\s+[a-z]+)?)',
            # "I am John Doe" / "I'm John Doe"
            r'I\s+(?:am|\'m)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})',
            # "I am john doe" (lowercase)
            r'I\s+(?:am|\'m)\s+([a-z]+\s+[a-z]+(?:\s+[a-z]+)?)',
            # "This is John Doe"
            r'(?:this\s+is|it\'s)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})',
            # "Name: John Doe"
            r'name\s*:\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})',
            # "Name: john doe" (lowercase)
            r'name\s*:\s*([a-z]+\s+[a-z]+(?:\s+[a-z]+)?)',
            # Hindi/Nepali patterns
            r'(?:mera|‡§Æ‡•á‡§∞‡§æ)\s+(?:naam|‡§®‡§æ‡§Æ)\s+(?:hai|‡§π‡•à)\s+([A-Za-z]+(?:\s+[A-Za-z]+){1,3})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message, re.IGNORECASE)
            if match:
                name = match.group(1).strip()
                if self._validate_name_candidate(name):
                    return self._format_name(name)
        
        return None
    
    def _extract_name_with_title(self, message: str) -> Optional[str]:
        """Extract name that starts with a title"""
        # Build title pattern
        title_pattern = '|'.join(self.TITLES)
        
        # Pattern: "Mr. John Doe" or "Dr John Doe"
        pattern = rf'\b(?:{title_pattern})\.?\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){{1,3}})\b'
        
        match = re.search(pattern, message, re.IGNORECASE)
        if match:
            name_part = match.group(1).strip()
            if self._validate_name_candidate(name_part):
                # Include title in formatted name
                title = match.group(0).split()[0]
                formatted_name = f"{title.title()}. {self._format_name(name_part)}"
                return formatted_name
        
        return None
    
    def _extract_proper_noun(self, message: str) -> Optional[str]:
        """Extract proper nouns that look like names (case-insensitive)"""
        # First check for 2-3 capitalized words in a row
        patterns = [
            # Two capitalized words
            r'\b([A-Z][a-z]+\s+[A-Z][a-z]+)\b',
            # Three capitalized words
            r'\b([A-Z][a-z]+\s+[A-Z][a-z]+\s+[A-Z][a-z]+)\b',
        ]
        
        candidates = []
        for pattern in patterns:
            matches = re.finditer(pattern, message)
            for match in matches:
                candidate = match.group(1).strip()
                if self._validate_name_candidate(candidate):
                    candidates.append(candidate)
        
        # Return the first valid candidate
        if candidates:
            # Prefer longer names (more specific)
            candidates.sort(key=lambda x: len(x.split()), reverse=True)
            return self._format_name(candidates[0])
        
        return None
    
    def _extract_simple_name(self, message: str) -> Optional[str]:
        """Extract simple name patterns (2-3 lowercase words)"""
        # Clean message - remove common patterns that are not names
        clean_msg = message.lower()
        
        # Remove any email, phone, date patterns first
        clean_msg = re.sub(r'\+\d{10,15}', '', clean_msg)  # Remove phone
        clean_msg = re.sub(r'\S+@\S+\.\S+', '', clean_msg)  # Remove email
        clean_msg = re.sub(r'\b\d{1,2}[-/]\d{1,2}[-/]\d{4}\b', '', clean_msg)  # Remove date
        clean_msg = re.sub(r'\b\d{5,6}\b', '', clean_msg)  # Remove pincode
        
        # Also remove common booking-related words
        for word in self.EXCLUDED_WORDS:
            clean_msg = re.sub(rf'\b{word}\b', '', clean_msg, flags=re.IGNORECASE)
        
        # Clean extra spaces
        clean_msg = re.sub(r'\s+', ' ', clean_msg).strip()
        
        # Look for 2-3 word sequences that look like names
        # Pattern for 2-3 words, each at least 2 characters
        pattern = r'\b([a-z]{2,}\s+[a-z]{2,}(?:\s+[a-z]{2,})?)\b'
        
        matches = re.findall(pattern, clean_msg)
        for name_candidate in matches:
            # Skip if it's too long or too short
            words = name_candidate.split()
            if len(words) not in [2, 3]:
                continue
                
            # Check if it's likely a name (not a sentence or common phrase)
            if self._looks_like_name(words):
                return self._format_name(name_candidate)
        
        return None
    
    def _extract_from_history(self, history: List[Dict]) -> Optional[str]:
        """Extract name from conversation history"""
        if not history:
            return None
        
        # Look through recent user messages
        for msg in reversed(history[-10:]):
            if msg.get('role') == 'user':
                content = msg.get('content', '')
                
                # Try extraction methods
                name = self._extract_explicit_name(content)
                if name:
                    return name
                
                name = self._extract_name_with_title(content)
                if name:
                    return name
                
                name = self._extract_proper_noun(content)
                if name:
                    return name
        
        return None
    
    def _looks_like_name(self, words: List[str]) -> bool:
        """Check if words look like a name"""
        candidate = ' '.join(words).lower()
        
        # Common non-name phrases
        non_names = [
            'thank you', 'please help', 'hello there', 'hi there', 
            'can you', 'could you', 'would you', 'let me',
            'i want', 'i need', 'my booking', 'the service',
            'how much', 'what is', 'tell me', 'show me'
        ]
        
        if candidate in non_names:
            return False
        
        # Check if words are too generic
        generic_words = ['and', 'the', 'for', 'with', 'this', 'that', 'have', 'has']
        if any(word in generic_words for word in words):
            return False
        
        # Check if at least one word looks like a common name
        return any(word in self.COMMON_FIRST_NAMES for word in words)
    
    def _validate_name_candidate(self, name: str) -> bool:
        """Validate if string is likely a name"""
        if not name or len(name) < 2:
            return False
        
        # Split into words
        words = name.split()
        
        # Check word count (1-4 words for names)
        if len(words) < 1 or len(words) > 4:
            return False
        
        # Check each word
        for word in words:
            word_lower = word.lower()
            
            # Check minimum length
            if len(word) < 2:
                return False
            
            # Check if it's an excluded word
            if word_lower in self.EXCLUDED_WORDS:
                return False
            
            # Check if it has digits (names shouldn't have digits)
            if any(c.isdigit() for c in word):
                return False
            
            # Check if it's all uppercase (likely acronym, not name)
            if word.isupper() and len(word) > 1:
                return False
        
        # Additional validation for single words
        if len(words) == 1:
            word_lower = words[0].lower()
            # Single word should be a common first name or at least 3 chars
            if len(words[0]) < 3 and word_lower not in self.COMMON_FIRST_NAMES:
                return False
        
        # Check if the whole phrase is not in excluded list
        full_phrase = ' '.join([w.lower() for w in words])
        if full_phrase in self.EXCLUDED_WORDS:
            return False
        
        return True
    
    def _format_name(self, name: str) -> str:
        """Format name (capitalize properly)"""
        # Split into words
        words = name.split()
        
        # Special cases for titles
        if len(words) > 1 and words[0].lower() in self.TITLES:
            # Format title with dot
            title = words[0].lower()
            if not title.endswith('.'):
                title = title + '.'
            formatted_words = [title.title()]
            # Format the rest of the name
            for word in words[1:]:
                formatted_words.append(word.capitalize())
            return ' '.join(formatted_words)
        
        # Regular capitalization for all words
        formatted_words = []
        for word in words:
            # Skip empty words
            if not word:
                continue
            
            # Capitalize first letter, rest lowercase
            formatted_word = word[0].upper() + word[1:].lower()
            formatted_words.append(formatted_word)
        
        return ' '.join(formatted_words)
    
    def _find_name_patterns(self, message: str) -> list:
        """Find potential name patterns (legacy method)"""
        candidates = []
        
        # Pattern 1: Sequences of capitalized words
        pattern1 = r'\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})\b'
        matches = re.finditer(pattern1, message)
        for match in matches:
            candidates.append(match.group(1))
        
        # Pattern 2: After "name is/:" or similar
        pattern2 = r'(?:name\s+(?:is|:)|my\s+name\s+is|I\s+am)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3})'
        matches = re.finditer(pattern2, message, re.IGNORECASE)
        for match in matches:
            candidates.append(match.group(1))
        
        return candidates


phone_extractor.py:

"""
Phone Number Extractor - Comprehensive phone extraction with country code validation
"""

import re
from typing import Optional, Dict, Any, List, Tuple
from .base_extractor import BaseExtractor


class PhoneExtractor(BaseExtractor):
    """Extract phone numbers from messages with strict country code validation"""
    
    # Country-specific phone patterns with validation rules
    PHONE_PATTERNS = {
        'India': {
            'country_code': '91',
            'local_length': 10,
            'patterns': [
                r'\+91[\s\-\.]?(\d{10})',           # +91 9876543210
                r'\+91[\s\-\.]?(\d{5})[\s\-\.]?(\d{5})',  # +91 98765 43210
                r'\+91\s*\(?\d{3,5}\)?\s*\d{3,5}\s*\d{4}',  # +91 (98765) 43210
            ],
            'starts_with': ['6', '7', '8', '9'],  # Valid starting digits
            'name': 'Indian'
        },
        'Nepal': {
            'country_code': '977',
            'local_length': 10,  # Can be 9 or 10
            'patterns': [
                r'\+977[\s\-\.]?(\d{9,10})',        # +977 9851234567
                r'\+977[\s\-\.]?(\d{2})[\s\-\.]?(\d{7,8})',  # +977 98 51234567
            ],
            'starts_with': ['9'],  # Usually starts with 9
            'name': 'Nepali'
        },
        'Pakistan': {
            'country_code': '92',
            'local_length': 10,
            'patterns': [
                r'\+92[\s\-\.]?(\d{10})',           # +92 3001234567
                r'\+92[\s\-\.]?(\d{3})[\s\-\.]?(\d{7})',  # +92 300 1234567
            ],
            'starts_with': ['3'],  # Mobile numbers start with 3
            'name': 'Pakistani'
        },
        'Bangladesh': {
            'country_code': '880',
            'local_length': 10,
            'patterns': [
                r'\+880[\s\-\.]?(\d{10})',          # +880 1712345678
                r'\+880[\s\-\.]?(\d{2})[\s\-\.]?(\d{8})',  # +880 17 12345678
            ],
            'starts_with': ['1'],  # Mobile starts with 1
            'name': 'Bangladeshi'
        },
        'Dubai': {
            'country_code': '971',
            'local_length': 9,
            'patterns': [
                r'\+971[\s\-\.]?(\d{9})',           # +971 501234567
                r'\+971[\s\-\.]?(\d{2})[\s\-\.]?(\d{7})',  # +971 50 1234567
            ],
            'starts_with': ['5'],  # Mobile usually starts with 5
            'name': 'UAE'
        },
        'USA': {
            'country_code': '1',
            'local_length': 10,
            'patterns': [
                r'\+1[\s\-\.]?(\d{10})',            # +1 2025551234
                r'\+1[\s\-\.]?\(?\d{3}\)?[\s\-\.]?\d{3}[\s\-\.]?\d{4}',  # +1 (202) 555-1234
            ],
            'starts_with': [],  # No specific requirement
            'name': 'US/Canada'
        }
    }
    
    # Phone keywords/indicators
    PHONE_INDICATORS = [
        'phone', 'mobile', 'whatsapp', 'contact', 'number', 'call',
        '‡§´‡•ã‡§®', '‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤', '‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™', '‡§®‡§Ç‡§¨‡§∞', '‡§´‡§º‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞',
        '‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§®‡§Ç‡§¨‡§∞', '‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï', '‡§ï‡•â‡§≤'
    ]
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract phone number with country code"""
        message = self.clean_message(message)
        
        # Try strict extraction (with country code) first
        result = self.extract_strict(message)
        if result:
            self.log_extraction('phone', True, 'strict')
            return result
        
        # Try to find phone without country code and infer country
        result = self._extract_with_inference(message, context)
        if result:
            self.log_extraction('phone', True, 'inference')
            return result
        
        # Try history if context provided
        if context:
            history = self.get_conversation_history(context)
            result = self.search_in_history(history, self.extract_strict)
            if result:
                self.log_extraction('phone', True, 'history')
                return result
        
        self.log_extraction('phone', False)
        return None
    
    def extract_strict(self, message: str) -> Optional[Dict]:
        """Extract phone with strict validation (must have country code)"""
        # Try each country pattern
        for country, config in self.PHONE_PATTERNS.items():
            for pattern in config['patterns']:
                match = re.search(pattern, message)
                if match:
                    # Extract all digits from the match
                    matched_text = match.group(0)
                    digits = re.sub(r'\D', '', matched_text)
                    
                    # Validate country code
                    country_code = config['country_code']
                    if digits.startswith(country_code):
                        # Extract local number
                        local_number = digits[len(country_code):]
                        
                        # Validate local number length
                        if self._validate_local_number(local_number, config):
                            full_phone = f"+{country_code}{local_number}"
                            
                            return {
                                'phone': local_number,
                                'full_phone': full_phone,
                                'country': country,
                                'country_code': country_code,
                                'confidence': 'high',
                                'method': 'pattern_match',
                                'formatted': self._format_phone(full_phone, country)
                            }
        
        return None
    
    def extract_indian(self, message: str) -> Optional[Dict]:
        """Extract Indian phone number (with or without +91)"""
        # Pattern for 10-digit Indian numbers
        patterns = [
            r'\b([6-9]\d{9})\b',                    # 9876543210
            r'\b([6-9]\d{4})[\s\-\.](\d{5})\b',    # 98765 43210
            r'\b([6-9]\d{2})[\s\-\.](\d{3})[\s\-\.](\d{4})\b',  # 987 654 3210
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message)
            if match:
                # Extract all digits
                digits = ''.join([g for g in match.groups() if g])
                
                # Validate: should be 10 digits and start with 6-9
                if len(digits) == 10 and digits[0] in '6789':
                    full_phone = f"+91{digits}"
                    
                    return {
                        'phone': digits,
                        'full_phone': full_phone,
                        'country': 'India',
                        'country_code': '91',
                        'confidence': 'medium',
                        'method': 'indian_pattern',
                        'formatted': self._format_phone(full_phone, 'India')
                    }
        
        return None
    
    def extract_international(self, message: str) -> Optional[Dict]:
        """Extract international phone number with + prefix"""
        # Generic international pattern
        pattern = r'\+\s*(\d{1,3})[\s\-\.]?(\d[\d\s\-\.\(\)]{6,})'
        
        match = re.search(pattern, message)
        if match:
            country_code = match.group(1)
            local_part = re.sub(r'[^\d]', '', match.group(2))
            
            # Try to identify country from code
            country = self._identify_country_from_code(country_code)
            
            if country:
                config = self.PHONE_PATTERNS[country]
                
                # Validate local number
                if self._validate_local_number(local_part, config):
                    full_phone = f"+{country_code}{local_part}"
                    
                    return {
                        'phone': local_part,
                        'full_phone': full_phone,
                        'country': country,
                        'country_code': country_code,
                        'confidence': 'medium',
                        'method': 'international_pattern',
                        'formatted': self._format_phone(full_phone, country)
                    }
        
        return None
    
    def _extract_with_inference(self, message: str, context: Optional[Dict[str, Any]]) -> Optional[Dict]:
        """Extract phone and infer country from context"""
        # Try to extract Indian number first (most common)
        result = self.extract_indian(message)
        if result:
            return result
        
        # Try international pattern
        result = self.extract_international(message)
        if result:
            return result
        
        # If context has country, try country-specific patterns
        if context:
            country = self.extract_from_context('country', context) or \
                     self.extract_from_context('service_country', context)
            
            if country and country in self.PHONE_PATTERNS:
                result = self._extract_for_country(message, country)
                if result:
                    return result
        
        return None
    
    def _extract_for_country(self, message: str, country: str) -> Optional[Dict]:
        """Extract phone for specific country without country code"""
        if country not in self.PHONE_PATTERNS:
            return None
        
        config = self.PHONE_PATTERNS[country]
        local_length = config['local_length']
        
        # Look for number with appropriate length
        if isinstance(local_length, int):
            pattern = rf'\b(\d{{{local_length}}})\b'
        else:  # Range
            pattern = rf'\b(\d{{{local_length}}})\b'
        
        matches = re.finditer(pattern, message)
        
        for match in matches:
            digits = match.group(1)
            
            # Validate starting digit if specified
            if config['starts_with']:
                if digits[0] not in config['starts_with']:
                    continue
            
            # Build full phone
            full_phone = f"+{config['country_code']}{digits}"
            
            return {
                'phone': digits,
                'full_phone': full_phone,
                'country': country,
                'country_code': config['country_code'],
                'confidence': 'medium',
                'method': 'country_inferred',
                'formatted': self._format_phone(full_phone, country)
            }
        
        return None
    
    def _validate_local_number(self, local_number: str, config: Dict) -> bool:
        """Validate local phone number"""
        # Check length
        expected_length = config['local_length']
        if isinstance(expected_length, int):
            if len(local_number) != expected_length:
                return False
        else:  # Range
            min_len, max_len = expected_length
            if not (min_len <= len(local_number) <= max_len):
                return False
        
        # Check starting digit if specified
        if config['starts_with'] and local_number:
            if local_number[0] not in config['starts_with']:
                return False
        
        # All digits check
        if not local_number.isdigit():
            return False
        
        return True
    
    def _identify_country_from_code(self, country_code: str) -> Optional[str]:
        """Identify country from country code"""
        for country, config in self.PHONE_PATTERNS.items():
            if config['country_code'] == country_code:
                return country
        return None
    
    def _format_phone(self, full_phone: str, country: str) -> str:
        """Format phone number for display"""
        # Remove + for processing
        if full_phone.startswith('+'):
            digits = full_phone[1:]
        else:
            digits = full_phone
        
        config = self.PHONE_PATTERNS.get(country)
        if not config:
            return full_phone
        
        country_code = config['country_code']
        local_number = digits[len(country_code):]
        
        # Format based on country
        if country == 'India':
            # +91 98765 43210
            if len(local_number) == 10:
                return f"+91 {local_number[:5]} {local_number[5:]}"
        elif country == 'Nepal':
            # +977 985 1234567
            if len(local_number) >= 9:
                return f"+977 {local_number[:3]} {local_number[3:]}"
        elif country == 'Pakistan':
            # +92 300 1234567
            if len(local_number) == 10:
                return f"+92 {local_number[:3]} {local_number[3:]}"
        elif country == 'Bangladesh':
            # +880 17 12345678
            if len(local_number) == 10:
                return f"+880 {local_number[:2]} {local_number[2:]}"
        elif country == 'Dubai':
            # +971 50 1234567
            if len(local_number) == 9:
                return f"+971 {local_number[:2]} {local_number[2:]}"
        elif country == 'USA':
            # +1 (202) 555-1234
            if len(local_number) == 10:
                return f"+1 ({local_number[:3]}) {local_number[3:6]}-{local_number[6:]}"
        
        # Default format
        return f"+{country_code} {local_number}"
    
    def _clean_phone_number(self, phone: str) -> str:
        """Clean phone number (remove all non-digits except +)"""
        if phone.startswith('+'):
            return '+' + re.sub(r'\D', '', phone[1:])
        return re.sub(r'\D', '', phone)
    
    def validate_phone(self, phone: str, country: Optional[str] = None) -> Dict:
        """
        Validate phone number
        
        Returns:
            Dict with 'valid' boolean and optional 'error' message
        """
        phone = self._clean_phone_number(phone)
        
        # Must start with +
        if not phone.startswith('+'):
            return {
                'valid': False,
                'error': 'Phone must start with country code (e.g., +91)'
            }
        
        # Extract digits
        digits = phone[1:]
        
        # Minimum length check
        if len(digits) < 10:
            return {
                'valid': False,
                'error': 'Phone number too short'
            }
        
        # If country specified, validate for that country
        if country and country in self.PHONE_PATTERNS:
            config = self.PHONE_PATTERNS[country]
            country_code = config['country_code']
            
            if not digits.startswith(country_code):
                return {
                    'valid': False,
                    'error': f'Country code should be +{country_code} for {country}'
                }
            
            local_number = digits[len(country_code):]
            if not self._validate_local_number(local_number, config):
                return {
                    'valid': False,
                    'error': f'Invalid {config["name"]} phone number format'
                }
        
        return {'valid': True}
    
    def get_country_from_phone(self, phone: str) -> Optional[str]:
        """Get country from phone number"""
        phone = self._clean_phone_number(phone)
        
        if not phone.startswith('+'):
            return None
        
        digits = phone[1:]
        
        # Try to match country code
        for country, config in self.PHONE_PATTERNS.items():
            country_code = config['country_code']
            if digits.startswith(country_code):
                return country
        
        return None


pincode_extractor.py:

"""
Pincode Extractor - Robust PIN/postal code extraction logic
"""

import re
from typing import Optional, Dict, Any, List
from .base_extractor import BaseExtractor


class PincodeExtractor(BaseExtractor):
    """Extract PIN/postal codes from messages with battle-tested logic"""
    
    # Country-specific pincode patterns and validations
    COUNTRY_PATTERNS = {
        'India': {
            'length': 6,
            'pattern': r'\b([1-8]\d{5})\b',  # 6 digits, starts with 1-8
            'name': 'PIN Code'
        },
        'Nepal': {
            'length': 5,
            'pattern': r'\b(\d{5})\b',  # 5 digits
            'name': 'Postal Code'
        },
        'Pakistan': {
            'length': 5,
            'pattern': r'\b(\d{5})\b',  # 5 digits
            'name': 'Postal Code'
        },
        'Bangladesh': {
            'length': 4,
            'pattern': r'\b(\d{4})\b',  # 4 digits
            'name': 'Postal Code'
        },
        'Dubai': {
            'length': 5,
            'pattern': r'\b(\d{5})\b',  # 5 digits (UAE doesn't use postal codes much)
            'name': 'Postal Code'
        }
    }
    
    # Keywords that indicate a pincode
    PINCODE_INDICATORS = [
        'pin', 'pincode', 'pin code', 'postal', 'postal code', 'zip', 'zip code',
        'post code', 'postcode', '‡§™‡§ø‡§®', '‡§™‡§ø‡§®‡§ï‡•ã‡§°', '‡§°‡§æ‡§ï ‡§ï‡•ã‡§°', '‡§™‡•ã‡§∏‡•ç‡§ü‡§≤ ‡§ï‡•ã‡§°'
    ]
    
    def extract(self, message: str, context: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Extract pincode from message"""
        message = self.clean_message(message)
        
        # Get country from context if available
        country = None
        if context:
            country = context.get('country') or context.get('service_country')
        
        # Try explicit pincode patterns first
        pincode = self._extract_explicit_pincode(message)
        if pincode:
            detected_country = self._detect_country_from_pincode(pincode)
            return {
                'pincode': pincode,
                'country': detected_country or country,
                'confidence': 'high',
                'method': 'explicit'
            }
        
        # Try to find pincode patterns in the message
        candidates = self._find_pincode_patterns(message)
        
        if not candidates:
            return None
        
        # Validate candidates
        for candidate in candidates:
            # Skip if it looks like a phone number
            if self._looks_like_phone(candidate, message):
                continue
            
            # Skip if it looks like a date
            if self._looks_like_date(candidate, message):
                continue
            
            # Validate with country if available
            if country:
                if self._validate_pincode_for_country(candidate, country):
                    return {
                        'pincode': candidate,
                        'country': country,
                        'confidence': 'high',
                        'method': 'country_validated'
                    }
            else:
                # Detect country from pincode
                detected_country = self._detect_country_from_pincode(candidate)
                if detected_country:
                    return {
                        'pincode': candidate,
                        'country': detected_country,
                        'confidence': 'medium',
                        'method': 'country_detected'
                    }
        
        # Return first candidate if no validation possible
        if candidates:
            return {
                'pincode': candidates[0],
                'country': country,
                'confidence': 'low',
                'method': 'pattern_match'
            }
        
        return None
    
    def _extract_explicit_pincode(self, message: str) -> Optional[str]:
        """Extract pincode from explicit patterns like 'PIN: 400050'"""
        msg_lower = message.lower()
        
        # Patterns with explicit indicators
        patterns = [
            # "PIN: 400050" or "Pincode: 400050"
            r'(?:pin|pincode|pin code|postal|postal code|zip|zip code|post code|postcode)\s*[:\-]?\s*(\d{4,6})',
            # "PIN 400050"
            r'(?:pin|pincode|postal|zip)\s+(\d{4,6})',
            # Hindi/Nepali patterns
            r'(?:‡§™‡§ø‡§®|‡§™‡§ø‡§®‡§ï‡•ã‡§°|‡§°‡§æ‡§ï ‡§ï‡•ã‡§°|‡§™‡•ã‡§∏‡•ç‡§ü‡§≤ ‡§ï‡•ã‡§°)\s*[:\-]?\s*(\d{4,6})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, msg_lower)
            if match:
                pincode = match.group(1)
                # Validate length
                if 4 <= len(pincode) <= 6:
                    return pincode
        
        return None
    
    def _find_pincode_patterns(self, message: str) -> List[str]:
        """Find all potential pincode patterns in message - FIXED"""
        candidates = []
        
        # Pattern 1: 4-6 digit numbers
        pattern = r'\b(\d{4,6})\b'
        matches = re.finditer(pattern, message)
        
        for match in matches:
            number = match.group(1)
            
            # Skip if it looks like a year (1900-2100)
            if len(number) == 4:
                try:
                    year = int(number)
                    if 1900 <= year <= 2100:
                        continue
                except ValueError:
                    pass
            
            # Skip if it's part of a phone number
            if self._looks_like_phone(number, message):
                continue
            
            # Don't skip based on date context for 5-6 digit numbers
            # Only check for date context for 4-digit numbers that passed year check
            if len(number) == 4:
                # Get context (20 chars before and after)
                start_pos = match.start()
                end_pos = match.end()
                
                context_start = max(0, start_pos - 20)
                context_end = min(len(message), end_pos + 20)
                context = message[context_start:context_end].lower()
                
                # Check for date indicators near the number
                date_indicators = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                                'jul', 'aug', 'sep', 'oct', 'nov', 'dec',
                                'month', 'day', 'date', 'st', 'nd', 'rd', 'th']
                
                # Check if any date indicator is in context
                is_likely_date = any(indicator in context for indicator in date_indicators)
                
                # Check for date patterns like dd/mm or mm/dd
                has_date_pattern = re.search(r'\d{1,2}[-/]\d{1,2}', context) is not None
                
                if is_likely_date or has_date_pattern:
                    continue
            
            # For 5-6 digit numbers, always consider them as potential pincodes
            if self._is_valid_pincode_length(number):
                candidates.append(number)
        
        return candidates
    
    def _is_valid_pincode_length(self, pincode: str) -> bool:
        """Check if pincode has valid length"""
        length = len(pincode)
        # Valid lengths: 4 (Bangladesh), 5 (Nepal, Pakistan, Dubai), 6 (India)
        return length in [4, 5, 6]
    
    def _validate_pincode_for_country(self, pincode: str, country: str) -> bool:
        """Validate pincode for specific country"""
        if country not in self.COUNTRY_PATTERNS:
            return False
        
        country_info = self.COUNTRY_PATTERNS[country]
        
        # Check length
        if len(pincode) != country_info['length']:
            return False
        
        # Check pattern
        pattern = country_info['pattern']
        if not re.match(pattern, pincode):
            return False
        
        # Additional country-specific validations
        if country == 'India':
            # Indian PINs start with 1-8
            if not pincode[0] in '12345678':
                return False
        
        return True
    
    def _detect_country_from_pincode(self, pincode: str) -> Optional[str]:
        """Detect country from pincode pattern"""
        length = len(pincode)
        
        if length == 6:
            # Could be India
            if pincode[0] in '12345678':
                return 'India'
        elif length == 5:
            # Could be Nepal, Pakistan, or Dubai
            # Default to Nepal if no other info
            return 'Nepal'
        elif length == 4:
            # Bangladesh
            return 'Bangladesh'
        
        return None
    
    def _looks_like_phone(self, number: str, message: str) -> bool:
        """Check if number looks like a phone number - FIXED"""
        # Find the number's position in message
        try:
            pos = message.index(number)
        except ValueError:
            return False
        
        # Check context around the number (extended context)
        context_before = message[max(0, pos-15):pos].lower()
        context_after = message[pos+len(number):pos+len(number)+15].lower()
        
        # Phone indicators - more specific
        phone_indicators = [
            'phone', 'whatsapp', 'mobile', 'contact', 'call',
            'number:', 'no:', 'ph:', 'tel:', 'mob:',
            '‡§´‡§º‡•ã‡§®', '‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤', '‡§®‡§Ç‡§¨‡§∞', '‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™'
        ]
        
        # Check if preceded by explicit phone indicators
        for indicator in phone_indicators:
            if indicator in context_before or indicator in context_after:
                return True
        
        # Check if it's preceded by + (country code)
        if '+' in context_before[-5:]:  # Check last 5 chars before the number
            return True
        
        # Check if it's a 10-digit number AND near common phone contexts
        if len(number) == 10:
            # Additional check: is it near common phone patterns?
            phone_contexts = ['91', '977', '92', '880']  # Common country codes
            for code in phone_contexts:
                if code in context_before:
                    return True
        
        return False
    
    def _looks_like_date(self, number: str, message: str) -> bool:
        """Check if number looks like a date"""
        # Find the number's position
        try:
            pos = message.index(number)
        except ValueError:
            return False
        
        # Check context
        context_before = message[max(0, pos-15):pos].lower()
        context_after = message[pos+len(number):pos+len(number)+15].lower()
        
        # Date indicators
        date_indicators = [
            'date', 'day', 'month', 'year', 'when', 'on',
            'jan', 'feb', 'mar', 'apr', 'may', 'jun',
            'jul', 'aug', 'sep', 'oct', 'nov', 'dec',
            '‡§Æ‡§ø‡§§‡§ø', '‡§§‡§æ‡§∞‡•Ä‡§ñ', '‡§¶‡§ø‡§®'
        ]
        
        for indicator in date_indicators:
            if indicator in context_before or indicator in context_after:
                return True
        
        # Check if it's part of a date format (DD/MM/YYYY)
        if '/' in context_before or '/' in context_after:
            return True
        
        if '-' in context_before or '-' in context_after:
            return True
        
        return False
    
    def _get_validation_error(self, pincode: str, country: str) -> str:
        """Get validation error message"""
        if country not in self.COUNTRY_PATTERNS:
            return f"Unknown country: {country}"
        
        country_info = self.COUNTRY_PATTERNS[country]
        expected_length = country_info['length']
        
        if len(pincode) != expected_length:
            return f"{country_info['name']} should be {expected_length} digits (got {len(pincode)})"
        
        if country == 'India' and pincode[0] not in '12345678':
            return "Indian PIN codes start with digits 1-8"
        
        return "Invalid format"

___________________________

Below are folders inside engine close to fsm:

intent_detector.py:
"""
Intent Detector - Enhanced user intent detection
"""

import re
from typing import Dict, List, Optional, Tuple
import logging

logger = logging.getLogger(__name__)


class IntentDetector:
    """Detects various user intents with confidence scoring"""
    
    def __init__(self):
        """Initialize intent detector with comprehensive patterns"""
        
        # Booking intent patterns
        self.booking_keywords = [
            'book', 'booking', 'reserve', 'reservation', 'schedule', 
            'appointment', 'i want to book', 'make booking', 'proceed',
            'book now', 'book service', 'book makeup', 'book bridal',
            'book party', 'book henna', 'make reservation', 'get appointment',
            'interested in booking', 'looking to book', 'want to reserve'
        ]
        
        # Info query patterns
        self.info_keywords = [
            'what', 'which', 'how', 'tell me', 'show me', 'list',
            'information', 'info', 'details', 'about', 'price', 'cost',
            'available', 'offer', 'have', 'do you have', 'can you show',
            'what are', 'what is', 'how much', 'pricing', 'packages'
        ]
        
        # Completion/confirmation patterns
        self.completion_keywords = [
            'done', 'finish', 'finished', 'complete', 'completed',
            'proceed', 'confirm', 'confirmed', 'go ahead', 'send otp',
            'book now', 'ready', 'all set', 'submit', 'finalize',
            "that's all", "that's it", 'all done', 'ready to book'
        ]
        
        # Exit intent patterns
        self.exit_keywords = [
            'exit', 'cancel', 'quit', 'stop', 'nevermind', 'never mind',
            'exit booking', 'cancel booking', 'stop booking', 'abort',
            'forget it', 'not interested', 'changed my mind'
        ]
        
        # Restart patterns
        self.restart_keywords = [
            'restart', 'start over', 'begin again', 'reset', 'new booking',
            'start fresh', 'start again', 'from beginning', 'retry'
        ]
        
        # Frustration indicators
        self.frustration_keywords = [
            'again', 'seriously', 'ugh', 'come on', 'really',
            'annoying', 'frustrating', "what's wrong", 'problem',
            'already gave', 'already provided', 'already told',
            'i told you', 'i said', 'i mentioned', 'you asked',
            'stupid', 'ridiculous', 'unbelievable', 'crazy',
            'not working', 'broken', 'error', 'wrong'
        ]
        
        # Affirmative patterns
        self.affirmative_keywords = [
            'yes', 'yeah', 'yep', 'yup', 'sure', 'ok', 'okay',
            'correct', 'right', 'exactly', 'absolutely', 'definitely',
            'of course', 'indeed', 'affirmative', 'confirmed'
        ]
        
        # Negative patterns
        self.negative_keywords = [
            'no', 'nope', 'nah', 'not', 'never', 'wrong', 'incorrect',
            'not correct', 'not right', "don't", 'dont', 'negative'
        ]
        
        # Service keywords mapping
        self.service_keywords = {
            'Bridal Makeup Services': [
                'bridal', 'bride', 'wedding', 'marriage', 'shaadi',
                'dulhan', 'wedding makeup', 'bridal makeup'
            ],
            'Party Makeup Services': [
                'party', 'function', 'celebration', 'event',
                'party makeup', 'occasion', 'gathering'
            ],
            'Engagement & Pre-Wedding Makeup': [
                'engagement', 'pre-wedding', 'pre wedding', 'sangeet',
                'mehendi', 'cocktail', 'engagement makeup',
                'engagement ceremony', 'ring ceremony'
            ],
            'Henna (Mehendi) Services': [
                'henna', 'mehendi', 'mehndi', 'henna art',
                'bridal henna', 'mehandi', 'mendhi'
            ]
        }
        
        # Question patterns
        self.question_patterns = [
            r'\?$',  # Ends with question mark
            r'^(what|where|when|why|how|which|who|can|could|would|will|is|are|do|does)',
            r'(tell me|show me|explain|describe|help me understand)',
            r'(what if|how about|what about)',
        ]
    
    def detect_intent(self, message: str, context: Dict = None) -> Dict[str, any]:
        """
        Detect primary intent with confidence score
        
        Returns:
            {
                'intent': str (booking|info|completion|exit|restart|question|unknown),
                'confidence': float (0.0-1.0),
                'sub_intent': str (optional),
                'entities': Dict (extracted entities)
            }
        """
        msg_lower = message.lower().strip()
        
        # Check each intent type with scoring
        scores = {
            'booking': self._score_booking_intent(msg_lower, context),
            'info': self._score_info_intent(msg_lower),
            'completion': self._score_completion_intent(msg_lower),
            'exit': self._score_exit_intent(msg_lower),
            'restart': self._score_restart_intent(msg_lower),
            'question': self._score_question_intent(msg_lower),
            'affirmative': self._score_affirmative(msg_lower),
            'negative': self._score_negative(msg_lower)
        }
        
        # Get highest scoring intent
        primary_intent = max(scores.items(), key=lambda x: x[1])
        
        return {
            'intent': primary_intent[0],
            'confidence': primary_intent[1],
            'all_scores': scores,
            'is_question': scores['question'] > 0.3,
            'has_frustration': self.detect_frustration(message)
        }
    
    def detect_booking_intent(self, message: str, history: List = None) -> bool:
        """Detect if user wants to make a booking"""
        msg_lower = message.lower().strip()
        
        # Strong signals - explicit booking keywords
        if any(keyword in msg_lower for keyword in self.booking_keywords):
            return True
        
        # Numeric selection (1-4) when services context exists
        if history:
            last_assistant = self._get_last_assistant_message(history)
            if last_assistant and self._has_service_list_context(last_assistant):
                if re.match(r'^[1-4]$', msg_lower):
                    return True
        
        # Pattern: "I want/need [service]" without info keywords
        want_pattern = r'i\s+(?:want|need|would\s+like)\s+(?:to\s+)?(?:book|get|have|reserve|schedule)'
        if re.search(want_pattern, msg_lower):
            return True
        
        # Pattern: "for [service]" (e.g., "for bridal makeup")
        for_pattern = r'for\s+(?:bridal|party|engagement|henna|mehendi|wedding)'
        if re.search(for_pattern, msg_lower):
            return True
        
        return False
    
    def detect_info_intent(self, message: str) -> bool:
        """Detect if user wants information"""
        msg_lower = message.lower()
        
        has_info = any(keyword in msg_lower for keyword in self.info_keywords)
        has_booking = any(keyword in msg_lower for keyword in self.booking_keywords)
        
        # Info intent if has info keywords but NOT booking keywords
        return has_info and not has_booking
    
    def detect_service_selection(self, message: str, last_shown_list: Optional[str] = None) -> Optional[str]:
        """
        Detect service selection from message
        
        Returns: service number (1-4) or service name
        """
        msg_lower = message.lower().strip()
        
        # Numeric selection (1-4)
        if last_shown_list == "services":
            num_match = re.search(r'\b([1-4])\b', msg_lower)
            if num_match:
                return num_match.group(1)
        
        # Text-based selection
        for service_name, keywords in self.service_keywords.items():
            for keyword in keywords:
                if keyword in msg_lower:
                    return service_name
        
        # Pattern matching for "go for X", "choose X", "select X"
        selection_patterns = [
            r'(?:go\s+for|choose|select|pick|want|need)\s+([1-4])',
            r'([1-4])\s+(?:please|pls)',
            r'option\s+([1-4])',
            r'number\s+([1-4])'
        ]
        
        for pattern in selection_patterns:
            match = re.search(pattern, msg_lower)
            if match:
                return match.group(1)
        
        return None
    
    def detect_package_selection(self, message: str, service: str, last_shown_list: Optional[str] = None) -> Optional[str]:
        """
        Detect package selection from message
        
        Returns: package number (1-3) or None
        """
        msg_lower = message.lower().strip()
        
        # Numeric selection (1-3)
        if last_shown_list == "packages":
            num_match = re.search(r'\b([1-3])\b', msg_lower)
            if num_match:
                return num_match.group(1)
        
        # Pattern matching
        selection_patterns = [
            r'(?:go\s+for|choose|select|pick|want|need)\s+([1-3])',
            r'([1-3])\s+(?:please|pls)',
            r'option\s+([1-3])',
            r'number\s+([1-3])'
        ]
        
        for pattern in selection_patterns:
            match = re.search(pattern, msg_lower)
            if match:
                return match.group(1)
        
        # Keywords like "lowest", "cheapest", "highest", "premium"
        if 'lowest' in msg_lower or 'cheapest' in msg_lower or 'affordable' in msg_lower:
            return 'lowest_price'
        
        if 'highest' in msg_lower or 'premium' in msg_lower or 'best' in msg_lower or 'top' in msg_lower:
            return 'highest_price'
        
        if 'senior' in msg_lower or 'artist' in msg_lower:
            return 'senior_artist'
        
        if 'chirag' in msg_lower or 'signature' in msg_lower:
            return 'chirag_signature'
        
        return None
    
    def detect_completion_intent(self, message: str) -> bool:
        """Detect if user wants to complete/confirm"""
        msg_lower = message.lower()
        return any(keyword in msg_lower for keyword in self.completion_keywords)
    
    def detect_frustration(self, message: str) -> bool:
        """Detect user frustration"""
        msg_lower = message.lower()
        
        # Check frustration keywords
        has_frustration_keywords = any(
            keyword in msg_lower for keyword in self.frustration_keywords
        )
        
        # Check for excessive punctuation (!!!, ???)
        has_excessive_punctuation = bool(
            re.search(r'[!?]{2,}', message)
        )
        
        # Check for all caps (minimum 3 words)
        words = message.split()
        caps_words = [w for w in words if w.isupper() and len(w) > 2]
        has_all_caps = len(caps_words) >= 2
        
        return has_frustration_keywords or has_excessive_punctuation or has_all_caps
    
    def detect_exit_intent(self, message: str) -> bool:
        """Detect if user wants to exit"""
        msg_lower = message.lower()
        return any(keyword in msg_lower for keyword in self.exit_keywords)
    
    def detect_restart_intent(self, message: str) -> bool:
        """Detect if user wants to restart"""
        msg_lower = message.lower()
        return any(keyword in msg_lower for keyword in self.restart_keywords)
    
    def detect_affirmative(self, message: str) -> bool:
        """Detect affirmative response"""
        msg_lower = message.lower().strip()
        return any(keyword == msg_lower or keyword in msg_lower 
                  for keyword in self.affirmative_keywords)
    
    def detect_negative(self, message: str) -> bool:
        """Detect negative response"""
        msg_lower = message.lower().strip()
        return any(keyword == msg_lower or keyword in msg_lower 
                  for keyword in self.negative_keywords)
    
    def is_question(self, message: str) -> bool:
        """Detect if message is a question"""
        for pattern in self.question_patterns:
            if re.search(pattern, message.lower()):
                return True
        return False
    
    # ============== SCORING METHODS ==============
    
    def _score_booking_intent(self, message: str, context: Dict = None) -> float:
        """Score booking intent (0.0-1.0)"""
        score = 0.0
        
        # Strong keywords
        strong_matches = sum(1 for kw in self.booking_keywords if kw in message)
        score += min(strong_matches * 0.4, 0.8)
        
        # Numeric selection in service context
        if context and context.get('last_shown_list') == 'services':
            if re.match(r'^[1-4]$', message.strip()):
                score += 0.9
        
        # Pattern matching
        if re.search(r'i\s+(?:want|need|would\s+like)\s+to\s+book', message):
            score += 0.5
        
        return min(score, 1.0)
    
    def _score_info_intent(self, message: str) -> float:
        """Score info intent (0.0-1.0)"""
        score = 0.0
        
        # Info keywords
        info_matches = sum(1 for kw in self.info_keywords if kw in message)
        score += min(info_matches * 0.3, 0.7)
        
        # Booking keywords (negative score)
        booking_matches = sum(1 for kw in self.booking_keywords if kw in message)
        score -= booking_matches * 0.3
        
        # Question marks
        if '?' in message:
            score += 0.2
        
        return max(min(score, 1.0), 0.0)
    
    def _score_completion_intent(self, message: str) -> float:
        """Score completion intent (0.0-1.0)"""
        score = 0.0
        
        matches = sum(1 for kw in self.completion_keywords if kw in message)
        score += min(matches * 0.5, 1.0)
        
        return score
    
    def _score_exit_intent(self, message: str) -> float:
        """Score exit intent (0.0-1.0)"""
        score = 0.0
        
        matches = sum(1 for kw in self.exit_keywords if kw in message)
        score += min(matches * 0.6, 1.0)
        
        return score
    
    def _score_restart_intent(self, message: str) -> float:
        """Score restart intent (0.0-1.0)"""
        score = 0.0
        
        matches = sum(1 for kw in self.restart_keywords if kw in message)
        score += min(matches * 0.6, 1.0)
        
        return score
    
    def _score_question_intent(self, message: str) -> float:
        """Score question intent (0.0-1.0)"""
        score = 0.0
        
        for pattern in self.question_patterns:
            if re.search(pattern, message):
                score += 0.4
        
        return min(score, 1.0)
    
    def _score_affirmative(self, message: str) -> float:
        """Score affirmative response (0.0-1.0)"""
        msg = message.strip()
        
        if msg in self.affirmative_keywords:
            return 1.0
        
        matches = sum(1 for kw in self.affirmative_keywords if kw in message)
        return min(matches * 0.5, 1.0)
    
    def _score_negative(self, message: str) -> float:
        """Score negative response (0.0-1.0)"""
        msg = message.strip()
        
        if msg in self.negative_keywords:
            return 1.0
        
        matches = sum(1 for kw in self.negative_keywords if kw in message)
        return min(matches * 0.5, 1.0)
    
    # ============== HELPER METHODS ==============
    
    def _get_last_assistant_message(self, history: List) -> Optional[str]:
        """Get last assistant message from history"""
        for msg in reversed(history):
            if isinstance(msg, dict) and msg.get('role') == 'assistant':
                return msg.get('content', '').lower()
        return None
    
    def _has_service_list_context(self, message: str) -> bool:
        """Check if message contains service list"""
        indicators = ['1.', '2.', '3.', '4.', 'bridal', 'party', 'henna', 'service']
        return any(ind in message for ind in indicators)



state_manger.py:
"""
State Manager - Handles state transitions and validations
"""

from typing import Dict, List, Optional, Set
from enum import Enum
import logging

from ..models.state import BookingState

logger = logging.getLogger(__name__)


class StateManager:
    """Manages FSM state transitions with validation"""
    
    def __init__(self):
        """Initialize state manager with transition rules"""
        
        # Define valid state transitions (FSM graph)
        self.transitions: Dict[BookingState, Set[BookingState]] = {
            BookingState.GREETING: {
                BookingState.INFO_MODE,
                BookingState.SELECTING_SERVICE,
                BookingState.GREETING  # Can stay in greeting
            },
            
            BookingState.INFO_MODE: {
                BookingState.SELECTING_SERVICE,
                BookingState.GREETING,
                BookingState.INFO_MODE  # Can stay for multiple queries
            },
            
            BookingState.SELECTING_SERVICE: {
                BookingState.SELECTING_PACKAGE,
                BookingState.INFO_MODE,  # Can ask questions
                BookingState.GREETING,  # Can restart
                BookingState.SELECTING_SERVICE  # Can retry
            },
            
            BookingState.SELECTING_PACKAGE: {
                BookingState.COLLECTING_DETAILS,
                BookingState.SELECTING_SERVICE,  # Can go back
                BookingState.INFO_MODE,  # Can ask questions
                BookingState.GREETING,  # Can restart
                BookingState.SELECTING_PACKAGE  # Can retry
            },
            
            BookingState.COLLECTING_DETAILS: {
                BookingState.CONFIRMING,
                BookingState.COLLECTING_DETAILS,  # Stay for more details
                BookingState.SELECTING_SERVICE,  # Can go back
                BookingState.GREETING  # Can restart
            },
            
            BookingState.CONFIRMING: {
                BookingState.OTP_SENT,
                BookingState.COLLECTING_DETAILS,  # Go back to edit
                BookingState.GREETING  # Can cancel
            },
            
            BookingState.OTP_SENT: {
                BookingState.COMPLETED,
                BookingState.OTP_SENT,  # Retry OTP
                BookingState.GREETING  # Can cancel
            },
            
            BookingState.COMPLETED: {
                BookingState.GREETING  # Start new booking
            }
        }
        
        # States that represent active booking flow
        self.booking_flow_states = {
            BookingState.SELECTING_SERVICE,
            BookingState.SELECTING_PACKAGE,
            BookingState.COLLECTING_DETAILS,
            BookingState.CONFIRMING,
            BookingState.OTP_SENT
        }
        
        # States that allow information queries
        self.info_allowed_states = {
            BookingState.GREETING,
            BookingState.INFO_MODE,
            BookingState.SELECTING_SERVICE,
            BookingState.SELECTING_PACKAGE
        }
        
        # Terminal states (end states)
        self.terminal_states = {
            BookingState.COMPLETED
        }
    
    def get_valid_transitions(self, current_state: BookingState) -> List[BookingState]:
        """
        Get list of valid next states from current state
        
        Args:
            current_state: Current FSM state
            
        Returns:
            List of valid next states
        """
        if current_state not in self.transitions:
            logger.warning(f"Unknown state: {current_state}")
            return [BookingState.GREETING]
        
        return list(self.transitions[current_state])
    
    def can_transition(self, from_state: BookingState, to_state: BookingState) -> bool:
        """
        Check if transition from one state to another is valid
        
        Args:
            from_state: Current state
            to_state: Desired next state
            
        Returns:
            True if transition is valid, False otherwise
        """
        if from_state not in self.transitions:
            logger.warning(f"Invalid from_state: {from_state}")
            return False
        
        valid_transitions = self.transitions[from_state]
        is_valid = to_state in valid_transitions
        
        if not is_valid:
            logger.warning(
                f"Invalid transition: {from_state.value} -> {to_state.value}. "
                f"Valid: {[s.value for s in valid_transitions]}"
            )
        
        return is_valid
    
    def get_default_state(self) -> BookingState:
        """
        Get default starting state
        
        Returns:
            Default state (GREETING)
        """
        return BookingState.GREETING
    
    def get_completion_state(self) -> BookingState:
        """
        Get final completion state
        
        Returns:
            Completion state (COMPLETED)
        """
        return BookingState.COMPLETED
    
    def is_booking_active(self, state: BookingState) -> bool:
        """
        Check if state represents active booking flow
        
        Args:
            state: Current state
            
        Returns:
            True if in active booking, False otherwise
        """
        return state in self.booking_flow_states
    
    def is_terminal_state(self, state: BookingState) -> bool:
        """
        Check if state is terminal (end state)
        
        Args:
            state: State to check
            
        Returns:
            True if terminal state, False otherwise
        """
        return state in self.terminal_states
    
    def can_handle_info_query(self, state: BookingState) -> bool:
        """
        Check if info queries are allowed in current state
        
        Args:
            state: Current state
            
        Returns:
            True if info queries allowed, False otherwise
        """
        return state in self.info_allowed_states
    
    def get_next_required_state(self, current_state: BookingState, intent_complete: bool = False) -> Optional[BookingState]:
        """
        Get next required state in linear booking flow
        
        Args:
            current_state: Current state
            intent_complete: Whether booking intent is complete
            
        Returns:
            Next required state or None
        """
        flow_sequence = [
            BookingState.GREETING,
            BookingState.SELECTING_SERVICE,
            BookingState.SELECTING_PACKAGE,
            BookingState.COLLECTING_DETAILS,
            BookingState.CONFIRMING,
            BookingState.OTP_SENT,
            BookingState.COMPLETED
        ]
        
        try:
            current_idx = flow_sequence.index(current_state)
            if current_idx < len(flow_sequence) - 1:
                return flow_sequence[current_idx + 1]
        except ValueError:
            logger.warning(f"State {current_state} not in linear flow")
        
        return None
    
    def get_previous_state(self, current_state: BookingState) -> Optional[BookingState]:
        """
        Get previous state in linear booking flow (for going back)
        
        Args:
            current_state: Current state
            
        Returns:
            Previous state or None
        """
        flow_sequence = [
            BookingState.GREETING,
            BookingState.SELECTING_SERVICE,
            BookingState.SELECTING_PACKAGE,
            BookingState.COLLECTING_DETAILS,
            BookingState.CONFIRMING,
            BookingState.OTP_SENT
        ]
        
        try:
            current_idx = flow_sequence.index(current_state)
            if current_idx > 0:
                return flow_sequence[current_idx - 1]
        except ValueError:
            pass
        
        return None
    
    def validate_state_requirements(self, state: BookingState, intent) -> Dict[str, any]:
        """
        Validate if requirements for a state are met
        
        Args:
            state: State to validate
            intent: BookingIntent object
            
        Returns:
            {
                'valid': bool,
                'missing': List[str],
                'can_proceed': bool
            }
        """
        requirements = {
            BookingState.GREETING: [],
            BookingState.INFO_MODE: [],
            BookingState.SELECTING_SERVICE: [],
            BookingState.SELECTING_PACKAGE: ['service'],
            BookingState.COLLECTING_DETAILS: ['service', 'package'],
            BookingState.CONFIRMING: ['service', 'package', 'name', 'email', 'phone', 'date', 'address', 'pincode', 'service_country'],
            BookingState.OTP_SENT: ['service', 'package', 'name', 'email', 'phone', 'date', 'address', 'pincode', 'service_country'],
            BookingState.COMPLETED: []
        }
        
        required = requirements.get(state, [])
        missing = []
        
        for field in required:
            if not getattr(intent, field, None):
                missing.append(field)
        
        return {
            'valid': len(missing) == 0,
            'missing': missing,
            'can_proceed': len(missing) == 0
        }
    
    def suggest_state_recovery(self, current_state: BookingState, error: str) -> BookingState:
        """
        Suggest state to recover to after error
        
        Args:
            current_state: State where error occurred
            error: Error description
            
        Returns:
            Suggested recovery state
        """
        # For most errors, go back to greeting
        if 'critical' in error.lower() or 'fatal' in error.lower():
            return BookingState.GREETING
        
        # For validation errors, stay in current state
        if 'validation' in error.lower() or 'invalid' in error.lower():
            return current_state
        
        # For missing data, go to appropriate collection state
        if 'missing' in error.lower():
            if current_state in [BookingState.CONFIRMING, BookingState.OTP_SENT]:
                return BookingState.COLLECTING_DETAILS
        
        # Default: go back one state or greeting
        previous = self.get_previous_state(current_state)
        return previous if previous else BookingState.GREETING
    
    def get_state_description(self, state: BookingState) -> str:
        """
        Get human-readable description of state
        
        Args:
            state: State to describe
            
        Returns:
            Description string
        """
        descriptions = {
            BookingState.GREETING: "Initial greeting and intent detection",
            BookingState.INFO_MODE: "Providing information to user",
            BookingState.SELECTING_SERVICE: "User selecting service type",
            BookingState.SELECTING_PACKAGE: "User selecting package",
            BookingState.COLLECTING_DETAILS: "Collecting user details (name, email, phone, etc.)",
            BookingState.CONFIRMING: "User confirming booking details",
            BookingState.OTP_SENT: "OTP sent, waiting for verification",
            BookingState.COMPLETED: "Booking completed successfully"
        }
        
        return descriptions.get(state, f"Unknown state: {state}")
    
    def get_state_progress(self, state: BookingState) -> float:
        """
        Get booking progress percentage for current state
        
        Args:
            state: Current state
            
        Returns:
            Progress as percentage (0.0-1.0)
        """
        progress_map = {
            BookingState.GREETING: 0.0,
            BookingState.INFO_MODE: 0.0,
            BookingState.SELECTING_SERVICE: 0.2,
            BookingState.SELECTING_PACKAGE: 0.4,
            BookingState.COLLECTING_DETAILS: 0.6,
            BookingState.CONFIRMING: 0.8,
            BookingState.OTP_SENT: 0.9,
            BookingState.COMPLETED: 1.0
        }
        
        return progress_map.get(state, 0.0)
    
    def get_transition_graph(self) -> Dict[str, List[str]]:
        """
        Get state transition graph as dict for visualization
        
        Returns:
            Dict mapping state names to list of next state names
        """
        graph = {}
        for from_state, to_states in self.transitions.items():
            graph[from_state.value] = [s.value for s in to_states]
        return graph
    
    def validate_transition_path(self, path: List[BookingState]) -> bool:
        """
        Validate if a sequence of state transitions is valid
        
        Args:
            path: List of states representing a path
            
        Returns:
            True if path is valid, False otherwise
        """
        if not path or len(path) < 2:
            return True
        
        for i in range(len(path) - 1):
            if not self.can_transition(path[i], path[i + 1]):
                return False
        
        return True
__________

Below are config( you can migrate a lot here making other config files):

services_config.py:

"""
Service definitions and country configurations
"""

# Service definitions with pricing
SERVICES = {
    "Bridal Makeup Services": {
        "packages": {
            "Chirag's Signature Bridal Makeup": "‚Çπ99,999",
            "Luxury Bridal Makeup (HD / Brush)": "‚Çπ79,999",
            "Reception / Engagement / Cocktail Makeup": "‚Çπ59,999"
        },
        "description": "Premium bridal makeup by Chirag Sharma, customized for weddings"
    },
    "Party Makeup Services": {
        "packages": {
            "Party Makeup by Chirag Sharma": "‚Çπ19,999",
            "Party Makeup by Senior Artist": "‚Çπ6,999"
        },
        "description": "Makeup for parties, receptions, and special occasions"
    },
    "Engagement & Pre-Wedding Makeup": {
        "packages": {
            "Engagement Makeup by Chirag": "‚Çπ59,999",
            "Pre-Wedding Makeup by Senior Artist": "‚Çπ19,999"
        },
        "description": "Makeup for engagement and pre-wedding functions"
    },
    "Henna (Mehendi) Services": {
        "packages": {
            "Henna by Chirag Sharma": "‚Çπ49,999",
            "Henna by Senior Artist": "‚Çπ19,999"
        },
        "description": "Henna services for bridal and special occasions"
    }
}

# Country configurations
COUNTRIES = ["India", "Nepal", "Pakistan", "Bangladesh", "Dubai"]
COUNTRY_CODES = {
    "India": "+91",
    "Nepal": "+977", 
    "Pakistan": "+92",
    "Bangladesh": "+880",
    "Dubai": "+971"
}
COUNTRY_PINCODE_LENGTHS = {
    "India": 6,
    "Nepal": 5,
    "Pakistan": 5,
    "Bangladesh": 4,
    "Dubai": 5
}

settings.py:

"""
Agent and LLM configuration settings
"""

# Language support
SUPPORTED_LANGUAGES = ["en", "ne", "hi", "mr"]
LANGUAGE_NAMES = {
    "en": "English",
    "ne": "Nepali",
    "hi": "Hindi",
    "mr": "Marathi"
}

# Agent settings
AGENT_SETTINGS = {
    "max_sessions": 1000,
    "session_ttl_hours": 2,
    "max_history_messages": 15,
    "otp_expiry_minutes": 5,
    "max_otp_attempts": 3,
    "rate_limit_per_minute": 10,
    "cleanup_interval_seconds": 300
}

# LLM settings
LLM_SETTINGS = {
    "model": "llama-3.1-8b-instant",
    "temperature": 0.4,
    "max_tokens": 300,
    "timeout": 15
}


Below are from models:

intent.py:
"""
Booking Intent Model - UPDATED with metadata field
"""

import re
from datetime import datetime
from typing import Optional, List, Dict, ClassVar, Any

from pydantic import BaseModel, field_validator


class BookingIntent(BaseModel):
    """Extracted booking information from conversation"""

    service: Optional[str] = None
    package: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    phone_country: Optional[str] = None
    service_country: Optional[str] = None
    address: Optional[str] = None
    pincode: Optional[str] = None
    date: Optional[str] = None
    message: Optional[str] = None
    
    # NEW: Metadata for storing additional info like date extraction details
    metadata: Dict[str, Any] = {}

    # Required fields for booking completion (NOT model fields)
    REQUIRED_FIELDS: ClassVar[List[str]] = [
        'service',
        'package',
        'name',
        'email',
        'phone',
        'service_country',
        'date',
        'address',
        'pincode',
    ]

    # ---------------- Validators ----------------

    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if v is None:
            return v

        v = v.strip().lower()
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_regex, v):
            raise ValueError("Invalid email format")

        return v

    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v):
        if v is None:
            return v

        v = v.strip()
        clean_phone = re.sub(r'[\s\-\(\)]', '', v)

        if not clean_phone.startswith('+'):
            raise ValueError("Phone must start with country code (e.g., +91)")

        digits = re.sub(r'\D', '', clean_phone[1:])

        if not (10 <= len(digits) <= 15):
            raise ValueError("Phone number length must be between 10 and 15 digits")

        return clean_phone

    @field_validator('date')
    @classmethod
    def validate_date(cls, v):
        if v is None:
            return v

        date_formats = [
            '%Y-%m-%d',
            '%d/%m/%Y',
            '%m/%d/%Y',
            '%d-%m-%Y',
            '%d %b %Y',
            '%d %B %Y',
        ]

        for fmt in date_formats:
            try:
                parsed_date = datetime.strptime(v, fmt)
                if parsed_date.date() < datetime.now().date():
                    raise ValueError("Date cannot be in the past")
                return parsed_date.strftime('%Y-%m-%d')
            except ValueError:
                continue

        raise ValueError("Invalid date format")

    # ---------------- Business Logic ----------------

    def is_complete(self) -> bool:
        """Check if all required fields are filled and valid"""
        for field in self.REQUIRED_FIELDS:
            if getattr(self, field) is None:
                return False

        return self._is_phone_valid() and self._is_email_valid()

    def _is_phone_valid(self) -> bool:
        if not self.phone:
            return False
        try:
            self.validate_phone(self.phone)
            return True
        except ValueError:
            return False

    def _is_email_valid(self) -> bool:
        if not self.email:
            return False
        try:
            self.validate_email(self.email)
            return True
        except ValueError:
            return False

    def missing_fields(self) -> List[str]:
        """Human-readable list of missing or invalid required fields"""
        field_map = {
            'service': 'service type',
            'package': 'package choice',
            'name': 'your name',
            'email': 'email address',
            'phone': 'phone number with country code',
            'service_country': 'service country',
            'date': 'preferred date',
            'address': 'service address',
            'pincode': 'PIN/postal code',
        }

        missing = []

        for field in self.REQUIRED_FIELDS:
            value = getattr(self, field)

            if field == 'phone' and value and not self._is_phone_valid():
                missing.append(field_map[field])
            elif field == 'email' and value and not self._is_email_valid():
                missing.append(field_map[field])
            elif value is None:
                missing.append(field_map[field])

        return missing

    def get_summary(self) -> Dict[str, str]:
        """Masked summary of collected information"""
        summary = {}
        field_map = {
            'service': 'Service',
            'package': 'Package',
            'name': 'Name',
            'email': 'Email',
            'phone': 'Phone',
            'phone_country': 'Phone Country',
            'service_country': 'Country',
            'address': 'Address',
            'pincode': 'PIN Code',
            'date': 'Date',
        }

        for field, label in field_map.items():
            value = getattr(self, field)
            if not value:
                continue

            if field == 'phone':
                digits = re.sub(r'\D', '', value)
                summary[label] = f"{value[:8]}****{digits[-4:]}"
            elif field == 'email':
                name, domain = value.split('@')
                masked = name[0] + '*' * max(len(name) - 2, 1) + name[-1]
                summary[label] = f"{masked}@{domain}"
            else:
                summary[label] = value

        return summary

    def copy(self) -> "BookingIntent":
        """Create a shallow copy of the intent"""
        return BookingIntent(**self.model_dump())


memory.py:
# agent/models/memory.py
"""
Conversation Memory Model with off-track tracking
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from datetime import datetime

from .intent import BookingIntent


class ConversationMemory(BaseModel):
    """Conversation state and memory with off-track tracking"""
    
    session_id: str
    language: str = "en"
    intent: BookingIntent = Field(default_factory=BookingIntent)
    stage: str = "greeting"
    booking_id: Optional[str] = None
    otp_attempts: int = 0
    off_track_count: int = 0  # Track consecutive off-track messages
    last_updated: datetime = Field(default_factory=datetime.utcnow)
    conversation_history: List[Dict[str, Any]] = Field(default_factory=list)
    last_shown_list: Optional[str] = None
    last_asked_field: Optional[str] = None
    
    class Config:
        arbitrary_types_allowed = True
    
    def add_message(self, role: str, content: str) -> None:
        """Add message to conversation history"""
        self.conversation_history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.utcnow().isoformat()
        })
        
        # Keep only last 20 messages
        if len(self.conversation_history) > 20:
            self.conversation_history = self.conversation_history[-20:]
        
        self.last_updated = datetime.utcnow()
    
    def reset(self) -> None:
        """Reset memory for new booking"""
        self.intent = BookingIntent()
        self.stage = "greeting"
        self.booking_id = None
        self.otp_attempts = 0
        self.off_track_count = 0  # Reset off-track counter
        self.last_shown_list = None
        self.last_asked_field = None
        
        # Keep only system messages in history
        system_messages = [
            msg for msg in self.conversation_history 
            if msg.get("role") == "system"
        ]
        self.conversation_history = system_messages
        
        self.last_updated = datetime.utcnow()
    
    def get_context(self) -> str:
        """Get conversation context summary"""
        if not self.conversation_history:
            return "No conversation history."
        
        # Get last 5 messages
        recent_messages = self.conversation_history[-5:]
        
        context_lines = []
        for msg in recent_messages:
            role = msg.get("role", "unknown")
            content = msg.get("content", "")[:100]  # Truncate long messages
            context_lines.append(f"{role.upper()}: {content}")
        
        # Add current state info
        context_lines.append(f"\nCurrent Stage: {self.stage}")
        
        if self.intent.service:
            context_lines.append(f"Selected Service: {self.intent.service}")
        if self.intent.package:
            context_lines.append(f"Selected Package: {self.intent.package}")
        
        missing = self.intent.missing_fields()
        if missing:
            context_lines.append(f"Missing Fields: {', '.join(missing)}")
        
        return "\n".join(context_lines)
    
    def update_stage(self, stage: str) -> None:
        """Update stage and refresh timestamp"""
        self.stage = stage
        self.last_updated = datetime.utcnow()
    
    def increment_otp_attempts(self) -> None:
        """Increment OTP attempts"""
        self.otp_attempts += 1
        self.last_updated = datetime.utcnow()
    
    def increment_off_track_count(self) -> None:
        """Increment off-track count"""
        self.off_track_count += 1
        self.last_updated = datetime.utcnow()
    
    def reset_off_track_count(self) -> None:
        """Reset off-track count"""
        self.off_track_count = 0
        self.last_updated = datetime.utcnow()
    
    def get_recent_user_messages(self, count: int = 3) -> List[str]:
        """Get recent user messages"""
        user_messages = [
            msg["content"] for msg in self.conversation_history[-count*2:] 
            if msg.get("role") == "user"
        ]
        return user_messages[-count:] if user_messages else []
    
    def get_last_assistant_message(self) -> Optional[str]:
        """Get the last assistant message from conversation history"""
        if not self.conversation_history:
            return None
        
        # Reverse search for last assistant message
        for msg in reversed(self.conversation_history):
            if msg.get("role") == "assistant":
                return msg.get("content", "")
        return None
    
    def get_last_user_message(self) -> Optional[str]:
        """Get the last user message from conversation history"""
        if not self.conversation_history:
            return None
        
        # Reverse search for last user message
        for msg in reversed(self.conversation_history):
            if msg.get("role") == "user":
                return msg.get("content", "")
        return None
    
    def get_last_n_assistant_messages(self, n: int = 3) -> List[str]:
        """Get last n assistant messages"""
        if not self.conversation_history:
            return []
        
        assistant_messages = [
            msg.get("content", "") for msg in reversed(self.conversation_history)
            if msg.get("role") == "assistant"
        ]
        return assistant_messages[:n]
    
    def get_last_n_user_messages(self, n: int = 3) -> List[str]:
        """Get last n user messages"""
        if not self.conversation_history:
            return []
        
        user_messages = [
            msg.get("content", "") for msg in reversed(self.conversation_history)
            if msg.get("role") == "user"
        ]
        return user_messages[:n]
    
    def has_recent_service_listing(self) -> bool:
        """Check if we recently showed service listing"""
        last_assistant_msg = self.get_last_assistant_message()
        if not last_assistant_msg:
            return False
        
        # Check if the last assistant message contains service listing keywords
        keywords = ['services', 'service', 'available services', 'bridal', 'party', 'engagement', 'henna']
        return any(keyword.lower() in last_assistant_msg.lower() for keyword in keywords)
    
    def is_in_chat_mode(self) -> bool:
        """Check if we're in chat mode"""
        return self.stage == "chat_mode"
    
    def get_conversation_summary(self, max_messages: int = 10) -> str:
        """Get summary of conversation for context"""
        if not self.conversation_history:
            return "No conversation yet."
        
        # Get the most recent messages up to max_messages
        recent = self.conversation_history[-max_messages:]
        
        summary_lines = []
        for msg in recent:
            role = msg.get("role", "unknown")
            content = msg.get("content", "")
            # Truncate very long messages
            if len(content) > 100:
                content = content[:100] + "..."
            summary_lines.append(f"{role}: {content}")
        
        # Add current state
        summary_lines.append(f"\nCurrent stage: {self.stage}")
        summary_lines.append(f"Service: {self.intent.service or 'Not selected'}")
        summary_lines.append(f"Package: {self.intent.package or 'Not selected'}")
        summary_lines.append(f"Off-track count: {self.off_track_count}")
        
        return "\n".join(summary_lines)
    
    def get_messages_by_role(self, role: str, max_count: int = 5) -> List[str]:
        """Get messages by specific role"""
        messages = [
            msg.get("content", "") for msg in self.conversation_history
            if msg.get("role") == role
        ]
        return messages[-max_count:] if messages else []


state.py:
"""
Booking States Enum
"""

from enum import Enum


class BookingState(Enum):
    """FSM States for booking flow"""
    
    GREETING = "greeting"
    INFO_MODE = "info_mode"
    SELECTING_SERVICE = "selecting_service"
    SELECTING_PACKAGE = "selecting_package"
    COLLECTING_DETAILS = "collecting_details"
    CONFIRMING = "confirming"
    OTP_SENT = "otp_sent"
    COMPLETED = "completed"
    
    @classmethod
    def from_string(cls, state_str: str) -> 'BookingState':
        """Convert string to BookingState enum"""
        state_map = {state.value: state for state in cls}
        return state_map.get(state_str, cls.GREETING)
    
    def is_booking_flow(self) -> bool:
        """Check if state is part of booking flow"""
        booking_states = [
            self.SELECTING_SERVICE,
            self.SELECTING_PACKAGE,
            self.COLLECTING_DETAILS,
            self.CONFIRMING,
            self.OTP_SENT,
            self.COMPLETED
        ]
        return self in booking_states
    
    def get_next_expected(self) -> str:
        """Get what's expected next in this state"""
        expectations = {
            self.GREETING: "greeting or booking intent",
            self.INFO_MODE: "information query",
            self.SELECTING_SERVICE: "service selection",
            self.SELECTING_PACKAGE: "package selection",
            self.COLLECTING_DETAILS: "personal details",
            self.CONFIRMING: "confirmation (yes/no)",
            self.OTP_SENT: "OTP verification",
            self.COMPLETED: "booking completion"
        }
        return expectations.get(self, "unknown")

_____________________
Below are Prompts content ( you can migrate many here )

builder.py: still unimplemented:

"""
Prompt Builder - Builds prompts dynamically
"""

from typing import Dict, List
from .templates import PromptTemplates


class PromptBuilder:
    """Build prompts dynamically based on context"""
    
    def __init__(self):
        """Initialize prompt builder"""
        pass
    
    def build_state_prompt(self, state: str, memory, language: str) -> str:
        """Build prompt for current state"""
        pass
    
    def build_missing_fields_prompt(self, missing_fields: List[str], collected: Dict, language: str) -> str:
        """Build prompt for missing fields"""
        pass
    
    def build_extracted_fields_ack(self, extracted_fields: Dict, language: str) -> str:
        """Build acknowledgment for extracted fields"""
        pass
    
    def build_next_expected_prompt(self, state: str, intent, language: str) -> str:
        """Build prompt for next expected action"""
        pass


system_prompt.py: unimplemented

"""
System Prompts for LLM
"""

from typing import Dict


class SystemPrompts:
    """System prompts for different contexts"""
    
    def get_agent_system_prompt(self, language: str, memory_state: Dict) -> str:
        """Get main agent system prompt"""
        pass
    
    def get_booking_system_prompt(self, language: str, context: Dict) -> str:
        """Get booking mode system prompt"""
        pass
    
    def get_info_system_prompt(self, language: str) -> str:
        """Get info mode system prompt"""
        pass
    
    def get_base_system_prompt(self, language: str) -> str:
        """Get base system prompt"""
        pass



templates.py:

"""
Prompt Templates - All language templates
"""

from typing import Dict, List


class PromptTemplates:
    """All prompt templates for different languages"""
    
    def __init__(self):
        """Initialize templates"""
        # Service definitions (from config)
        self.services = {
            "Bridal Makeup Services": {
                "description_en": "Premium bridal makeup by Chirag Sharma",
                "description_hi": "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™",
                "description_ne": "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™"
            },
            "Party Makeup Services": {
                "description_en": "Makeup for parties and special occasions",
                "description_hi": "‡§™‡§æ‡§∞‡•ç‡§ü‡§ø‡§Ø‡•ã‡§Ç ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™",
                "description_ne": "‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™"
            },
            "Engagement & Pre-Wedding Makeup": {
                "description_en": "Makeup for engagement functions",
                "description_hi": "‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™",
                "description_ne": "‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü ‡§∏‡§Æ‡§æ‡§∞‡•ã‡§π‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™"
            },
            "Henna (Mehendi) Services": {
                "description_en": "Henna services for bridal and special occasions",
                "description_hi": "‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç",
                "description_ne": "‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç"
            }
        }
    
    def get_welcome_message(self, language: str, is_booking: bool = False) -> str:
        """Get welcome message"""
        if is_booking:
            if language == "hi":
                return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç JinniChirag ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§™ ‡§ï‡§ø‡§∏ ‡§∏‡•á‡§µ‡§æ ‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?"
            elif language == "ne":
                return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ JinniChirag ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Å‡§Å‡•§ ‡§§‡§™‡§æ‡§à‡§Ç ‡§ï‡•Å‡§® ‡§∏‡•á‡§µ‡§æ ‡§¨‡•Å‡§ï ‡§ó‡§∞‡•ç‡§® ‡§ö‡§æ‡§π‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ?"
            else:
                return "Hello! I'm JinniChirag assistant. Which service would you like to book?"
        else:
            if language == "hi":
                return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç JinniChirag ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?"
            elif language == "ne":
                return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ JinniChirag ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Å‡§Å‡•§ ‡§Ü‡§ú ‡§Æ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§ï‡§∏‡§∞‡•Ä ‡§Æ‡§¶‡•ç‡§¶‡§§ ‡§ó‡§∞‡•ç‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å?"
            else:
                return "Hello! I'm JinniChirag assistant. How can I help you today?"
    
    def get_service_list(self, language: str) -> str:
        """Get service list"""
        if language == "hi":
            prompt = "üéØ **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç:**\n\n"
            for i, (service, info) in enumerate(self.services.items(), 1):
                description = info.get(f"description_{language}", info["description_en"])
                prompt += f"{i}. **{service}**\n   {description}\n\n"
            prompt += "**‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ (1-4) ‡§ö‡•Å‡§®‡•á‡§Ç ‡§Ø‡§æ ‡§∏‡•á‡§µ‡§æ ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§**"
            return prompt
        elif language == "ne":
            prompt = "üéØ **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç:**\n\n"
            for i, (service, info) in enumerate(self.services.items(), 1):
                description = info.get(f"description_{language}", info["description_en"])
                prompt += f"{i}. **{service}**\n   {description}\n\n"
            prompt += "**‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Æ‡•ç‡§¨‡§∞ (1-4) ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§∏‡•á‡§µ‡§æ‡§ï‡•ã ‡§®‡§æ‡§Æ ‡§≤‡•á‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§**"
            return prompt
        else:
            prompt = "üéØ **Available Services:**\n\n"
            for i, (service, info) in enumerate(self.services.items(), 1):
                description = info["description_en"]
                prompt += f"{i}. **{service}**\n   {description}\n\n"
            prompt += "**Please choose a number (1-4) or type the service name.**"
            return prompt
    
    def get_service_details(self, language: str) -> str:
        """Get detailed service list with pricing"""
        if language == "hi":
            return """üéØ **‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç ‡§î‡§∞ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç:**

1. **‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§ï‡§æ ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ99,999
   ‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD / ‡§¨‡•ç‡§∞‡§∂): ‚Çπ79,999
   ‚Ä¢ ‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§® / ‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü / ‡§ï‡•â‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ59,999

2. **‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§™‡§æ‡§∞‡•ç‡§ü‡§ø‡§Ø‡•ã‡§Ç ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ19,999
   ‚Ä¢ ‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ9,999

3. **‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§î‡§∞ ‡§™‡•ç‡§∞‡•Ä-‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™** - ‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§™‡•à‡§ï‡•á‡§ú: ‚Çπ49,999
   ‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§™‡•à‡§ï‡•á‡§ú: ‚Çπ29,999
   ‚Ä¢ ‡§¨‡•á‡§∏‡§ø‡§ï ‡§™‡•à‡§ï‡•á‡§ú: ‚Çπ14,999

4. **‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç** - ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§î‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä: ‚Çπ49,999
   ‚Ä¢ ‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä: ‚Çπ19,999

‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§®‡§Æ‡•á‡§Ç ‡§∏‡•á ‡§ï‡§ø‡§∏‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á? ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ (1-4) ‡§ö‡•Å‡§®‡•á‡§Ç ‡§Ø‡§æ ‡§∏‡•á‡§µ‡§æ ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§"""
        elif language == "ne":
            return """üéØ **‡§π‡§æ‡§Æ‡•ç‡§∞‡•ã ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç ‡§∞ ‡§Æ‡•Å‡§≤‡•ç‡§Ø‡§π‡§∞‡•Ç:**

1. **‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó‡§ï‡•ã ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ99,999
   ‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD / ‡§¨‡•ç‡§∞‡§∂): ‚Çπ79,999
   ‚Ä¢ ‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§® / ‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü / ‡§ï‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ59,999

2. **‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ19,999
   ‚Ä¢ ‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ9,999

3. **‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü ‡§∞ ‡§™‡•ç‡§∞‡•Ä-‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§ï‡§Ö‡§™** - ‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü ‡§∏‡§Æ‡§æ‡§∞‡•ã‡§π‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡•á‡§ï‡§Ö‡§™
   ‚Ä¢ ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú: ‚Çπ49,999
   ‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú: ‚Çπ29,999
   ‚Ä¢ ‡§¨‡•á‡§∏‡§ø‡§ï ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú: ‚Çπ14,999

4. **‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç** - ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§∞ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ö‡§µ‡§∏‡§∞‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§π‡•á‡§®‡•ç‡§®‡§æ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç
   ‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§π‡•á‡§®‡•ç‡§®‡§æ: ‚Çπ49,999
   ‚Ä¢ ‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§π‡•á‡§®‡•ç‡§®‡§æ: ‚Çπ19,999

‡§ï‡•á ‡§§‡§™‡§æ‡§à‡§Ç ‡§Ø‡•Ä ‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§ï‡•Å‡§®‡•à ‡§∏‡•á‡§µ‡§æ ‡§¨‡•Å‡§ï ‡§ó‡§∞‡•ç‡§® ‡§ö‡§æ‡§π‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ? ‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Æ‡•ç‡§¨‡§∞ (1-4) ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§∏‡•á‡§µ‡§æ‡§ï‡•ã ‡§®‡§æ‡§Æ ‡§≤‡•á‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§"""
        else:
            return """üéØ **Our Services and Pricing:**

1. **Bridal Makeup Services** - Premium bridal makeup by Chirag Sharma
   ‚Ä¢ Chirag's Signature Bridal Makeup: ‚Çπ99,999
   ‚Ä¢ Luxury Bridal Makeup (HD / Brush): ‚Çπ79,999
   ‚Ä¢ Reception / Engagement / Cocktail Makeup: ‚Çπ59,999

2. **Party Makeup Services** - Makeup for parties and special occasions
   ‚Ä¢ Party Makeup by Chirag Sharma: ‚Çπ19,999
   ‚Ä¢ Party Makeup by Senior Artist: ‚Çπ9,999

3. **Engagement & Pre-Wedding Makeup** - Makeup for engagement functions
   ‚Ä¢ Signature Package: ‚Çπ49,999
   ‚Ä¢ Luxury Package: ‚Çπ29,999
   ‚Ä¢ Basic Package: ‚Çπ14,999

4. **Henna (Mehendi) Services** - Henna services for bridal and special occasions
   ‚Ä¢ Henna by Chirag Sharma: ‚Çπ49,999
   ‚Ä¢ Henna by Senior Artist: ‚Çπ19,999

Would you like to book any of these services? Please choose a number (1-4) or type the service name."""
    
    def get_package_options(self, service: str, language: str) -> str:
        """Get package options for service with proper formatting"""
        packages = {
            "Bridal Makeup Services": {
                "en": [
                    "Chirag's Signature Bridal Makeup - ‚Çπ99,999",
                    "Luxury Bridal Makeup (HD / Brush) - ‚Çπ79,999",
                    "Reception / Engagement / Cocktail Makeup - ‚Çπ59,999"
                ],
                "hi": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§ï‡§æ ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ99,999",
                    "‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD / ‡§¨‡•ç‡§∞‡§∂) - ‚Çπ79,999",
                    "‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§® / ‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü / ‡§ï‡•â‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ59,999"
                ],
                "ne": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó‡§ï‡•ã ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ99,999",
                    "‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD / ‡§¨‡•ç‡§∞‡§∂) - ‚Çπ79,999",
                    "‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§® / ‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü / ‡§ï‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ59,999"
                ]
            },
            "Party Makeup Services": {
                "en": [
                    "Party Makeup by Chirag Sharma - ‚Çπ19,999",
                    "Party Makeup by Senior Artist - ‚Çπ9,999"
                ],
                "hi": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ19,999",
                    "‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ9,999"
                ],
                "ne": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ19,999",
                    "‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™ - ‚Çπ9,999"
                ]
            },
            "Engagement & Pre-Wedding Makeup": {
                "en": [
                    "Signature Package - ‚Çπ49,999",
                    "Luxury Package - ‚Çπ29,999",
                    "Basic Package - ‚Çπ14,999"
                ],
                "hi": [
                    "‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§™‡•à‡§ï‡•á‡§ú - ‚Çπ49,999",
                    "‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§™‡•à‡§ï‡•á‡§ú - ‚Çπ29,999",
                    "‡§¨‡•á‡§∏‡§ø‡§ï ‡§™‡•à‡§ï‡•á‡§ú - ‚Çπ14,999"
                ],
                "ne": [
                    "‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú - ‚Çπ49,999",
                    "‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú - ‚Çπ29,999",
                    "‡§¨‡•á‡§∏‡§ø‡§ï ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú - ‚Çπ14,999"
                ]
            },
            "Henna (Mehendi) Services": {
                "en": [
                    "Henna by Chirag Sharma - ‚Çπ49,999",
                    "Henna by Senior Artist - ‚Çπ19,999"
                ],
                "hi": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä - ‚Çπ49,999",
                    "‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä - ‚Çπ19,999"
                ],
                "ne": [
                    "‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§π‡•á‡§®‡•ç‡§®‡§æ - ‚Çπ49,999",
                    "‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§π‡•á‡§®‡•ç‡§®‡§æ - ‚Çπ19,999"
                ]
            }
        }
        
        service_packages = packages.get(service, packages["Bridal Makeup Services"])
        lang_packages = service_packages.get(language, service_packages["en"])
        
        if language == "hi":
            prompt = f"üì¶ **{service} ‡§ï‡•á ‡§™‡•à‡§ï‡•á‡§ú:**\n\n"
            for i, pkg in enumerate(lang_packages, 1):
                prompt += f"{i}. {pkg}\n"
            prompt += "\n**‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ ‡§ö‡•Å‡§®‡•á‡§Ç ‡§Ø‡§æ ‡§™‡•à‡§ï‡•á‡§ú ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§**"
        elif language == "ne":
            prompt = f"üì¶ **{service} ‡§ï‡•ã ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú‡§π‡§∞‡•Ç:**\n\n"
            for i, pkg in enumerate(lang_packages, 1):
                prompt += f"{i}. {pkg}\n"
            prompt += "\n**‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Æ‡•ç‡§¨‡§∞ ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú‡§ï‡•ã ‡§®‡§æ‡§Æ ‡§≤‡•á‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§**"
        else:
            prompt = f"üì¶ **Packages for {service}:**\n\n"
            for i, pkg in enumerate(lang_packages, 1):
                prompt += f"{i}. {pkg}\n"
            prompt += "\n**Please choose a number or type the package name.**"
        
        return prompt
    
    def get_details_prompt(self, language: str) -> str:
        """Get details collection prompt"""
        if language == "hi":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á‡§Ç:**

‡§Ü‡§™ ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§Ø‡§æ ‡§è‡§ï-‡§è‡§ï ‡§ï‡§∞‡§ï‡•á:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§ú‡•à‡§∏‡•á +919876543210):
‚Ä¢ **‡§à‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ** (‡§ú‡•à‡§∏‡•á 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +919876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä, 110001, ‡§≠‡§æ‡§∞‡§§"

‡§Ü‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?"""
        elif language == "ne":
            return """üìã **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

‡§§‡§™‡§æ‡§à‡§Ç ‡§è‡§ï‡•à ‡§™‡§ü‡§ï ‡§∏‡§¨‡•à ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡§ø‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ ‡§µ‡§æ ‡§è‡§ï-‡§è‡§ï ‡§ó‡§∞‡•á‡§∞:

‚Ä¢ **‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ:**
‚Ä¢ **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞** (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§, ‡§ú‡§∏‡•ç‡§§‡•à +9779876543210):
‚Ä¢ **‡§á‡§Æ‡•á‡§≤:**
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø** (‡§ú‡§∏‡•ç‡§§‡•à 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025):
‚Ä¢ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®:**
‚Ä¢ **‡§™‡§ø‡§® ‡§ï‡•ã‡§°:**
‚Ä¢ **‡§¶‡•á‡§∂** (‡§≠‡§æ‡§∞‡§§/‡§®‡•á‡§™‡§æ‡§≤/‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®/‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂/‡§¶‡•Å‡§¨‡§à):

**‡§â‡§¶‡§æ‡§π‡§∞‡§£:** "‡§∞‡§Æ‡•á‡§∂ ‡§ï‡•Å‡§Æ‡§æ‡§∞, +9779876543210, ramesh@email.com, 15 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2025, ‡§ï‡§æ‡§†‡§Æ‡§æ‡§°‡•å‡§Ç, 44600, ‡§®‡•á‡§™‡§æ‡§≤"

‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•á ‡§π‡•ã?"""
        else:
            return """üìã **Please provide your details:**

You can provide all details at once or one by one:

‚Ä¢ **Full Name:**
‚Ä¢ **WhatsApp Number** (with country code, e.g., +919876543210):
‚Ä¢ **Email:**
‚Ä¢ **Event Date** (e.g., March 25, 2025):
‚Ä¢ **Event Location:**
‚Ä¢ **PIN Code:**
‚Ä¢ **Country** (India/Nepal/Pakistan/Bangladesh/Dubai):

**Example:** "Ramesh Kumar, +919876543210, ramesh@email.com, April 15, 2025, Delhi, 110001, India"

What is your full name?"""
    
    def get_phone_prompt(self, language: str) -> str:
        """Get phone number prompt"""
        if language == "hi":
            return """üì± **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞ (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§•)**

‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§∞‡•á‡§Ç:
‚Ä¢ +91-9876543210 (‡§≠‡§æ‡§∞‡§§)
‚Ä¢ +977-9851234567 (‡§®‡•á‡§™‡§æ‡§≤)
‚Ä¢ +92-3001234567 (‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®)
‚Ä¢ +880-1712345678 (‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂)
‚Ä¢ +971-501234567 (‡§¶‡•Å‡§¨‡§à)

OTP ‡§á‡§∏‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§™‡§∞ ‡§≠‡•á‡§ú‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ‡•§"""
        elif language == "ne":
            return """üì± **‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞ (‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§)**

‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞ ‡§∏‡§æ‡§ù‡§æ ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:
‚Ä¢ +91-9876543210 (‡§≠‡§æ‡§∞‡§§)
‚Ä¢ +977-9851234567 (‡§®‡•á‡§™‡§æ‡§≤)
‚Ä¢ +92-3001234567 (‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®)
‚Ä¢ +880-1712345678 (‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂)
‚Ä¢ +971-501234567 (‡§¶‡•Å‡§¨‡§à)

OTP ‡§Ø‡§π‡•Ä ‡§®‡§Æ‡•ç‡§¨‡§∞‡§Æ‡§æ ‡§™‡§†‡§æ‡§á‡§®‡•á‡§õ‡•§"""
        else:
            return """üì± **WhatsApp Number (with Country Code)**

Please share your WhatsApp number with country code:
‚Ä¢ +91-9876543210 (India)
‚Ä¢ +977-9851234567 (Nepal)
‚Ä¢ +92-3001234567 (Pakistan)
‚Ä¢ +880-1712345678 (Bangladesh)
‚Ä¢ +971-501234567 (Dubai)

OTP will be sent to this number."""
    
    def get_otp_sent_message(self, language: str, phone: str) -> str:
        """Get OTP sent message"""
        # Mask phone for display
        if phone and len(phone) > 8:
            masked = f"{phone[:8]}****{phone[-4:] if len(phone) > 12 else '****'}"
        else:
            masked = phone
        
        if language == "hi":
            return f"""‚úÖ **OTP ‡§≠‡•á‡§ú ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à!**

üì≤ OTP {masked} ‡§™‡§∞ ‡§≠‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§

üî¢ **‡§ï‡•É‡§™‡§Ø‡§æ 6 ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§ï‡§æ OTP ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç:**

(OTP 5 ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡•à‡§ß ‡§π‡•à)"""
        elif language == "ne":
            return f"""‚úÖ **OTP ‡§™‡§†‡§æ‡§á‡§è‡§ï‡•ã ‡§õ!**

üì≤ OTP {masked} ‡§Æ‡§æ ‡§™‡§†‡§æ‡§á‡§è‡§ï‡•ã ‡§õ‡•§

üî¢ **‡§ï‡•É‡§™‡§Ø‡§æ ‡•¨ ‡§Ö‡§Ç‡§ï‡§ï‡•ã OTP ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

(OTP ‡•´ ‡§Æ‡§ø‡§®‡•á‡§ü‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§õ)"""
        else:
            return f"""‚úÖ **OTP Sent!**

üì≤ OTP has been sent to {masked}.

üî¢ **Please enter the 6-digit OTP:**

(OTP valid for 5 minutes)"""
    
    def get_booking_confirmed_message(self, language: str, name: str) -> str:
        """Get booking confirmation message"""
        if language == "hi":
            return f"""üéâ **‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∏‡§´‡§≤!**

‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶ {name} ‡§ú‡•Ä!

‚úÖ **‡§Ü‡§™‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∞‡§ø‡§ï‡•ç‡§µ‡•á‡§∏‡•ç‡§ü ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§ï‡•ã ‡§™‡§æ‡§∏ ‡§≠‡•á‡§ú ‡§¶‡•Ä ‡§ó‡§à ‡§π‡•à‡•§**

üìã **‡§Ü‡§ó‡•á ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ:**
1. ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§Ü‡§™‡§ï‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ï‡•Ä ‡§∏‡§Æ‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á
2. ‡§Ü‡§™‡§ï‡•ã 24 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§≠‡•Ä‡§§‡§∞ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§™‡§∞ ‡§ï‡•â‡§®‡•ç‡§´‡§∞‡•ç‡§Æ‡•á‡§∂‡§® ‡§Æ‡§ø‡§≤‡•á‡§ó‡§æ
3. ‡§≠‡•Å‡§ó‡§§‡§æ‡§® ‡§î‡§∞ ‡§Ö‡§®‡•ç‡§Ø ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§ø‡§è ‡§ú‡§æ‡§è‡§Ç‡§ó‡•á

üôè **JinniChirag ‡§ö‡•Å‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!** üíÑ‚ú®"""
        elif language == "ne":
            return f"""üéâ **‡§¨‡•Å‡§ï‡§ø‡§ô ‡§∏‡§´‡§≤!**

‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶ {name}!

‚úÖ **‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§Ö‡§®‡•Å‡§∞‡•ã‡§ß ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§™‡§†‡§æ‡§á‡§è‡§ï‡•ã ‡§õ‡•§**

üìã **‡§Ö‡§ó‡§æ‡§°‡§ø‡§ï‡•ã ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ:**
1. ‡§ö‡§ø‡§∞‡§æ‡§ó‡§≤‡•á ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô‡§ï‡•ã ‡§∏‡§Æ‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ó‡§∞‡•ç‡§®‡•á‡§õ‡§®‡•ç
2. ‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡§æ‡§à ‡•®‡•™ ‡§ò‡§£‡•ç‡§ü‡§æ‡§≠‡§ø‡§§‡•ç‡§∞ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™‡§Æ‡§æ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø‡§ï‡§∞‡§£ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§®‡•á‡§õ
3. ‡§≠‡•Å‡§ï‡•ç‡§§‡§æ‡§® ‡§∞ ‡§Ö‡§®‡•ç‡§Ø ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§∏‡§æ‡§ù‡§æ ‡§ó‡§∞‡§ø‡§®‡•á‡§õ

üôè **JinniChirag ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§≠‡§è‡§ï‡•ã‡§Æ‡§æ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!** üíÑ‚ú®"""
        else:
            return f"""üéâ **Booking Successful!**

Thank you {name}!

‚úÖ **Your booking request has been sent to Chirag Sharma.**

üìã **Next Steps:**
1. Chirag will review your booking
2. You'll receive confirmation via WhatsApp within 24 hours
3. Payment and other details will be shared

üôè **Thank you for choosing JinniChirag!** üíÑ‚ú®"""
    
    def get_bulk_request_message(self, missing_fields: List[str], language: str) -> str:
        """Get bulk information request message"""
        if not missing_fields:
            return ""
        
        # Field mapping
        field_map = {
            "name": "Full Name" if language == "en" else "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ" if language == "hi" else "‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ",
            "phone": "WhatsApp Number" if language == "en" else "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞" if language == "hi" else "‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞",
            "email": "Email" if language == "en" else "‡§à‡§Æ‡•á‡§≤" if language == "hi" else "‡§á‡§Æ‡•á‡§≤",
            "event_date": "Event Date" if language == "en" else "‡§á‡§µ‡•á‡§Ç‡§ü ‡§§‡§æ‡§∞‡•Ä‡§ñ" if language == "hi" else "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡§ø‡§§‡§ø",
            "location": "Event Location" if language == "en" else "‡§á‡§µ‡•á‡§Ç‡§ü ‡§∏‡•ç‡§•‡§æ‡§®" if language == "hi" else "‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§∏‡•ç‡§•‡§æ‡§®",
            "pincode": "PIN Code" if language == "en" else "‡§™‡§ø‡§® ‡§ï‡•ã‡§°" if language == "hi" else "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
            "service_country": "Country" if language == "en" else "‡§¶‡•á‡§∂" if language == "hi" else "‡§¶‡•á‡§∂"
        }
        
        fields_text = "\n".join([f"‚Ä¢ {field_map.get(field, field)}" for field in missing_fields[:3]])
        
        if language == "hi":
            return f"""üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç:**

{fields_text}

**‡§ü‡§ø‡§™:** ‡§Ü‡§™ ‡§∏‡§≠‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§è‡§ï ‡§∏‡§æ‡§• ‡§¶‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§"""
        elif language == "ne":
            return f"""üìù **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡§≤‡§ï‡•ã ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

{fields_text}

**‡§∏‡•Å‡§ù‡§æ‡§µ:** ‡§§‡§™‡§æ‡§à‡§Ç ‡§∏‡§¨‡•à ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§è‡§ï‡•à ‡§™‡§ü‡§ï ‡§¶‡§ø‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ‡•§"""
        else:
            return f"""üìù **Please provide the following information:**

{fields_text}

**Tip:** You can provide all information at once."""
    
    def get_confirmation_prompt(self, intent_summary: Dict, language: str) -> str:
        """Get confirmation prompt"""
        # Format summary nicely
        summary_items = []
        field_map = {
            "Service": "Service" if language == "en" else "‡§∏‡•á‡§µ‡§æ" if language == "hi" else "‡§∏‡•á‡§µ‡§æ",
            "Package": "Package" if language == "en" else "‡§™‡•à‡§ï‡•á‡§ú" if language == "hi" else "‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú",
            "Name": "Name" if language == "en" else "‡§®‡§æ‡§Æ" if language == "hi" else "‡§®‡§æ‡§Æ",
            "Email": "Email" if language == "en" else "‡§à‡§Æ‡•á‡§≤" if language == "hi" else "‡§á‡§Æ‡•á‡§≤",
            "Phone": "Phone" if language == "en" else "‡§´‡§º‡•ã‡§®" if language == "hi" else "‡§´‡•ã‡§®",
            "Country": "Country" if language == "en" else "‡§¶‡•á‡§∂" if language == "hi" else "‡§¶‡•á‡§∂",
            "Address": "Address" if language == "en" else "‡§™‡§§‡§æ" if language == "hi" else "‡§†‡•á‡§ó‡§æ‡§®‡§æ",
            "PIN Code": "PIN Code" if language == "en" else "‡§™‡§ø‡§® ‡§ï‡•ã‡§°" if language == "hi" else "‡§™‡§ø‡§® ‡§ï‡•ã‡§°",
            "Date": "Date" if language == "en" else "‡§§‡§æ‡§∞‡•Ä‡§ñ" if language == "hi" else "‡§Æ‡§ø‡§§‡§ø"
        }
        
        for key, value in intent_summary.items():
            display_key = field_map.get(key, key)
            summary_items.append(f"‚Ä¢ **{display_key}:** {value}")
        
        summary_text = "\n".join(summary_items)
        
        if language == "hi":
            return f"""üéØ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç:**

{summary_text}

**‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§∏‡§π‡•Ä ‡§π‡•à?** ('‡§π‡§æ‡§Ç' ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç ‡§Ø‡§æ ‡§¨‡§¶‡§≤‡§æ‡§µ ‡§ï‡•á ‡§≤‡§ø‡§è '‡§®‡§π‡•Ä‡§Ç')"""
        elif language == "ne":
            return f"""üéØ **‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:**

{summary_text}

**‡§ï‡•á ‡§∏‡§¨‡•à ‡§†‡•Ä‡§ï ‡§õ?** ('‡§π‡•ã' ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡§ø‡§®‡•Å‡§π‡•ã‡§∏‡•ç ‡§µ‡§æ ‡§™‡§∞‡§ø‡§µ‡§∞‡•ç‡§§‡§® ‡§ó‡§∞‡•ç‡§® '‡§π‡•ã‡§á‡§®')"""
        else:
            return f"""üéØ **Please confirm your booking details:**

{summary_text}

**Is everything correct?** (Reply 'yes' to confirm or 'no' to make changes)"""
    
    def get_country_inquiry_prompt(self, language: str) -> str:
        """Get country inquiry prompt"""
        if language == "hi":
            return "üåç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§ö‡•Å‡§®‡•á‡§Ç:** ‡§≠‡§æ‡§∞‡§§, ‡§®‡•á‡§™‡§æ‡§≤, ‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®, ‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂, ‡§Ø‡§æ ‡§¶‡•Å‡§¨‡§à?"
        elif language == "ne":
            return "üåç **‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•á‡§∂ ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç:** ‡§≠‡§æ‡§∞‡§§, ‡§®‡•á‡§™‡§æ‡§≤, ‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®, ‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂, ‡§µ‡§æ ‡§¶‡•Å‡§¨‡§à?"
        else:
            return "üåç **Please specify country:** India, Nepal, Pakistan, Bangladesh, or Dubai?"
    
    def get_missing_field_prompt(self, field: str, language: str) -> str:
        """Get prompt for specific missing field"""
        prompts = {
            "name": {
                "en": "üë§ **What's your full name?**",
                "hi": "üë§ **‡§Ü‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?**",
                "ne": "üë§ **‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§™‡•Å‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•á ‡§π‡•ã?**"
            },
            "email": {
                "en": "üìß **What's your email address?**",
                "hi": "üìß **‡§Ü‡§™‡§ï‡§æ ‡§à‡§Æ‡•á‡§≤ ‡§™‡§§‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?**",
                "ne": "üìß **‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§á‡§Æ‡•á‡§≤ ‡§†‡•á‡§ó‡§æ‡§®‡§æ ‡§ï‡•á ‡§π‡•ã?**"
            },
            "phone": {
                "en": "üì± **What's your WhatsApp number with country code?**\n(Example: +919876543210)",
                "hi": "üì± **‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§Ü‡§™‡§ï‡§æ ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Ç‡§¨‡§∞ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?**\n(‡§â‡§¶‡§æ‡§π‡§∞‡§£: +919876543210)",
                "ne": "üì± **‡§¶‡•á‡§∂ ‡§ï‡•ã‡§° ‡§∏‡§π‡§ø‡§§ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§®‡§Æ‡•ç‡§¨‡§∞ ‡§ï‡•á ‡§π‡•ã?**\n(‡§â‡§¶‡§æ‡§π‡§∞‡§£: +919876543210)"
            },
            "date": {
                "en": "üìÖ **When is the event?**\n(e.g., March 25, 2025)",
                "hi": "üìÖ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§ï‡§¨ ‡§π‡•à?**\n(‡§ú‡•à‡§∏‡•á, 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025)",
                "ne": "üìÖ **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§ï‡§π‡§ø‡§≤‡•á ‡§π‡•ã?**\n(‡§ú‡§∏‡•ç‡§§‡•à, 25 ‡§Æ‡§æ‡§∞‡•ç‡§ö 2025)"
            },
            "address": {
                "en": "üìç **What's the event address?**",
                "hi": "üìç **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§ï‡§æ ‡§™‡§§‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?**",
                "ne": "üìç **‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ‡§ï‡•ã ‡§†‡•á‡§ó‡§æ‡§®‡§æ ‡§ï‡•á ‡§π‡•ã?**"
            },
            "pincode": {
                "en": "üìÆ **What's the PIN/postal code?**",
                "hi": "üìÆ **‡§™‡§ø‡§®/‡§°‡§æ‡§ï ‡§ï‡•ã‡§° ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?**",
                "ne": "üìÆ **‡§™‡§ø‡§®/‡§°‡§æ‡§ï ‡§ï‡•ã‡§° ‡§ï‡•á ‡§π‡•ã?**"
            },
            "country": {
                "en": "üåç **Which country?**\n(India, Nepal, Pakistan, Bangladesh, Dubai)",
                "hi": "üåç **‡§ï‡•å‡§® ‡§∏‡§æ ‡§¶‡•á‡§∂?**\n(‡§≠‡§æ‡§∞‡§§, ‡§®‡•á‡§™‡§æ‡§≤, ‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®, ‡§¨‡§æ‡§Ç‡§ó‡•ç‡§≤‡§æ‡§¶‡•á‡§∂, ‡§¶‡•Å‡§¨‡§à)",
                "ne": "üåç **‡§ï‡•Å‡§® ‡§¶‡•á‡§∂?**\n(‡§≠‡§æ‡§∞‡§§, ‡§®‡•á‡§™‡§æ‡§≤, ‡§™‡§æ‡§ï‡§ø‡§∏‡•ç‡§§‡§æ‡§®, ‡§¨‡§Ç‡§ó‡§≤‡§æ‡§¶‡•á‡§∂, ‡§¶‡•Å‡§¨‡§à)"
            }
        }
        
        field_prompts = prompts.get(field.lower().split()[0], prompts["name"])
        return field_prompts.get(language, field_prompts["en"])
    
    def get_exit_message(self, language: str) -> str:
        """Get exit/cancellation message"""
        if language == "hi":
            return "‚úÖ **‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞ ‡§¶‡•Ä ‡§ó‡§à ‡§π‡•à‡•§** ‡§î‡§∞ ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?"
        elif language == "ne":
            return "‚úÖ **‡§¨‡•Å‡§ï‡§ø‡§ô ‡§∞‡§¶‡•ç‡§¶ ‡§ó‡§∞‡§ø‡§è‡§ï‡•ã ‡§õ‡•§** ‡§Ö‡§∞‡•Å ‡§ï‡§∏‡§∞‡•Ä ‡§Æ‡§¶‡•ç‡§¶‡§§ ‡§ó‡§∞‡•ç‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å?"
        else:
            return "‚úÖ **Booking cancelled.** How else can I help?"
    
    def get_restart_message(self, language: str) -> str:
        """Get restart message"""
        if language == "hi":
            return "üîÑ **‡§ï‡•ã‡§à ‡§¨‡§æ‡§§ ‡§®‡§π‡•Ä‡§Ç!** ‡§ö‡§≤‡§ø‡§è ‡§®‡§è ‡§∏‡§ø‡§∞‡•á ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§"
        elif language == "ne":
            return "üîÑ **‡§ï‡•á‡§π‡•Ä ‡§π‡•Å‡§¶‡•à‡§®!** ‡§®‡§Ø‡§æ‡§Å ‡§∏‡•Å‡§∞‡•Å‡§µ‡§æ‡§§ ‡§ó‡§∞‡•å‡§Ç‡•§"
        else:
            return "üîÑ **No problem!** Let's start fresh."
    
    def get_service_price_info(self, service_name: str, language: str) -> str:
        """Get specific service price information"""
        price_info = {
            "Bridal Makeup Services": {
                "en": "**Bridal Makeup Services:**\n‚Ä¢ Chirag's Signature Bridal Makeup: ‚Çπ99,999\n‚Ä¢ Luxury Bridal Makeup (HD/Brush): ‚Çπ79,999\n‚Ä¢ Reception/Engagement/Cocktail Makeup: ‚Çπ59,999",
                "hi": "**‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§è‡§Ç:**\n‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§ï‡§æ ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ99,999\n‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD/‡§¨‡•ç‡§∞‡§∂): ‚Çπ79,999\n‚Ä¢ ‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§®/‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü/‡§ï‡•â‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ59,999",
                "ne": "**‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç:**\n‚Ä¢ ‡§ö‡§ø‡§∞‡§æ‡§ó‡§ï‡•ã ‡§∏‡§ø‡§ó‡•ç‡§®‡•á‡§ö‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ99,999\n‚Ä¢ ‡§≤‡§ï‡•ç‡§ú‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ (HD/‡§¨‡•ç‡§∞‡§∂): ‚Çπ79,999\n‚Ä¢ ‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§®/‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü/‡§ï‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ59,999"
            },
            "Reception": {
                "en": "**Reception/Engagement/Cocktail Makeup** costs ‚Çπ59,999. This is part of our Bridal Makeup Services.",
                "hi": "**‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§®/‡§è‡§Ç‡§ó‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü/‡§ï‡•â‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™** ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§ ‚Çπ59,999 ‡§π‡•à‡•§ ‡§Ø‡§π ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§ì‡§Ç ‡§ï‡§æ ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§π‡•à‡•§",
                "ne": "**‡§∞‡§ø‡§∏‡•á‡§™‡•ç‡§∂‡§®/‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§Æ‡•á‡§®‡•ç‡§ü/‡§ï‡§ï‡§ü‡•á‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™** ‡§ï‡•ã ‡§Æ‡•Å‡§≤‡•ç‡§Ø ‚Çπ59,999 ‡§π‡•ã‡•§ ‡§Ø‡•ã ‡§π‡§æ‡§Æ‡•ç‡§∞‡•ã ‡§¨‡•ç‡§∞‡§æ‡§á‡§°‡§≤ ‡§Æ‡•á‡§ï‡§Ö‡§™ ‡§∏‡•á‡§µ‡§æ‡§π‡§∞‡•Ç‡§ï‡•ã ‡§≠‡§æ‡§ó ‡§π‡•ã‡•§"
            },
            "Senior Artist": {
                "en": "**Senior Artist Pricing:**\n‚Ä¢ Party Makeup by Senior Artist: ‚Çπ9,999\n‚Ä¢ Henna by Senior Artist: ‚Çπ19,999",
                "hi": "**‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç:**\n‚Ä¢ ‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ9,999\n‚Ä¢ ‡§∏‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§Ü‡§∞‡•ç‡§ü‡§ø‡§∏‡•ç‡§ü ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Æ‡•á‡§Ç‡§π‡§¶‡•Ä: ‚Çπ19,999",
                "ne": "**‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞‡§ï‡•ã ‡§Æ‡•Å‡§≤‡•ç‡§Ø‡§π‡§∞‡•Ç:**\n‚Ä¢ ‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§™‡§æ‡§∞‡•ç‡§ü‡•Ä ‡§Æ‡•á‡§ï‡§Ö‡§™: ‚Çπ9,999\n‚Ä¢ ‡§∏‡§ø‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§≤‡§æ‡§ï‡§æ‡§∞ ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§π‡•á‡§®‡•ç‡§®‡§æ: ‚Çπ19,999"
            }
        }
        
        # Find matching service
        for key, value in price_info.items():
            if key.lower() in service_name.lower() or service_name.lower() in key.lower():
                return value.get(language, value["en"])
        
        # Default to service details
        return self.get_service_details(language)

_______________

Below are services content...

booking_services.py:

"""
Booking Service - COMPLETE IMPLEMENTATION
Booking creation and management
"""

import re
import logging
from datetime import datetime
from typing import Dict, Any

from ..models.memory import ConversationMemory

logger = logging.getLogger(__name__)


class BookingService:
    """Booking creation and management"""
    
    def __init__(self, booking_collection, twilio_client, whatsapp_from: str):
        """Initialize booking service"""
        self.booking_collection = booking_collection
        self.twilio_client = twilio_client
        self.whatsapp_from = whatsapp_from
        
        self.country_codes = {
            "India": "+91",
            "Nepal": "+977",
            "Pakistan": "+92",
            "Bangladesh": "+880",
            "Dubai": "+971"
        }
    
    def create_booking_payload(self, memory: ConversationMemory) -> Dict[str, Any]:
        """Create booking data from memory"""
        phone_country = memory.intent.phone_country
        
        # Infer phone country if not set
        if not phone_country and memory.intent.phone and memory.intent.phone.startswith('+'):
            phone_code_map = {
                '91': 'India', '977': 'Nepal', '92': 'Pakistan',
                '880': 'Bangladesh', '971': 'Dubai'
            }
            
            for code, country in phone_code_map.items():
                if memory.intent.phone.startswith(f'+{code}'):
                    phone_country = country
                    break
        
        if not phone_country:
            phone_country = memory.intent.service_country or "India"
        
        # Format phone
        formatted_phone = self._format_phone_for_api(memory.intent.phone, phone_country)
        
        if not formatted_phone.startswith('+'):
            logger.error(f"Phone missing country code: {memory.intent.phone}")
            digits = re.sub(r'\D', '', memory.intent.phone or "")
            if len(digits) >= 10:
                formatted_phone = f"+91{digits[-10:]}"
            else:
                formatted_phone = ""
        
        return {
            "service": memory.intent.service,
            "package": memory.intent.package,
            "name": memory.intent.name,
            "email": memory.intent.email,
            "phone": formatted_phone,
            "phone_country": phone_country,
            "service_country": memory.intent.service_country or "India",
            "address": memory.intent.address,
            "pincode": memory.intent.pincode,
            "date": memory.intent.date,
            "message": memory.intent.message or "",
            "language": memory.language,
            "session_id": memory.session_id,
            "stage": memory.stage,
            "status": "pending",
            "otp_verified": False,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "source": "agent_chat"
        }
    
    def validate_booking_completeness(self, intent) -> bool:
        """Validate booking has all required fields"""
        return intent.is_complete()
    
    def save_booking(self, booking_data: Dict) -> str:
        """Save booking to database"""
        try:
            result = self.booking_collection.insert_one(booking_data)
            booking_id = str(result.inserted_id)
            logger.info(f"‚úÖ Booking saved: {booking_id}")
            return booking_id
        except Exception as e:
            logger.error(f"‚ùå Booking save failed: {e}")
            raise
    
    def send_confirmation_whatsapp(self, phone: str, booking_data: Dict, language: str) -> bool:
        """Send WhatsApp confirmation"""
        try:
            whatsapp_msg = self.generate_whatsapp_message(booking_data, language)
            
            whatsapp_phone = phone
            if not whatsapp_phone.startswith('whatsapp:'):
                whatsapp_phone = f"whatsapp:{phone}"
            
            self.twilio_client.messages.create(
                from_=self.whatsapp_from,
                to=whatsapp_phone,
                body=whatsapp_msg
            )
            
            logger.info(f"‚úÖ Confirmation WhatsApp sent to {phone}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå WhatsApp send failed: {e}")
            return False
    
    def generate_whatsapp_message(self, booking_data: Dict, language: str) -> str:
        """Generate WhatsApp confirmation message"""
        name = booking_data.get("name", "")
        service = booking_data.get("service", "")
        package = booking_data.get("package", "")
        date = booking_data.get("date", "")
        country = booking_data.get("service_country", "India")
        
        messages = {
            "en": f"""‚úÖ **Booking Request Sent to Chirag Sharma!**

üìã **Details:**
‚Ä¢ Name: {name}
‚Ä¢ Service: {service}
‚Ä¢ Package: {package}
‚Ä¢ Date: {date}
‚Ä¢ Location: {country}

‚è≥ **Status:** Pending Approval
Chirag will review and contact you within 24 hours via WhatsApp.

Thank you for choosing JinniChirag! üíÑ‚ú®""",
            
            "ne": f"""‚úÖ **‡§¨‡•Å‡§ï‡§ø‡§ô ‡§Ö‡§®‡•Å‡§∞‡•ã‡§ß ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ‡§≤‡§æ‡§à ‡§™‡§†‡§æ‡§á‡§è‡§ï‡•ã ‡§õ!**

üìã **‡§µ‡§ø‡§µ‡§∞‡§£:**
‚Ä¢ ‡§®‡§æ‡§Æ: {name}
‚Ä¢ ‡§∏‡•á‡§µ‡§æ: {service}
‚Ä¢ ‡§™‡•ç‡§Ø‡§æ‡§ï‡•á‡§ú: {package}
‚Ä¢ ‡§Æ‡§ø‡§§‡§ø: {date}
‚Ä¢ ‡§∏‡•ç‡§•‡§æ‡§®: {country}

‚è≥ **‡§∏‡•ç‡§•‡§ø‡§§‡§ø:** ‡§∏‡•ç‡§µ‡•Ä‡§ï‡•É‡§§‡§ø ‡§™‡§∞‡•ç‡§ñ‡§ø‡§∞‡§π‡•á‡§ï‡•ã
‡§ö‡§ø‡§∞‡§æ‡§ó ‡•®‡•™ ‡§ò‡§£‡•ç‡§ü‡§æ ‡§≠‡§ø‡§§‡•ç‡§∞ ‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡§æ‡§à ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§Æ‡§æ‡§∞‡•ç‡§´‡§§ ‡§∏‡§Æ‡•ç‡§™‡§∞‡•ç‡§ï ‡§ó‡§∞‡•ç‡§®‡•á‡§õ‡•§

JinniChirag ‡§õ‡§®‡•ã‡§ü ‡§ó‡§∞‡•ç‡§®‡•Å‡§≠‡§è‡§ï‡•ã‡§Æ‡§æ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! üíÑ‚ú®""",
            
            "hi": f"""‚úÖ **‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§Ö‡§®‡•Å‡§∞‡•ã‡§ß ‡§ö‡§ø‡§∞‡§æ‡§ó ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§ï‡•ã ‡§≠‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ!**

üìã **‡§µ‡§ø‡§µ‡§∞‡§£:**
‚Ä¢ ‡§®‡§æ‡§Æ: {name}
‚Ä¢ ‡§∏‡•á‡§µ‡§æ: {service}
‚Ä¢ ‡§™‡•à‡§ï‡•á‡§ú: {package}
‚Ä¢ ‡§§‡§æ‡§∞‡•Ä‡§ñ: {date}
‚Ä¢ ‡§∏‡•ç‡§•‡§æ‡§®: {country}

‚è≥ **‡§∏‡•ç‡§•‡§ø‡§§‡§ø:** ‡§∏‡•ç‡§µ‡•Ä‡§ï‡•É‡§§‡§ø ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ
‡§ö‡§ø‡§∞‡§æ‡§ó ‡•®‡•™ ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§≠‡•Ä‡§§‡§∞ ‡§Ü‡§™‡§∏‡•á ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§™‡§∞ ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§ó‡§æ‡•§

JinniChirag ‡§ö‡•Å‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! üíÑ‚ú®"""
        }
        
        return messages.get(language, messages["en"])
    
    def format_booking_summary(self, intent, language: str) -> str:
        """Format booking summary"""
        summary_parts = []
        
        if intent.service:
            summary_parts.append(f"Service: {intent.service}")
        if intent.package:
            summary_parts.append(f"Package: {intent.package}")
        if intent.name:
            summary_parts.append(f"Name: {intent.name}")
        if intent.date:
            summary_parts.append(f"Date: {intent.date}")
        if intent.service_country:
            summary_parts.append(f"Location: {intent.service_country}")
        
        return "\n".join(summary_parts)
    
    def _format_phone_for_api(self, phone: str, country: str = "India") -> str:
        """Format phone for API (add country code)"""
        if not phone:
            return ""
        
        if phone.startswith('+'):
            digits = re.sub(r'\D', '', phone)
            if len(digits) >= 10:
                return phone
            else:
                return ""
        
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 10:
            return ""
        
        phone_number = digits[-10:]
        country_code = self.country_codes.get(country, "+91")
        
        if country_code.startswith('+'):
            clean_code = country_code[1:]
        else:
            clean_code = country_code
        
        return f"+{clean_code}{phone_number}"


knowledge_base_services.py:

# agent/services/knowledge_base_service.py
"""
Knowledge Base Service - Handles knowledge base queries with Groq LLM
"""

import logging
import os
from typing import Optional, Dict, Any
import requests
from config import GROQ_API_KEY

logger = logging.getLogger(__name__)


class KnowledgeBaseService:
    """Service for querying knowledge base with Groq LLM"""
    
    def __init__(self, knowledge_collection=None):
        """Initialize knowledge base service"""
        self.knowledge_collection = knowledge_collection
        self.groq_api_key = GROQ_API_KEY
        
        if not self.groq_api_key:
            logger.warning("GROQ_API_KEY not found in environment")
        
        logger.info("KnowledgeBaseService initialized")
    
    def load_knowledge_from_db(self, language: str) -> str:
        """Load knowledge base content from database for specific language"""
        try:
            if self.knowledge_collection is None:
                logger.warning("No knowledge collection configured")
                return ""
            
            # Get all active knowledge entries for the specified language
            knowledge_entries = list(self.knowledge_collection.find({
                "language": language,
                "is_active": True
            }).sort("created_at", -1))
            
            if not knowledge_entries:
                logger.warning(f"‚ö†Ô∏è No knowledge entries found for language: {language}")
                return ""
            
            # Combine all content
            content_blocks = []
            for entry in knowledge_entries:
                content = entry.get("content", "")
                category = entry.get("category", "")
                
                if content:  # Only add if content exists
                    if category:
                        content_blocks.append(f"[{category}]\n{content}")
                    else:
                        content_blocks.append(content)
            
            combined_content = "\n\n---\n\n".join(content_blocks)
            
            if combined_content:
                logger.info(f"‚úÖ Loaded {len(content_blocks)} knowledge entries for language: {language}")
            
            return combined_content
            
        except Exception as e:
            logger.error(f"‚ùå Error loading knowledge from database: {e}", exc_info=True)
            return ""
    
    async def get_answer(self, question: str, language: str, context: Optional[str] = None) -> str:
        """Get answer from knowledge base using Groq LLM"""
        try:
            # Load knowledge base
            knowledge_base = self.load_knowledge_from_db(language)
            
            if not knowledge_base:
                logger.info(f"‚ö†Ô∏è No knowledge base found for language: {language}, using LLM general knowledge")
                return await self._get_answer_from_llm(question, language, context)
            
            # Build system prompt
            system_prompt = self._build_system_prompt(language, knowledge_base, context)
            
            # Prepare messages for Groq API
            messages_for_ai = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": question}
            ]
            
            # Call Groq API
            response = requests.post(
                "https://api.groq.com/openai/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.groq_api_key}",
                    "Content-Type": "application/json",
                },
                json={
                    "model": "llama-3.1-8b-instant",
                    "messages": messages_for_ai,
                    "temperature": 0.3,
                    "max_tokens": 150,
                },
                timeout=10,
            )
            
            if response.status_code != 200:
                logger.error(f"‚ùå Groq API error: {response.status_code} - {response.text}")
                return await self._get_answer_from_llm(question, language, context)
            
            # Extract answer
            result = response.json()
            answer = result["choices"][0]["message"]["content"].strip()
            
            # Clean up the answer
            answer = self._clean_answer(answer)
            
            logger.info(f"‚úÖ Knowledge base answered: '{question[:40]}...' in {language}")
            
            return answer
            
        except requests.exceptions.Timeout:
            logger.error("‚è±Ô∏è Groq API timeout")
            return self._get_minimal_fallback(language)
        except requests.exceptions.RequestException as e:
            logger.error(f"üåê Groq API request error: {e}")
            return self._get_minimal_fallback(language)
        except Exception as e:
            logger.error(f"‚ùå Error getting answer from knowledge base: {e}", exc_info=True)
            return self._get_minimal_fallback(language)
    
    async def _get_answer_from_llm(self, question: str, language: str, context: Optional[str] = None) -> str:
        """Get answer directly from LLM when knowledge base is empty"""
        try:
            # Build general system prompt
            system_prompt = self._build_general_prompt(language, context)
            
            messages_for_ai = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": question}
            ]
            
            response = requests.post(
                "https://api.groq.com/openai/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.groq_api_key}",
                    "Content-Type": "application/json",
                },
                json={
                    "model": "llama-3.1-8b-instant",
                    "messages": messages_for_ai,
                    "temperature": 0.3,
                    "max_tokens": 120,
                },
                timeout=10,
            )
            
            if response.status_code == 200:
                result = response.json()
                answer = result["choices"][0]["message"]["content"].strip()
                return self._clean_answer(answer)
            else:
                return self._get_minimal_fallback(language)
                
        except Exception:
            return self._get_minimal_fallback(language)
    
    def _build_system_prompt(self, language: str, knowledge_base: str, context: Optional[str] = None) -> str:
        """Build system prompt with knowledge base"""
        
        language_instructions = {
            "en": "Answer in English naturally and concisely. Keep it short (2-3 sentences max).",
            "hi": "Answer in Hindi (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max).",
            "ne": "Answer in Nepali (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max).",
            "mr": "Answer in Marathi (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max)."
        }
        
        lang_config = language_instructions.get(language, language_instructions["en"])
        
        prompt = f"""You are a helpful assistant for Chirag Sharma's celebrity makeup artist booking service.

{lang_config}

IMPORTANT: Keep your answer VERY SHORT - 2-3 sentences maximum.
Answer naturally and conversationally.

KNOWLEDGE BASE:
{knowledge_base}

{f"CONTEXT: {context}" if context else ""}

Answer the question based on the knowledge above."""

        return prompt
    
    def _build_general_prompt(self, language: str, context: Optional[str] = None) -> str:
        """Build general prompt without knowledge base"""
        
        language_instructions = {
            "en": "Answer in English naturally and concisely. Keep it short (2-3 sentences max).",
            "hi": "Answer in Hindi (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max).",
            "ne": "Answer in Nepali (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max).",
            "mr": "Answer in Marathi (Devanagari script) naturally and concisely. Keep it short (2-3 sentences max)."
        }
        
        lang_config = language_instructions.get(language, language_instructions["en"])
        
        prompt = f"""You are a helpful assistant for Chirag Sharma's celebrity makeup artist booking service.

{lang_config}

{f"CONTEXT: {context}" if context else ""}

Answer the question concisely and helpfully."""

        return prompt
    
    def _clean_answer(self, answer: str) -> str:
        """Clean up AI-generated answer"""
        answer = answer.strip()
        
        # Remove unwanted prefixes
        unwanted_prefixes = [
            "According to the knowledge base",
            "Based on the information",
            "As per the knowledge base",
            "The knowledge base states",
            "From the knowledge base",
            "According to",
            "Based on"
        ]
        
        for prefix in unwanted_prefixes:
            if answer.lower().startswith(prefix.lower()):
                answer = answer[len(prefix):].strip()
                if answer.startswith(("," or ":")):
                    answer = answer[1:].strip()
                if answer:
                    answer = answer[0].upper() + answer[1:]
        
        return answer
    
    def _get_minimal_fallback(self, language: str) -> str:
        """Provide minimal fallback when everything fails"""
        
        fallback_messages = {
            "en": "Please continue with your booking for more information.",
            "hi": "‡§Ö‡§ß‡§ø‡§ï ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç‡•§",
            "ne": "‡§•‡§™ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ü‡§´‡•ç‡§®‡•ã ‡§¨‡•Å‡§ï‡§ø‡§ô ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§æ‡§ñ‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§",
            "mr": "‡§Ö‡§ß‡§ø‡§ï ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó ‡§∏‡•Å‡§∞‡•Ç ‡§†‡•á‡§µ‡§æ."
        }
        
        return fallback_messages.get(language, fallback_messages["en"])


memory_services.py:

"""
Memory Service - Session management
"""

import secrets
from datetime import datetime, timedelta
from typing import Dict, Optional, Any, List
from collections import OrderedDict
import logging
import threading

from ..models.memory import ConversationMemory
from ..models.intent import BookingIntent

logger = logging.getLogger(__name__)


class MemoryService:
    """In-memory session store with TTL and LRU cleanup"""
    
    def __init__(self, ttl_hours: int = 2, max_sessions: int = 1000):
        """Initialize memory service"""
        self.ttl_hours = ttl_hours
        self.max_sessions = max_sessions
        self.sessions: Dict[str, ConversationMemory] = OrderedDict()
        self.lock = threading.RLock()
        self.stats = {
            'created': 0,
            'accessed': 0,
            'expired': 0,
            'evicted': 0,
            'last_cleanup': None
        }
        
        # Start cleanup thread
        self.cleanup_thread = threading.Thread(target=self._cleanup_worker, daemon=True)
        self.cleanup_thread.start()
        
        logger.info(f"MemoryService initialized: TTL={ttl_hours}h, Max={max_sessions}")
    
    def create_session(self, language: str = "en") -> str:
        """Create new session"""
        with self.lock:
            # Generate unique session ID
            session_id = secrets.token_urlsafe(16)
            
            # Create new memory
            memory = ConversationMemory(
                session_id=session_id,
                language=language
            )
            
            # Add to sessions
            self.sessions[session_id] = memory
            self.sessions.move_to_end(session_id)  # Mark as recently used
            
            # Update stats
            self.stats['created'] += 1
            
            logger.info(f"Created new session: {session_id} (lang: {language})")
            
            return session_id
    
    def get_session(self, session_id: str) -> Optional[ConversationMemory]:
        """Get session by ID"""
        with self.lock:
            if session_id not in self.sessions:
                return None
            
            memory = self.sessions[session_id]
            
            # Check if expired
            if self._is_expired(memory):
                del self.sessions[session_id]
                self.stats['expired'] += 1
                logger.info(f"Session expired: {session_id}")
                return None
            
            # Move to end (recently used)
            self.sessions.move_to_end(session_id)
            
            # Update stats
            self.stats['accessed'] += 1
            
            return memory
    
    def update_session(self, session_id: str, memory: ConversationMemory) -> None:
        """Update session"""
        with self.lock:
            if session_id not in self.sessions:
                return
            
            # Update memory and move to end
            self.sessions[session_id] = memory
            self.sessions.move_to_end(session_id)
            
            # Update last_updated
            memory.last_updated = datetime.utcnow()
            
            logger.debug(f"Updated session: {session_id}")
    
    def delete_session(self, session_id: str) -> bool:
        """Delete session"""
        with self.lock:
            if session_id in self.sessions:
                del self.sessions[session_id]
                logger.info(f"Deleted session: {session_id}")
                return True
            return False
    
    def reset_session(self, session_id: str) -> Optional[ConversationMemory]:
        """Reset session for new booking"""
        with self.lock:
            memory = self.get_session(session_id)
            if not memory:
                return None
            
            # Reset memory but keep session ID and language
            memory.reset()
            self.update_session(session_id, memory)
            
            logger.info(f"Reset session: {session_id}")
            
            return memory
    
    def update_last_shown_list(self, session_id: str, list_type: str) -> Optional[ConversationMemory]:
        """Update last shown list context"""
        with self.lock:
            memory = self.get_session(session_id)
            if not memory:
                return None
            
            memory.last_shown_list = list_type
            self.update_session(session_id, memory)
            
            return memory
    
    def cleanup_old_sessions(self) -> int:
        """Cleanup expired sessions"""
        with self.lock:
            expired_count = 0
            current_time = datetime.utcnow()
            
            # Find expired sessions
            expired_sessions = []
            for session_id, memory in list(self.sessions.items()):
                if self._is_expired(memory):
                    expired_sessions.append(session_id)
            
            # Remove expired sessions
            for session_id in expired_sessions:
                del self.sessions[session_id]
                expired_count += 1
            
            # LRU cleanup if still over limit
            if len(self.sessions) > self.max_sessions:
                overflow = len(self.sessions) - self.max_sessions
                for _ in range(overflow):
                    # Remove oldest (least recently used)
                    session_id, _ = self.sessions.popitem(last=False)
                    self.stats['evicted'] += 1
            
            # Update stats
            self.stats['expired'] += expired_count
            self.stats['last_cleanup'] = current_time
            
            if expired_count > 0:
                logger.info(f"Cleaned up {expired_count} expired sessions")
            
            return expired_count
    
    def get_stats(self) -> Dict[str, Any]:
        """Get memory store statistics"""
        with self.lock:
            stats = self.stats.copy()
            stats.update({
                'active_sessions': len(self.sessions),
                'max_sessions': self.max_sessions,
                'ttl_hours': self.ttl_hours,
                'timestamp': datetime.utcnow().isoformat()
            })
            return stats
    
    def _is_expired(self, memory: ConversationMemory) -> bool:
        """Check if session is expired"""
        expiration_time = memory.last_updated + timedelta(hours=self.ttl_hours)
        return datetime.utcnow() > expiration_time
    
    def _cleanup_worker(self):
        """Background cleanup worker"""
        import time
        
        while True:
            try:
                time.sleep(300)  # Run every 5 minutes
                cleaned = self.cleanup_old_sessions()
                if cleaned > 0:
                    logger.debug(f"Background cleanup removed {cleaned} sessions")
            except Exception as e:
                logger.error(f"Cleanup worker error: {e}")
    
    def _cleanup_lru(self, force: bool = False):
        """LRU cleanup if store is too large"""
        with self.lock:
            if len(self.sessions) > self.max_sessions or force:
                overflow = len(self.sessions) - self.max_sessions
                if overflow > 0:
                    for _ in range(overflow):
                        session_id, _ = self.sessions.popitem(last=False)
                        self.stats['evicted'] += 1
                    logger.info(f"LRU cleanup removed {overflow} sessions")


otp_services.py:

"""
OTP Service - Enhanced with proper generation, storage, and verification
"""

import secrets
import logging
from datetime import datetime, timedelta
from random import randint
from typing import Dict, Optional, Tuple, Any

logger = logging.getLogger(__name__)


class OTPService:
    """Service for OTP operations with enhanced security"""
    
    def __init__(self, twilio_client=None, from_number: str = None, expiry_minutes: int = 5):
        """
        Initialize OTP service
        
        Args:
            twilio_client: Twilio client instance
            from_number: WhatsApp-enabled Twilio number
            expiry_minutes: OTP expiry time in minutes
        """
        self.twilio_client = twilio_client
        self.from_number = from_number
        self.expiry_minutes = expiry_minutes
        self.otp_store: Dict[str, Dict] = {}  # In-memory store: booking_id -> otp_data
        
        logger.info(f"OTPService initialized (expiry: {expiry_minutes} minutes)")
    
    def generate_otp(self) -> str:
        """
        Generate a 6-digit OTP
        
        Returns:
            6-digit OTP string
        """
        otp = str(randint(100000, 999999))
        logger.debug(f"Generated OTP: {otp[:2]}****")
        return otp
    
    def generate_booking_id(self) -> str:
        """
        Generate a unique booking ID
        
        Returns:
            Secure booking ID string
        """
        booking_id = secrets.token_urlsafe(16)
        logger.debug(f"Generated booking ID: {booking_id[:8]}...")
        return booking_id
    
    def store_otp_data(self, booking_id: str, otp: str, phone: str, 
                      booking_data: Dict, language: str) -> None:
        """
        Store OTP with expiry and booking data
        
        Args:
            booking_id: Unique booking identifier
            otp: 6-digit OTP
            phone: User's phone number
            booking_data: Complete booking information
            language: User's language preference
        """
        expires_at = datetime.utcnow() + timedelta(minutes=self.expiry_minutes)
        
        self.otp_store[booking_id] = {
            "otp": otp,
            "expires_at": expires_at,
            "booking_data": booking_data,
            "phone": phone,
            "language": language,
            "attempts": 0,
            "created_at": datetime.utcnow(),
            "last_sent": datetime.utcnow()
        }
        
        logger.info(
            f"Stored OTP for booking {booking_id[:8]}..., "
            f"expires at {expires_at.strftime('%Y-%m-%d %H:%M:%S')}"
        )
    
    def send_otp(self, phone: str, otp: str, language: str = "en") -> bool:
        """
        Send OTP via WhatsApp using Twilio
        
        Args:
            phone: Phone number (with country code)
            otp: 6-digit OTP to send
            language: Language for OTP message
            
        Returns:
            True if sent successfully, False otherwise
        """
        if not self.twilio_client or not self.from_number:
            logger.warning("Twilio client or from_number not configured, skipping SMS send")
            # In development, we can skip actual sending
            return True
        
        try:
            # Ensure phone has whatsapp: prefix
            whatsapp_phone = f"whatsapp:{phone}" if not phone.startswith("whatsapp:") else phone
            
            # Format from number
            from_whatsapp = f"whatsapp:{self.from_number}" if not self.from_number.startswith("whatsapp:") else self.from_number
            
            # Get message in appropriate language
            message = self._get_otp_message(otp, language)
            
            # Send via Twilio
            result = self.twilio_client.messages.create(
                from_=from_whatsapp,
                to=whatsapp_phone,
                body=message
            )
            
            logger.info(f"‚úÖ OTP sent to {phone} (SID: {result.sid})")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Failed to send OTP to {phone}: {e}")
            return False
    
    def verify_otp(self, booking_id: str, user_otp: str) -> Dict[str, Any]:
        """
        Verify OTP and return result
        
        Args:
            booking_id: Booking identifier
            user_otp: OTP entered by user
            
        Returns:
            Dict with verification result and metadata
        """
        logger.info(f"üîç Verifying OTP for booking {booking_id[:8]}...")
        
        # Check if booking exists
        otp_data = self.otp_store.get(booking_id)
        
        if not otp_data:
            logger.warning(f"‚ùå Booking ID not found: {booking_id[:8]}...")
            return {
                "valid": False,
                "error": "OTP expired or invalid booking ID",
                "should_restart": True
            }
        
        # Check expiry
        now = datetime.utcnow()
        if now > otp_data["expires_at"]:
            logger.warning(f"‚è∞ OTP expired for booking {booking_id[:8]}...")
            del self.otp_store[booking_id]
            return {
                "valid": False,
                "error": f"OTP expired ({self.expiry_minutes} minutes)",
                "should_restart": True
            }
        
        # Increment attempts
        otp_data["attempts"] += 1
        
        # Check max attempts
        if otp_data["attempts"] > 3:
            logger.warning(f"üö´ Too many OTP attempts for booking {booking_id[:8]}...")
            del self.otp_store[booking_id]
            return {
                "valid": False,
                "error": "Too many failed attempts (max 3)",
                "should_restart": True
            }
        
        # Verify OTP
        if user_otp != otp_data["otp"]:
            attempts_left = 3 - otp_data["attempts"]
            logger.warning(
                f"‚ùå Wrong OTP for booking {booking_id[:8]}... "
                f"({attempts_left} attempts left)"
            )
            # ‚úÖ DON'T delete here - only after max attempts or success
            return {
                "valid": False,
                "error": f"Wrong OTP. {attempts_left} attempt{'s' if attempts_left > 1 else ''} left.",
                "should_restart": False,
                "attempts_left": attempts_left
            }
        
        # ‚úÖ OTP verified successfully
        logger.info(f"‚úÖ OTP verified successfully for booking {booking_id[:8]}...")
        
        booking_data = otp_data["booking_data"]
        phone = otp_data["phone"]
        language = otp_data["language"]
        
        # ‚úÖ IMPORTANT: Keep OTP data until booking is saved successfully
        # It will be deleted by the orchestrator after successful booking save
        # OR manually after booking failure
        
        return {
            "valid": True,
            "booking_data": booking_data,
            "phone": phone,
            "language": language,
            "verified_at": datetime.utcnow().isoformat(),
            "booking_id": booking_id  # ‚úÖ Return booking_id for cleanup later
        }
    
    def resend_otp(self, booking_id: str, force_new: bool = True) -> Dict[str, Any]:
        """
        Resend OTP for existing booking - ALWAYS generates NEW OTP
        
        Args:
            booking_id: Booking identifier
            force_new: If True, always generate new OTP (default)
            
        Returns:
            Dict with resend result
        """
        logger.info(f"üîÑ Resending OTP for booking {booking_id[:8]}... (force_new={force_new})")
        
        otp_data = self.otp_store.get(booking_id)
        
        if not otp_data:
            logger.warning(f"‚ùå Cannot resend: Booking ID not found {booking_id[:8]}...")
            return {
                "success": False,
                "error": "OTP expired or invalid booking ID",
                "should_regenerate": True
            }
        
        # Check if expired
        now = datetime.utcnow()
        if now > otp_data["expires_at"]:
            logger.warning(f"‚è∞ Cannot resend: OTP expired for {booking_id[:8]}...")
            del self.otp_store[booking_id]
            return {
                "success": False,
                "error": "OTP expired",
                "should_regenerate": True
            }
        
        # Check rate limiting (prevent spam)
        last_sent = otp_data.get("last_sent")
        if last_sent:
            time_since_last = (now - last_sent).total_seconds()
            if time_since_last < 30:  # Minimum 30 seconds between resends
                wait_time = int(30 - time_since_last)
                logger.warning(f"‚è±Ô∏è Rate limit: Wait {wait_time}s before resending")
                return {
                    "success": False,
                    "error": f"Please wait {wait_time} seconds before resending",
                    "should_regenerate": False
                }
        
        # ‚úÖ ALWAYS generate NEW OTP when resending
        new_otp = self.generate_otp()
        
        # Update OTP data
        otp_data["otp"] = new_otp
        otp_data["attempts"] = 0  # ‚úÖ Reset attempts with new OTP
        otp_data["expires_at"] = now + timedelta(minutes=self.expiry_minutes)
        otp_data["last_sent"] = now
        
        phone = otp_data["phone"]
        language = otp_data["language"]
        
        # Send new OTP
        sent = self.send_otp(phone, new_otp, language)
        
        if sent:
            logger.info(f"‚úÖ NEW OTP generated and sent to {phone}")
            return {
                "success": True,
                "phone": phone,
                "new_otp_generated": True,
                "resent_at": now.isoformat()
            }
        else:
            logger.error(f"‚ùå Failed to send new OTP to {phone}")
            return {
                "success": False,
                "error": "Failed to send OTP via SMS",
                "should_regenerate": False
            }
    
    def cleanup_expired_otps(self) -> int:
        """
        Remove expired OTPs from store
        
        Returns:
            Number of expired OTPs cleaned
        """
        expired = []
        now = datetime.utcnow()
        
        for booking_id, data in self.otp_store.items():
            if now > data["expires_at"]:
                expired.append(booking_id)
        
        for booking_id in expired:
            del self.otp_store[booking_id]
        
        if expired:
            logger.info(f"üßπ Cleaned {len(expired)} expired OTP(s)")
        
        return len(expired)
    
    def get_otp_data(self, booking_id: str) -> Optional[Dict]:
        """
        Retrieve OTP data for a booking
        
        Args:
            booking_id: Booking identifier
            
        Returns:
            OTP data dict or None if not found
        """
        data = self.otp_store.get(booking_id)
        
        if data:
            # Check if expired
            if datetime.utcnow() > data["expires_at"]:
                logger.warning(f"‚è∞ Retrieved expired OTP for {booking_id[:8]}...")
                del self.otp_store[booking_id]
                return None
        
        return data
    
    def delete_otp_data(self, booking_id: str) -> bool:
        """
        Delete OTP data for a booking
        
        Args:
            booking_id: Booking identifier
            
        Returns:
            True if deleted, False if not found
        """
        if booking_id in self.otp_store:
            del self.otp_store[booking_id]
            logger.info(f"üóëÔ∏è Deleted OTP data for {booking_id[:8]}...")
            return True
        return False
    
    def get_stats(self) -> Dict[str, Any]:
        """
        Get OTP service statistics
        
        Returns:
            Dict with service stats
        """
        now = datetime.utcnow()
        active_otps = len(self.otp_store)
        expired = sum(1 for data in self.otp_store.values() if now > data["expires_at"])
        
        return {
            "active_otps": active_otps,
            "expired_otps": expired,
            "expiry_minutes": self.expiry_minutes,
            "twilio_configured": self.twilio_client is not None
        }
    
    def _get_otp_message(self, otp: str, language: str) -> str:
        """
        Get OTP message in appropriate language
        
        Args:
            otp: 6-digit OTP
            language: Language code
            
        Returns:
            Formatted OTP message
        """
        messages = {
            "en": f"Your JinniChirag booking OTP is {otp}. Valid for {self.expiry_minutes} minutes. Do not share this code.",
            
            "hi": f"‡§Ü‡§™‡§ï‡§æ JinniChirag ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó OTP {otp} ‡§π‡•à‡•§ {self.expiry_minutes} ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§æ‡§®‡•ç‡§Ø‡•§ ‡§á‡§∏ ‡§ï‡•ã‡§° ‡§ï‡•ã ‡§∏‡§æ‡§ù‡§æ ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§",
            
            "ne": f"‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã JinniChirag ‡§¨‡•Å‡§ï‡§ø‡§ô OTP {otp} ‡§π‡•ã‡•§ {self.expiry_minutes} ‡§Æ‡§ø‡§®‡•á‡§ü‡§ï‡•ã ‡§≤‡§æ‡§ó‡§ø ‡§Æ‡§æ‡§®‡•ç‡§Ø‡•§ ‡§Ø‡•ã ‡§ï‡•ã‡§° ‡§∏‡§æ‡§ù‡§æ ‡§®‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§",
            
            "mr": f"‡§§‡•Å‡§Æ‡§ö‡§æ JinniChirag ‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó OTP {otp} ‡§Ü‡§π‡•á‡•§ {self.expiry_minutes} ‡§Æ‡§ø‡§®‡§ø‡§ü‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä ‡§µ‡•à‡§ß‡•§ ‡§π‡§æ ‡§ï‡•ã‡§° ‡§∂‡•á‡§Ö‡§∞ ‡§ï‡§∞‡•Ç ‡§®‡§ï‡§æ‡•§"
        }
        
        return messages.get(language, messages["en"])


phone_services.py:



"""
Phone number formatting and validation
"""

import re
import logging
from typing import Dict, Optional

from ..config.services_config import COUNTRY_CODES
from ..utils.patterns import PHONE_PATTERNS

logger = logging.getLogger(__name__)

class PhoneService:
    """Service for phone number operations"""
    
    def __init__(self):
        self.country_codes = COUNTRY_CODES
    
    def format_for_api(self, phone: str, country: str = "India") -> str:
        """
        Format phone for API (add country code if missing)
        Input: "+919876543210" or "9876543210"
        Output: "+919876543210"
        """
        if not phone:
            return ""
        
        if phone.startswith('+'):
            digits = re.sub(r'\D', '', phone)
            if len(digits) >= 10:
                return phone
            else:
                return ""
        
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 10:
            return ""
        
        phone_number = digits[-10:]
        country_code = self.country_codes.get(country, "+91")
        
        if country_code.startswith('+'):
            clean_code = country_code[1:]
        else:
            clean_code = country_code
        
        return f"+{clean_code}{phone_number}"
    
    def format_for_display(self, phone: str, country: str = "India") -> str:
        """
        Format phone for display
        Input: "+919876543210"
        Output: "+91 98765 43210"
        """
        if not phone:
            return ""
        
        if phone.startswith('+'):
            digits = phone[1:]
            if len(digits) >= 10:
                country_part = digits[:2] if len(digits) > 10 else "91"
                number_part = digits[-10:] if len(digits) > 10 else digits
                
                if len(number_part) == 10:
                    return f"+{country_part} {number_part[:5]} {number_part[5:]}"
                else:
                    return phone
        else:
            digits = re.sub(r'\D', '', phone)
            if len(digits) >= 10:
                number_part = digits[-10:]
                return f"+91 {number_part[:5]} {number_part[5:]}"
        
        return phone
    
    def validate_with_country_code(self, phone: str) -> Dict:
        """Validate phone number with country code"""
        if not phone:
            return {"valid": False, "error": "Phone number is required"}
        
        phone = phone.strip()
        
        # Must start with +
        if not phone.startswith('+'):
            return {
                "valid": False, 
                "error": "Phone must start with country code (e.g., +91)",
                "suggestion": "Add country code like +91-9876543210"
            }
        
        # Extract digits after +
        digits = re.sub(r'\D', '', phone[1:])
        total_digits = len(digits)
        
        logger.info(f"Phone validation: {phone}, digits: {digits}, total: {total_digits}")
        
        # Check for Indian numbers specifically
        if phone.startswith('+91'):
            if total_digits != 12:
                return {
                    "valid": False,
                    "error": f"Indian number should have 10 digits after +91 (got {total_digits - 2})",
                    "suggestion": "Format: +91-9876543210"
                }
            
            number = digits[2:]
            if number[0] not in ['6', '7', '8', '9']:
                return {
                    "valid": False,
                    "error": "Indian mobile numbers start with 6,7,8, or 9",
                    "suggestion": "Provide a valid Indian mobile number"
                }
            
            return {
                "valid": True,
                "phone": phone,
                "country": "India",
                "formatted": f"+91-{number[:5]}-{number[5:]}"
            }
        
        # For other countries
        country_code = ""
        for i in range(1, 4):
            if i <= len(digits):
                country_code = digits[:i]
                break
        
        code_map = {
            '91': 'India', '977': 'Nepal', '92': 'Pakistan', 
            '880': 'Bangladesh', '971': 'Dubai', '1': 'USA'
        }
        
        country = code_map.get(country_code)
        
        if not country:
            return {
                "valid": False,
                "error": f"Unsupported country code: +{country_code}",
                "suggestion": "Use +91 (India), +977 (Nepal), +92 (Pakistan), +880 (Bangladesh), or +971 (Dubai)"
            }
        
        min_lengths = {
            'India': 10, 'Nepal': 7, 'Pakistan': 10,
            'Bangladesh': 10, 'Dubai': 9, 'USA': 10
        }
        
        min_required = min_lengths.get(country, 7)
        number_digits = total_digits - len(country_code)
        
        if number_digits < min_required:
            return {
                "valid": False,
                "error": f"{country} number needs at least {min_required} digits after country code (got {number_digits})",
                "suggestion": f"Provide full {country} number with +{country_code}"
            }
        
        return {
            "valid": True,
            "phone": phone,
            "country": country,
            "formatted": f"+{country_code}-{digits[len(country_code):]}"
        }
    
    def get_country_from_phone(self, phone: str) -> Optional[str]:
        """Extract country from phone code"""
        if not phone or not phone.startswith('+'):
            return None
        
        # Extract digits after +
        digits = re.sub(r'\D', '', phone[1:])
        
        code_map = {
            '91': 'India', '977': 'Nepal', '92': 'Pakistan', 
            '880': 'Bangladesh', '971': 'Dubai', '1': 'USA'
        }
        
        for i in range(1, 4):
            if i <= len(digits):
                code = digits[:i]
                if code in code_map:
                    return code_map[code]
        
        return None


Below are Utils content...( many things can be migrated here too)

formatters.py:

"""
Data formatting utilities
"""

import re
from typing import Optional

class Formatters:
    """Data formatting utilities"""
    
    @staticmethod
    def format_phone_display(phone: str) -> str:
        """Format phone for display"""
        if not phone:
            return ""
        
        if phone.startswith('+'):
            digits = phone[1:]
            if len(digits) >= 10:
                country_part = digits[:2] if len(digits) > 10 else "91"
                number_part = digits[-10:] if len(digits) > 10 else digits
                
                if len(number_part) == 10:
                    return f"+{country_part} {number_part[:5]} {number_part[5:]}"
                else:
                    return phone
        else:
            digits = re.sub(r'\D', '', phone)
            if len(digits) >= 10:
                number_part = digits[-10:]
                return f"+91 {number_part[:5]} {number_part[5:]}"
        
        return phone
    
    @staticmethod
    def format_date_display(date_str: str) -> Optional[str]:
        """Format date for display"""
        try:
            from datetime import datetime
            date_obj = datetime.strptime(date_str, "%Y-%m-%d")
            return date_obj.strftime("%d %b %Y")
        except:
            return date_str
    
    @staticmethod
    def mask_phone(phone: str) -> str:
        """Mask phone number for display"""
        if not phone or len(phone) < 8:
            return phone
        
        if phone.startswith('+'):
            # Extract digits after +
            digits = phone[1:]
            if len(digits) >= 8:
                return f"+{digits[:4]}****{digits[-4:]}"
        else:
            digits = re.sub(r'\D', '', phone)
            if len(digits) >= 8:
                return f"{digits[:4]}****{digits[-4:]}"
        
        return phone
    
    @staticmethod
    def mask_email(email: str) -> str:
        """Mask email for display"""
        if not email or '@' not in email:
            return email
        
        username, domain = email.split('@')
        if len(username) <= 2:
            return f"{username[0]}***@{domain}"
        else:
            return f"{username[:2]}***@{domain}"


helpers.py:

"""
General helper utilities
"""

import secrets
import logging
from datetime import datetime
from typing import Optional

logger = logging.getLogger(__name__)

class Helpers:
    """Helper utilities"""
    
    @staticmethod
    def generate_session_id() -> str:
        """Generate secure session ID"""
        return secrets.token_urlsafe(16)
    
    @staticmethod
    def generate_booking_id() -> str:
        """Generate secure booking ID"""
        return secrets.token_urlsafe(16)
    
    @staticmethod
    def get_timestamp() -> str:
        """Get current timestamp in ISO format"""
        return datetime.utcnow().isoformat()
    
    @staticmethod
    def log_processing(stage: str, message: str, extra: Optional[dict] = None):
        """Log processing information"""
        log_data = {
            "stage": stage,
            "message_preview": message[:50] + "..." if len(message) > 50 else message,
            "timestamp": Helpers.get_timestamp()
        }
        
        if extra:
            log_data.update(extra)
        
        logger.info(f"üìù Processing: {log_data}")
    
    @staticmethod
    def clean_text(text: str) -> str:
        """Clean and normalize text"""
        if not text:
            return ""
        
        # Remove extra whitespace
        cleaned = ' '.join(text.strip().split())
        
        # Normalize common variations
        replacements = {
            'whatsapp': 'WhatsApp',
            'whats app': 'WhatsApp',
            'pincode': 'PIN code',
            'pin code': 'PIN code',
            'postal code': 'PIN code',
            'zip code': 'PIN code'
        }
        
        for old, new in replacements.items():
            cleaned = cleaned.replace(old, new)
        
        return cleaned


patterns.py:

"""
Centralized regex patterns for extraction
"""

import re

# Phone patterns
PHONE_PATTERNS = {
    "india": r'\+91[\s\-\.]?(\d{10})',
    "nepal": r'\+977[\s\-\.]?(\d{9,10})',
    "generic": r'\+(\d{1,3})[\s\-\.]?(\d{6,})',
    "indian_without_code": r'\b(\d{10})\b'
}

# Email pattern
EMAIL_PATTERN = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

# Date patterns
DATE_PATTERNS = [
    r'\b(\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s*\d{0,4})\b',
    r'\b(\d{4}-\d{1,2}-\d{1,2})\b',
    r'\b(\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{4})\b',
    r'\b(?:today|tomorrow|next week|in a week|after a week|next month|in a month)\b'
]

# Pincode pattern
PINCODE_PATTERN = r'\b(\d{5,6})\b'

# Address indicators
ADDRESS_INDICATORS = [
    'street', 'st.', 'road', 'rd.', 'lane', 'ln.', 'avenue', 'ave.',
    'boulevard', 'blvd.', 'drive', 'dr.', 'circle', 'cir.', 'court', 'ct.',
    'house', 'flat', 'apartment', 'apt.', 'building', 'bldg.', 'floor', 'fl.',
    'room', 'rm.', 'suite', 'ste.', 'unit', 'block', 'blk.',
    'colony', 'sector', 'area', 'locality', 'village', 'town', 'city',
    'district', 'state', 'county', 'province', 'region',
    'near', 'beside', 'opposite', 'behind', 'in front of', 'at', 'by',
    'no.', 'number', '#', 'plot', 'ward', 'mohalla', 'chowk', 'nagar'
]

# Intent keywords
INTENT_KEYWORDS = {
    "booking": [
        "book", "booking", "i want to book", "want to book", "book this",
        "book it", "proceed with booking", "confirm booking", "make booking",
        "schedule", "reserve", "appointment", "i'll book", "let's book",
        "go for", "go with", "choose", "select", "pick", "get", "proceed",
        "confirm", "go ahead", "take", "i'd like to book", "i'd like to make",
        "book for", "book a", "book an", "make a booking", "make reservation"
    ],
    "info": [
        "list", "show", "tell me about", "what are", "what is", "which",
        "how much", "cost", "price", "info", "information", "about",
        "details", "available", "offer", "explain", "describe"
    ],
    "completion": [
        "book now", "proceed", "confirm", "done", "finish", "complete",
        "ok book", "ok proceed", "go ahead", "send otp", "ready",
        "let's book", "book it", "book this", "finalize"
    ]
}

# Frustration keywords
FRUSTRATION_KEYWORDS = [
    'again', 'seriously', 'ugh', 'come on', 'really', 'annoying',
    'frustrating', 'ridiculous', 'whats wrong', "what's wrong",
    'hello?', 'hey', 'are you there', 'anyone', 'this is crazy',
    'unbelievable', 'omg', 'oh my god', 'god', 'jeez', 'jesus',
    'what the hell', 'what the fuck', 'wtf', 'damn', 'dammit',
    'didnt get', "didn't get", 'not getting', 'where is', 'when will'
]

__________________________

Below are validators:
date_validator.py:

"""
Date Validator - Enhanced with comprehensive validation
"""

from datetime import datetime, timedelta
from typing import Dict, Optional
import re


class DateValidator:
    """Validate dates for event scheduling"""
    
    def __init__(self):
        """Initialize date validator"""
        # Supported date formats
        self.supported_formats = [
            '%Y-%m-%d',           # 2026-02-05
            '%d/%m/%Y',           # 05/02/2026
            '%m/%d/%Y',           # 02/05/2026
            '%d-%m-%Y',           # 05-02-2026
            '%Y/%m/%d',           # 2026/02/05
            '%d %b %Y',           # 05 Feb 2026
            '%d %B %Y',           # 05 February 2026
            '%b %d, %Y',          # Feb 05, 2026
            '%B %d, %Y',          # February 05, 2026
        ]
        
        # Month name mapping
        self.month_map = {
            'jan': 1, 'january': 1,
            'feb': 2, 'february': 2,
            'mar': 3, 'march': 3,
            'apr': 4, 'april': 4,
            'may': 5,
            'jun': 6, 'june': 6,
            'jul': 7, 'july': 7,
            'aug': 8, 'august': 8,
            'sep': 9, 'september': 9,
            'oct': 10, 'october': 10,
            'nov': 11, 'november': 11,
            'dec': 12, 'december': 12
        }
    
    def validate(self, date_str: str) -> Dict:
        """
        Validate date string
        
        Returns:
            {
                'valid': bool,
                'date': str (YYYY-MM-DD format),
                'parsed': datetime object,
                'error': str (if invalid),
                'is_future': bool,
                'days_from_now': int
            }
        """
        if not date_str:
            return {
                'valid': False,
                'error': 'Date is required',
                'date': ''
            }
        
        # Clean date string
        cleaned = self._clean_date_string(date_str)
        
        # Try to parse the date
        parsed_date = self._parse_date(cleaned)
        
        if not parsed_date:
            return {
                'valid': False,
                'error': 'Invalid date format',
                'suggestion': 'Use format: 5 Feb 2026, 2026-02-05, or 05/02/2026',
                'date': date_str
            }
        
        # Validate date is reasonable
        validation_result = self._validate_date_constraints(parsed_date)
        
        if not validation_result['valid']:
            return validation_result
        
        # Calculate days from now
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        delta = parsed_date - today
        days_from_now = delta.days
        
        # All validations passed
        return {
            'valid': True,
            'date': parsed_date.strftime('%Y-%m-%d'),
            'parsed': parsed_date,
            'is_future': days_from_now >= 0,
            'days_from_now': days_from_now,
            'formatted': parsed_date.strftime('%d %b %Y')  # 05 Feb 2026
        }
    
    def validate_format(self, date_str: str) -> bool:
        """Validate if date string can be parsed"""
        if not date_str:
            return False
        
        cleaned = self._clean_date_string(date_str)
        parsed_date = self._parse_date(cleaned)
        
        return parsed_date is not None
    
    def validate_future_date(self, date_str: str) -> bool:
        """Validate date is in future"""
        result = self.validate(date_str)
        
        if not result['valid']:
            return False
        
        return result.get('is_future', False)
    
    def get_validation_error(self, date_str: str) -> str:
        """Get validation error message"""
        result = self.validate(date_str)
        
        if result['valid']:
            return ""
        
        return result.get('error', 'Invalid date')
    
    def _clean_date_string(self, date_str: str) -> str:
        """Clean date string for parsing"""
        if not date_str:
            return ""
        
        # Remove extra whitespace
        cleaned = ' '.join(date_str.strip().split())
        
        # Remove ordinal suffixes (st, nd, rd, th)
        cleaned = re.sub(r'(\d+)(st|nd|rd|th)', r'\1', cleaned, flags=re.IGNORECASE)
        
        return cleaned
    
    def _parse_date(self, date_str: str) -> Optional[datetime]:
        """
        Parse date string to datetime object
        Handles multiple formats including invalid dates like "30 feb"
        """
        if not date_str:
            return None
        
        date_lower = date_str.lower()
        
        # Handle relative dates
        if date_lower == 'today':
            return datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        if date_lower == 'tomorrow':
            return (datetime.now() + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Try standard format first
        for fmt in self.supported_formats:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        
        # Try parsing with month names (handles "30 feb 2026")
        parsed = self._parse_month_name_date(date_str)
        if parsed:
            return parsed
        
        return None
    
    def _parse_month_name_date(self, date_str: str) -> Optional[datetime]:
        """
        Parse dates with month names, handling invalid dates like "30 feb"
        """
        date_lower = date_str.lower()
        
        # Pattern: "30 feb 2026" or "30th feb 2026"
        pattern1 = r'(\d{1,2})\s+([a-z]+)\s+(\d{4})'
        match = re.search(pattern1, date_lower)
        
        if match:
            day = int(match.group(1))
            month_name = match.group(2)
            year = int(match.group(3))
            
            # Get month number
            month = self.month_map.get(month_name)
            if not month:
                return None
            
            # Handle invalid day for month
            import calendar
            max_day = calendar.monthrange(year, month)[1]
            
            if day > max_day:
                # Adjust to last valid day of month
                day = max_day
            
            try:
                return datetime(year, month, day)
            except ValueError:
                return None
        
        # Pattern: "feb 30 2026" or "february 30 2026"
        pattern2 = r'([a-z]+)\s+(\d{1,2})\s+(\d{4})'
        match = re.search(pattern2, date_lower)
        
        if match:
            month_name = match.group(1)
            day = int(match.group(2))
            year = int(match.group(3))
            
            month = self.month_map.get(month_name)
            if not month:
                return None
            
            import calendar
            max_day = calendar.monthrange(year, month)[1]
            
            if day > max_day:
                day = max_day
            
            try:
                return datetime(year, month, day)
            except ValueError:
                return None
        
        # Pattern: "30 feb" (no year)
        pattern3 = r'(\d{1,2})\s+([a-z]+)$'
        match = re.search(pattern3, date_lower)
        
        if match:
            day = int(match.group(1))
            month_name = match.group(2)
            
            month = self.month_map.get(month_name)
            if not month:
                return None
            
            # Use current year or next year
            current_date = datetime.now()
            year = current_date.year
            
            # If month has passed this year, use next year
            if month < current_date.month or (month == current_date.month and day < current_date.day):
                year = current_date.year + 1
            
            import calendar
            max_day = calendar.monthrange(year, month)[1]
            
            if day > max_day:
                day = max_day
            
            try:
                return datetime(year, month, day)
            except ValueError:
                return None
        
        # Pattern: "feb 30" (no year)
        pattern4 = r'([a-z]+)\s+(\d{1,2})$'
        match = re.search(pattern4, date_lower)
        
        if match:
            month_name = match.group(1)
            day = int(match.group(2))
            
            month = self.month_map.get(month_name)
            if not month:
                return None
            
            current_date = datetime.now()
            year = current_date.year
            
            if month < current_date.month or (month == current_date.month and day < current_date.day):
                year = current_date.year + 1
            
            import calendar
            max_day = calendar.monthrange(year, month)[1]
            
            if day > max_day:
                day = max_day
            
            try:
                return datetime(year, month, day)
            except ValueError:
                return None
        
        return None
    
    def _validate_date_constraints(self, date: datetime) -> Dict:
        """Validate date constraints"""
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Calculate difference
        delta = date - today
        days_diff = delta.days
        
        # Check if date is too far in the past
        if days_diff < -7:
            return {
                'valid': False,
                'error': f'Date is {abs(days_diff)} days in the past',
                'suggestion': 'Please provide a current or future date'
            }
        
        # Check if date is too far in future (more than 2 years)
        if days_diff > 730:  # ~2 years
            return {
                'valid': False,
                'error': f'Date is {days_diff} days in the future',
                'suggestion': 'Please provide a date within the next 2 years'
            }
        
        # Warn if date is in very near future (less than 3 days)
        warning = None
        if 0 <= days_diff < 3:
            warning = f'Event is only {days_diff} day(s) away. Please ensure availability.'
        
        return {
            'valid': True,
            'warning': warning
        }


email_validator.py:

"""
Email Validator - Enhanced with comprehensive validation
"""

import re
from typing import Dict


class EmailValidator:
    """Validate email addresses"""
    
    def __init__(self):
        """Initialize email validator"""
        # Comprehensive email regex pattern
        self.email_pattern = re.compile(
            r'^[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9][a-zA-Z0-9.-]*\.[a-zA-Z]{2,}$'
        )
        
        # Common disposable email domains to warn about
        self.disposable_domains = {
            'tempmail.com', 'guerrillamail.com', '10minutemail.com',
            'mailinator.com', 'throwaway.email', 'temp-mail.org'
        }
        
        # Trusted email providers
        self.trusted_providers = {
            'gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com',
            'icloud.com', 'protonmail.com', 'aol.com', 'live.com',
            'mail.com', 'zoho.com', 'yandex.com'
        }
    
    def validate(self, email: str) -> Dict:
        """
        Validate email address
        
        Returns:
            {
                'valid': bool,
                'email': str (cleaned),
                'error': str (if invalid),
                'warning': str (if disposable),
                'provider': str (domain)
            }
        """
        if not email:
            return {
                'valid': False,
                'error': 'Email address is required',
                'email': ''
            }
        
        # Clean email
        cleaned = self._clean_email(email)
        
        # Basic format validation
        if not self.validate_format(cleaned):
            error = self._get_format_error(cleaned)
            return {
                'valid': False,
                'error': error,
                'email': email
            }
        
        # Extract domain
        domain = cleaned.split('@')[1].lower()
        
        # Check for disposable email
        warning = None
        if domain in self.disposable_domains:
            warning = 'This appears to be a temporary/disposable email address'
        
        # Additional validations
        validation_errors = []
        
        # Check for consecutive dots
        if '..' in cleaned:
            validation_errors.append('Email cannot contain consecutive dots')
        
        # Check for dot before @
        local_part = cleaned.split('@')[0]
        if local_part.startswith('.') or local_part.endswith('.'):
            validation_errors.append('Email cannot start or end with a dot before @')
        
        # Check domain has at least one dot
        if '.' not in domain:
            validation_errors.append('Email domain must contain at least one dot')
        
        # Check TLD length
        tld = domain.split('.')[-1]
        if len(tld) < 2:
            validation_errors.append('Top-level domain must be at least 2 characters')
        
        if validation_errors:
            return {
                'valid': False,
                'error': '; '.join(validation_errors),
                'email': email
            }
        
        # All validations passed
        return {
            'valid': True,
            'email': cleaned,
            'provider': domain,
            'is_trusted': domain in self.trusted_providers,
            'warning': warning
        }
    
    def validate_format(self, email: str) -> bool:
        """Validate email format using regex"""
        if not email:
            return False
        
        # Must contain exactly one @
        if email.count('@') != 1:
            return False
        
        # Match against pattern
        return bool(self.email_pattern.match(email))
    
    def get_validation_error(self, email: str) -> str:
        """Get validation error message"""
        result = self.validate(email)
        if result['valid']:
            return ""
        return result.get('error', 'Invalid email address')
    
    def _clean_email(self, email: str) -> str:
        """Clean email address"""
        if not email:
            return ""
        
        # Remove leading/trailing whitespace
        cleaned = email.strip()
        
        # Remove any quotes
        cleaned = cleaned.replace('"', '').replace("'", "")
        
        # Convert to lowercase (email addresses are case-insensitive)
        cleaned = cleaned.lower()
        
        return cleaned
    
    def _get_format_error(self, email: str) -> str:
        """Get specific format error message"""
        if not email:
            return "Email address is required"
        
        if '@' not in email:
            return "Email must contain @ symbol"
        
        if email.count('@') > 1:
            return "Email must contain exactly one @ symbol"
        
        parts = email.split('@')
        if len(parts[0]) == 0:
            return "Email must have a username before @"
        
        if len(parts[1]) == 0:
            return "Email must have a domain after @"
        
        if '.' not in parts[1]:
            return "Email domain must contain a dot (.)"
        
        # Check for invalid characters
        if re.search(r'[^a-zA-Z0-9._%+-@]', email):
            return "Email contains invalid characters"
        
        # Check local part (before @)
        if parts[0].startswith('.') or parts[0].endswith('.'):
            return "Email username cannot start or end with a dot"
        
        if '..' in email:
            return "Email cannot contain consecutive dots"
        
        # Check domain part (after @)
        domain = parts[1]
        if domain.startswith('.') or domain.endswith('.'):
            return "Email domain cannot start or end with a dot"
        
        # Check TLD
        domain_parts = domain.split('.')
        tld = domain_parts[-1]
        if len(tld) < 2:
            return "Email domain extension must be at least 2 characters"
        
        if not tld.isalpha():
            return "Email domain extension must contain only letters"
        
        return "Invalid email format. Example: user@example.com"
    
    def suggest_correction(self, email: str) -> str:
        """Suggest email correction"""
        if not email:
            return "Example: john.doe@gmail.com"
        
        # Check for common typos in domains
        common_typos = {
            'gmial.com': 'gmail.com',
            'gmai.com': 'gmail.com',
            'gnail.com': 'gmail.com',
            'yahooo.com': 'yahoo.com',
            'yaho.com': 'yahoo.com',
            'hotmial.com': 'hotmail.com',
            'hotmal.com': 'hotmail.com',
            'outlok.com': 'outlook.com',
        }
        
        if '@' in email:
            parts = email.split('@')
            domain = parts[1].lower()
            
            if domain in common_typos:
                return f"Did you mean {parts[0]}@{common_typos[domain]}?"
        
        return "Example: john.doe@gmail.com"


phone_validator.py:

"""
Phone Validator - Enhanced with comprehensive validation
"""

import re
from typing import Dict, Optional


class PhoneValidator:
    """Validate phone numbers with country code support"""
    
    def __init__(self):
        """Initialize phone validator"""
        # Country code patterns and rules
        self.country_rules = {
            '91': {
                'name': 'India',
                'length': 10,
                'pattern': r'^[6-9]\d{9}$',
                'format': '+91-XXXXXXXXXX'
            },
            '977': {
                'name': 'Nepal',
                'length': 10,
                'pattern': r'^9[678]\d{8}$',
                'format': '+977-XXXXXXXXXX'
            },
            '92': {
                'name': 'Pakistan',
                'length': 10,
                'pattern': r'^3\d{9}$',
                'format': '+92-3XXXXXXXXX'
            },
            '880': {
                'name': 'Bangladesh',
                'length': 10,
                'pattern': r'^1[3-9]\d{8}$',
                'format': '+880-1XXXXXXXXX'
            },
            '971': {
                'name': 'Dubai',
                'length': 9,
                'pattern': r'^5[024568]\d{7}$',
                'format': '+971-5XXXXXXXX'
            },
            '1': {
                'name': 'USA/Canada',
                'length': 10,
                'pattern': r'^[2-9]\d{9}$',
                'format': '+1-XXXXXXXXXX'
            }
        }
    
    def validate(self, phone: str) -> Dict:
        """
        Validate phone number
        
        Returns:
            {
                'valid': bool,
                'phone': str (cleaned),
                'country': str,
                'country_code': str,
                'error': str (if invalid),
                'suggestion': str (if invalid)
            }
        """
        if not phone:
            return {
                'valid': False,
                'error': 'Phone number is required',
                'suggestion': 'Please provide your WhatsApp number with country code (e.g., +91-9876543210)'
            }
        
        # Clean phone number
        cleaned = self._clean_phone(phone)
        
        # Must start with +
        if not cleaned.startswith('+'):
            return {
                'valid': False,
                'error': 'Phone number must include country code starting with +',
                'suggestion': 'Format: +91-9876543210 (India), +977-9851234567 (Nepal), etc.',
                'phone': phone
            }
        
        # Extract country code and number
        result = self._extract_country_and_number(cleaned)
        if not result:
            return {
                'valid': False,
                'error': 'Invalid phone number format',
                'suggestion': 'Please provide in format: +[country code]-[number]',
                'phone': phone
            }
        
        country_code, number = result
        
        # Validate with country code
        return self.validate_with_country_code(f"+{country_code}{number}")
    
    def validate_indian(self, phone: str) -> Dict:
        """Validate Indian phone number"""
        cleaned = self._clean_phone(phone)
        
        # Extract digits only
        digits = re.sub(r'\D', '', cleaned)
        
        # Check if it has +91
        if cleaned.startswith('+91'):
            digits = digits[2:]  # Remove 91
        elif len(digits) == 10:
            # Assume India if 10 digits
            pass
        else:
            return {
                'valid': False,
                'error': 'Indian number must be 10 digits',
                'suggestion': 'Format: +91-9876543210',
                'phone': phone
            }
        
        # Validate Indian mobile pattern
        if not re.match(r'^[6-9]\d{9}$', digits):
            return {
                'valid': False,
                'error': 'Indian mobile numbers must start with 6, 7, 8, or 9',
                'suggestion': 'Format: +91-9876543210 (10 digits starting with 6-9)',
                'phone': phone
            }
        
        return {
            'valid': True,
            'phone': f"+91{digits}",
            'country': 'India',
            'country_code': '91',
            'formatted': f"+91-{digits[:5]} {digits[5:]}"
        }
    
    def validate_international(self, phone: str) -> Dict:
        """Validate international phone number"""
        cleaned = self._clean_phone(phone)
        
        if not cleaned.startswith('+'):
            return {
                'valid': False,
                'error': 'International number must start with + and country code',
                'suggestion': 'Format: +[country code]-[number]',
                'phone': phone
            }
        
        return self.validate_with_country_code(cleaned)
    
    def validate_with_country_code(self, phone: str) -> Dict:
        """
        Validate phone has proper country code and format
        
        This is the MAIN validation method used by FSM
        """
        if not phone:
            return {
                'valid': False,
                'error': 'Phone number is required',
                'suggestion': 'Provide WhatsApp number with country code',
                'phone': phone
            }
        
        cleaned = self._clean_phone(phone)
        
        # Must start with +
        if not cleaned.startswith('+'):
            return {
                'valid': False,
                'error': 'Must include country code (starting with +)',
                'suggestion': 'Format: +91-9876543210 (India), +977-9851234567 (Nepal)',
                'phone': phone
            }
        
        # Extract country code and number
        result = self._extract_country_and_number(cleaned)
        if not result:
            return {
                'valid': False,
                'error': 'Invalid phone number format',
                'suggestion': 'Format: +[country code]-[number]',
                'phone': phone
            }
        
        country_code, number = result
        
        # Check if we support this country
        if country_code not in self.country_rules:
            return {
                'valid': False,
                'error': f'Country code +{country_code} not supported',
                'suggestion': 'Supported: India (+91), Nepal (+977), Pakistan (+92), Bangladesh (+880), Dubai (+971)',
                'phone': phone
            }
        
        # Get country rules
        rules = self.country_rules[country_code]
        
        # Validate length
        if len(number) != rules['length']:
            return {
                'valid': False,
                'error': f"{rules['name']} numbers must be {rules['length']} digits",
                'suggestion': f"Format: {rules['format']}",
                'phone': phone
            }
        
        # Validate pattern
        if not re.match(rules['pattern'], number):
            return {
                'valid': False,
                'error': f"Invalid {rules['name']} number format",
                'suggestion': f"Format: {rules['format']}",
                'phone': phone
            }
        
        # All validations passed
        return {
            'valid': True,
            'phone': f"+{country_code}{number}",
            'country': rules['name'],
            'country_code': country_code,
            'formatted': self._format_phone_display(f"+{country_code}{number}")
        }
    
    def get_validation_error(self, phone: str) -> str:
        """Get validation error message"""
        result = self.validate(phone)
        if result['valid']:
            return ""
        return result.get('error', 'Invalid phone number')
    
    def suggest_correction(self, phone: str) -> str:
        """Suggest phone number correction"""
        result = self.validate(phone)
        if result['valid']:
            return ""
        return result.get('suggestion', 'Please provide valid phone number with country code')
    
    def _clean_phone(self, phone: str) -> str:
        """Clean phone number - keep + and digits only"""
        if not phone:
            return ""
        
        # Keep + at start and all digits
        cleaned = phone.strip()
        
        # Remove common separators but keep + at start
        if cleaned.startswith('+'):
            # Keep the +, remove everything except digits after it
            prefix = '+'
            rest = re.sub(r'[^\d]', '', cleaned[1:])
            return prefix + rest
        else:
            # Just digits
            return re.sub(r'\D', '', cleaned)
    
    def _extract_country_and_number(self, phone: str) -> Optional[tuple]:
        """
        Extract country code and number from phone
        
        Returns: (country_code, number) or None
        """
        if not phone or not phone.startswith('+'):
            return None
        
        # Remove +
        digits = phone[1:]
        
        # Try to match known country codes (1-3 digits)
        for length in [3, 2, 1]:
            if len(digits) > length:
                potential_code = digits[:length]
                if potential_code in self.country_rules:
                    number = digits[length:]
                    return (potential_code, number)
        
        return None
    
    def _format_phone_display(self, phone: str) -> str:
        """Format phone for display"""
        if not phone or not phone.startswith('+'):
            return phone
        
        result = self._extract_country_and_number(phone)
        if not result:
            return phone
        
        country_code, number = result
        
        # Format based on country
        if country_code == '91':  # India
            return f"+91-{number[:5]} {number[5:]}"
        elif country_code == '977':  # Nepal
            return f"+977-{number[:3]} {number[3:6]} {number[6:]}"
        elif country_code == '92':  # Pakistan
            return f"+92-{number[:3]} {number[3:]}"
        elif country_code == '880':  # Bangladesh
            return f"+880-{number[:4]} {number[4:]}"
        elif country_code == '971':  # Dubai
            return f"+971-{number[:2]} {number[2:5]} {number[5:]}"
        elif country_code == '1':  # USA/Canada
            return f"+1-{number[:3]} {number[3:6]} {number[6:]}"
        else:
            return f"+{country_code}-{number}"


pincode_validator.py:

"""
Pincode Validator - Enhanced with comprehensive validation
"""

import re
from typing import Dict, Optional


class PincodeValidator:
    """Validate PIN/postal codes for different countries"""
    
    def __init__(self):
        """Initialize pincode validator"""
        # Country-specific pincode rules
        self.country_rules = {
            'India': {
                'length': 6,
                'pattern': r'^[1-9]\d{5}$',
                'format': '6 digits starting with 1-9',
                'example': '400001'
            },
            'Nepal': {
                'length': 5,
                'pattern': r'^\d{5}$',
                'format': '5 digits',
                'example': '44600'
            },
            'Pakistan': {
                'length': 5,
                'pattern': r'^\d{5}$',
                'format': '5 digits',
                'example': '75500'
            },
            'Bangladesh': {
                'length': 4,
                'pattern': r'^\d{4}$',
                'format': '4 digits',
                'example': '1000'
            },
            'Dubai': {
                'length': 5,
                'pattern': r'^\d{5}$',
                'format': '5 digits',
                'example': '00000'
            }
        }
        
        # Region validation for India (first digit indicates region)
        self.india_regions = {
            '1': 'Delhi, Haryana, Punjab',
            '2': 'Himachal Pradesh, Jammu & Kashmir',
            '3': 'Rajasthan, Punjab',
            '4': 'Maharashtra, Goa',
            '5': 'Karnataka, Andhra Pradesh',
            '6': 'Tamil Nadu, Kerala',
            '7': 'West Bengal, Odisha',
            '8': 'Bihar, Jharkhand',
            '9': 'Uttar Pradesh, Uttarakhand'
        }
    
    def validate(self, pincode: str, country: str) -> Dict:
        """
        Validate pincode for given country
        
        Returns:
            {
                'valid': bool,
                'pincode': str (cleaned),
                'country': str,
                'error': str (if invalid),
                'region': str (for India),
                'format': str
            }
        """
        if not pincode:
            return {
                'valid': False,
                'error': 'PIN/postal code is required',
                'pincode': ''
            }
        
        if not country:
            return {
                'valid': False,
                'error': 'Country is required to validate PIN code',
                'pincode': pincode
            }
        
        # Clean pincode
        cleaned = self._clean_pincode(pincode)
        
        # Check if country is supported
        if country not in self.country_rules:
            return {
                'valid': False,
                'error': f'PIN code validation not supported for {country}',
                'pincode': pincode,
                'country': country
            }
        
        # Get country-specific rules
        rules = self.country_rules[country]
        
        # Validate length
        if len(cleaned) != rules['length']:
            return {
                'valid': False,
                'error': f"{country} PIN codes must be {rules['length']} digits",
                'suggestion': f"Format: {rules['format']} (Example: {rules['example']})",
                'pincode': pincode,
                'country': country
            }
        
        # Validate pattern
        if not re.match(rules['pattern'], cleaned):
            return {
                'valid': False,
                'error': f"Invalid {country} PIN code format",
                'suggestion': f"Format: {rules['format']} (Example: {rules['example']})",
                'pincode': pincode,
                'country': country
            }
        
        # Country-specific validations
        if country == 'India':
            return self._validate_indian_pincode(cleaned)
        elif country == 'Nepal':
            return self._validate_nepali_pincode(cleaned)
        else:
            # Generic success for other countries
            return {
                'valid': True,
                'pincode': cleaned,
                'country': country,
                'format': rules['format']
            }
    
    def validate_indian(self, pincode: str) -> bool:
        """Validate Indian pincode (returns bool for backward compatibility)"""
        result = self._validate_indian_pincode(pincode)
        return result['valid']
    
    def validate_nepali(self, pincode: str) -> bool:
        """Validate Nepali pincode (returns bool for backward compatibility)"""
        result = self._validate_nepali_pincode(pincode)
        return result['valid']
    
    def get_validation_error(self, pincode: str, country: str) -> str:
        """Get validation error message"""
        result = self.validate(pincode, country)
        
        if result['valid']:
            return ""
        
        return result.get('error', 'Invalid PIN code')
    
    def _clean_pincode(self, pincode: str) -> str:
        """Clean pincode - keep only digits"""
        if not pincode:
            return ""
        
        # Remove all non-digit characters
        cleaned = re.sub(r'\D', '', pincode.strip())
        
        return cleaned
    
    def _validate_indian_pincode(self, pincode: str) -> Dict:
        """Validate Indian pincode with region detection"""
        cleaned = self._clean_pincode(pincode)
        
        # Must be 6 digits
        if len(cleaned) != 6:
            return {
                'valid': False,
                'error': 'Indian PIN codes must be 6 digits',
                'suggestion': 'Example: 400001 (Mumbai)',
                'pincode': pincode
            }
        
        # Must start with 1-9 (not 0)
        if cleaned[0] == '0':
            return {
                'valid': False,
                'error': 'Indian PIN codes cannot start with 0',
                'suggestion': 'Example: 400001, 110001, 560001',
                'pincode': pincode
            }
        
        # Get region from first digit
        first_digit = cleaned[0]
        region = self.india_regions.get(first_digit, 'Unknown region')
        
        return {
            'valid': True,
            'pincode': cleaned,
            'country': 'India',
            'region': region,
            'format': '6 digits'
        }
    
    def _validate_nepali_pincode(self, pincode: str) -> Dict:
        """Validate Nepali pincode"""
        cleaned = self._clean_pincode(pincode)
        
        # Must be 5 digits
        if len(cleaned) != 5:
            return {
                'valid': False,
                'error': 'Nepali postal codes must be 5 digits',
                'suggestion': 'Example: 44600 (Kathmandu)',
                'pincode': pincode
            }
        
        # All digits (0-9 allowed)
        if not cleaned.isdigit():
            return {
                'valid': False,
                'error': 'Nepali postal codes must contain only digits',
                'pincode': pincode
            }
        
        # Region detection for Nepal (basic)
        region = self._get_nepali_region(cleaned)
        
        return {
            'valid': True,
            'pincode': cleaned,
            'country': 'Nepal',
            'region': region,
            'format': '5 digits'
        }
    
    def _get_nepali_region(self, pincode: str) -> str:
        """Get region from Nepali pincode (basic mapping)"""
        if not pincode or len(pincode) != 5:
            return 'Unknown'
        
        # Basic region mapping (first 2 digits)
        prefix = pincode[:2]
        
        nepal_regions = {
            '44': 'Kathmandu Valley',
            '33': 'Pokhara',
            '56': 'Biratnagar',
            '10': 'Far Western Region',
            '21': 'Mid Western Region',
            '45': 'Lalitpur',
            '46': 'Bhaktapur'
        }
        
        return nepal_regions.get(prefix, 'Nepal')
    
    def infer_country_from_pincode(self, pincode: str) -> Optional[str]:
        """Infer country from pincode length and format"""
        if not pincode:
            return None
        
        cleaned = self._clean_pincode(pincode)
        length = len(cleaned)
        
        # Try to infer based on length and pattern
        if length == 6 and cleaned[0] != '0':
            # Likely India
            return 'India'
        elif length == 5:
            # Could be Nepal, Pakistan, or Dubai
            # Default to Nepal if no other info
            return 'Nepal'
        elif length == 4:
            # Likely Bangladesh
            return 'Bangladesh'
        
        return None

________________


Below are handler and all fines are empty:
    Directory: C:\Users\Dell\OneDrive\Desktop\BtechProject\chirag-sharma-backend\agent\handlers

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---           1/24/2026 12:46 AM              0 __init__.py
-a---           1/24/2026 12:46 AM              0 base_handler.py
-a---           1/24/2026 12:46 AM              0 confirmation_handler.py
-a---           1/24/2026 12:46 AM              0 details_handler.py
-a---           1/24/2026 12:46 AM              0 greeting_handler.py
-a---           1/24/2026 12:46 AM              0 info_handler.py
-a---           1/24/2026 12:46 AM              0 otp_handler.py
-a---           1/24/2026 12:46 AM              0 package_handler.py
-a---           1/24/2026 12:46 AM              0 service_handler.py

(venv) PS C:\Users\Dell\OneDrive\Desktop\BtechProject\chirag-sharma-backend\agent\handlers>


_____________________

Beloware my api code which is perfect:
    Directory: C:\Users\Dell\OneDrive\Desktop\BtechProject\chirag-sharma-backend\agent\api

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d----           1/24/2026  2:43 AM                __pycache__
-a---           1/24/2026 12:46 AM              0 __init__.py
-a---           1/24/2026  1:54 AM           5404 endpoints.py
-a---           1/24/2026  1:54 AM            636 router.py

(venv) PS C:\Users\Dell\OneDrive\Desktop\BtechProject\chirag-sharma-backend\agent\api> 

if you want to see code:

endpoints.py:
"""
Agent API Endpoints
"""

import logging
from fastapi import HTTPException, Depends
from datetime import datetime
from typing import Dict

from ..models.api_models import AgentChatRequest, AgentChatResponse
from ..orchestrator import AgentOrchestrator
from ..services.memory_service import MemoryService

logger = logging.getLogger(__name__)


class AgentEndpoints:
    """Agent API endpoint handlers"""
    
    def __init__(self, orchestrator: AgentOrchestrator):
        """Initialize endpoints"""
        self.orchestrator = orchestrator
        self.memory_service = orchestrator.memory_service
        
        logger.info("AgentEndpoints initialized")
    
    async def chat(self, request: AgentChatRequest) -> AgentChatResponse:
        """Main chat endpoint"""
        try:
            # Validate request
            self._validate_request(request)
            
            logger.info(f"Chat request: session={request.session_id}, lang={request.language}")
            
            # Process message
            result = await self.orchestrator.process_message(
                message=request.message,
                session_id=request.session_id,
                language=request.language
            )
            
            # Convert to AgentChatResponse
            response = self._build_response(result)
            
            logger.info(f"Chat response: session={response.session_id}, stage={response.stage}")
            
            return response
            
        except ValueError as e:
            logger.warning(f"Validation error: {e}")
            raise HTTPException(status_code=400, detail=str(e))
        except Exception as e:
            logger.error(f"Chat endpoint error: {e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def get_sessions(self):
        """Get session statistics"""
        try:
            stats = self.memory_service.get_stats()
            return {
                "status": "ok",
                "timestamp": datetime.utcnow().isoformat(),
                "stats": stats
            }
        except Exception as e:
            logger.error(f"Get sessions error: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def cleanup(self):
        """Force cleanup of expired sessions"""
        try:
            cleaned = self.memory_service.cleanup_old_sessions()
            return {
                "status": "ok",
                "cleaned": cleaned,
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.error(f"Cleanup error: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def delete_session(self, session_id: str):
        """Delete specific session"""
        try:
            deleted = self.memory_service.delete_session(session_id)
            if deleted:
                return {
                    "status": "ok",
                    "message": "Session deleted",
                    "session_id": session_id
                }
            else:
                raise HTTPException(status_code=404, detail="Session not found")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Delete session error: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def health_check(self):
        """Health check endpoint"""
        try:
            stats = self.memory_service.get_stats()
            return {
                "status": "healthy",
                "timestamp": datetime.utcnow().isoformat(),
                "active_sessions": stats.get("active_sessions", 0),
                "memory_service": "operational"
            }
        except Exception as e:
            logger.error(f"Health check error: {e}")
            raise HTTPException(status_code=503, detail="Service unhealthy")
    
    def _validate_request(self, request: AgentChatRequest) -> None:
        """Validate incoming request"""
        # Message validation
        if not request.message or len(request.message.strip()) == 0:
            raise ValueError("Message cannot be empty")
        
        if len(request.message) > 1000:
            raise ValueError("Message too long (max 1000 characters)")
        
        # Language validation
        if request.language not in ["en", "ne", "hi", "mr"]:
            raise ValueError(f"Unsupported language: {request.language}")
    
    def _build_response(self, result: dict) -> AgentChatResponse:
        """Build response from orchestrator result"""
        try:
            return AgentChatResponse(**result)
        except Exception as e:
            logger.error(f"Error building AgentChatResponse: {e}")
            
            # Create a fallback response
            return AgentChatResponse(
                reply="Sorry, there was an error processing your request.",
                session_id=result.get("session_id", "error"),
                stage="error",
                action="error",
                missing_fields=[],
                collected_info={},
                chat_mode="normal"
            )

________

router.py:

"""
Agent API Router
"""

from fastapi import APIRouter
from .endpoints import AgentEndpoints


def create_agent_router(orchestrator) -> APIRouter:
    """Create and configure agent router"""
    
    router = APIRouter(prefix="/agent", tags=["Agent Chat"])
    endpoints = AgentEndpoints(orchestrator)
    
    # Register endpoints
    router.post("/chat")(endpoints.chat)
    router.get("/sessions")(endpoints.get_sessions)
    router.post("/cleanup")(endpoints.cleanup)
    router.delete("/sessions/{session_id}")(endpoints.delete_session)
    router.get("/health")(endpoints.health_check)
    
    return router

____________

I want to decrease the length of fsm and orchestrator by migrating content from orchestractor and fsm to these listed files wherever suitable...
Help me decrease the length and make my code more modular...

NOTE: I dont want to make any function weak decreasing anything that are necessaery.

At first Give me Structure clearly.
